This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
debug_data/
  .key
src/
  application/
    interfaces/
      __init__.py
      ai_port.py
      browser_port.py
      storage_port.py
    use_cases/
      __init__.py
      apply_to_job.py
      bot_orchestrator.py
    __init__.py
  config/
    __init__.py
    settings.py
  domain/
    entities/
      __init__.py
      application.py
      candidate.py
      job.py
    services/
      __init__.py
      opsec_service.py
    value_objects/
      __init__.py
      credentials.py
      job_filter.py
    __init__.py
  infrastructure/
    ai/
      __init__.py
      openai_adapter.py
      prompt_builder.py
    browser/
      __init__.py
      camoufox_adapter.py
      cookie_manager.py
      human_simulator.py
    parsers/
      __init__.py
      job_parser.py
      resume_parser.py
    security/
      __init__.py
      crypto.py
    storage/
      __init__.py
      migrations.py
      sqlite_adapter.py
    __init__.py
  presentation/
    gui/
      components/
        __init__.py
        controls.py
        credentials.py
        job_panel.py
        log_dashboard.py
        profile.py
        resume_upload.py
        theme_toggle.py
      styles/
        __init__.py
        theme.py
      __init__.py
      app.py
    __init__.py
  __init__.py
  main.py
tests/
  unit/
    __init__.py
    test_entities.py
    test_opsec_service.py
  __init__.py
.env.example
.gitignore
GLOBAL_RULES.md
PRD.md
pyproject.toml
README.md
requirements.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="debug_data/.key">
mNZdHtgtdcrJhiYhg-CLKnKgKyGht4gMlQI8synyT0Q=
</file>

<file path="src/application/interfaces/__init__.py">
# Interfaces Package
from .browser_port import BrowserPort
from .ai_port import AIPort
from .storage_port import StoragePort

__all__ = ["BrowserPort", "AIPort", "StoragePort"]
</file>

<file path="src/application/interfaces/ai_port.py">
"""
AI Port - Abstract interface for AI operations.
"""

from abc import ABC, abstractmethod
from typing import Optional

from src.infrastructure.ai.prompt_builder import PromptResult


class AIPort(ABC):
    """Abstract interface for AI operations."""
    
    @abstractmethod
    def initialize(self) -> None:
        """Initialize the AI service."""
        pass
    
    @abstractmethod
    async def answer_text_question(
        self,
        prompt: PromptResult,
    ) -> tuple[str, int]:
        """Answer a text question. Returns (answer, tokens_used)."""
        pass
    
    @abstractmethod
    async def get_selected_option(
        self,
        prompt: PromptResult,
        options: list[str],
    ) -> tuple[str, int]:
        """Select an option. Returns (selected_option, tokens_used)."""
        pass
    
    @abstractmethod
    async def health_check(self) -> bool:
        """Check if AI service is available."""
        pass
</file>

<file path="src/application/interfaces/browser_port.py">
"""
Browser Port - Abstract interface for browser operations.

Following Clean Architecture, this defines the contract that
any browser adapter must implement.
"""

from abc import ABC, abstractmethod
from pathlib import Path
from typing import Optional


class BrowserPort(ABC):
    """Abstract interface for browser automation."""
    
    @abstractmethod
    async def start(self) -> None:
        """Start the browser."""
        pass
    
    @abstractmethod
    async def stop(self) -> None:
        """Stop the browser."""
        pass
    
    @abstractmethod
    async def is_logged_in(self) -> bool:
        """Check if logged into LinkedIn."""
        pass
    
    @abstractmethod
    async def login(self, username: str, password: str) -> bool:
        """Log into LinkedIn."""
        pass
    
    @abstractmethod
    async def navigate(self, url: str) -> None:
        """Navigate to a URL."""
        pass
    
    @abstractmethod
    async def search_jobs(
        self,
        keywords: list[str],
        location: str = "",
        remote_only: bool = False,
    ) -> str:
        """Search for jobs and return the results URL."""
        pass
    
    @abstractmethod
    async def upload_file_invisible(
        self,
        file_path: Path,
        input_selector: str = 'input[type="file"]',
    ) -> bool:
        """Upload a file without dialog."""
        pass
    
    @abstractmethod
    async def take_screenshot(self, path: Path) -> None:
        """Take a screenshot."""
        pass
    
    @abstractmethod
    async def get_page_content(self) -> str:
        """Get current page HTML."""
        pass
</file>

<file path="src/application/interfaces/storage_port.py">
"""
Storage Port - Abstract interface for data persistence.
"""

from abc import ABC, abstractmethod
from datetime import date, datetime
from typing import Optional

from src.domain.entities import Application, ApplicationStatus
from src.domain.value_objects import Credentials, JobFilter


class StoragePort(ABC):
    """Abstract interface for data storage."""
    
    @abstractmethod
    async def initialize(self) -> None:
        """Initialize storage connection."""
        pass
    
    @abstractmethod
    async def close(self) -> None:
        """Close storage connection."""
        pass
    
    # Config
    @abstractmethod
    async def get_config(self, key: str, default: Optional[str] = None) -> Optional[str]:
        """Get a config value."""
        pass
    
    @abstractmethod
    async def set_config(self, key: str, value: str) -> None:
        """Set a config value."""
        pass
    
    # Credentials
    @abstractmethod
    async def save_credentials(self, credentials: Credentials) -> None:
        """Save credentials."""
        pass
    
    @abstractmethod
    async def get_credentials(self) -> Optional[Credentials]:
        """Get stored credentials."""
        pass
    
    # Job Filter
    @abstractmethod
    async def save_job_filter(self, job_filter: JobFilter) -> None:
        """Save job filter settings."""
        pass
    
    @abstractmethod
    async def get_job_filter(self) -> Optional[JobFilter]:
        """Get saved job filter."""
        pass
    
    # Applications
    @abstractmethod
    async def save_application(self, application: Application) -> int:
        """Save an application record."""
        pass
    
    @abstractmethod
    async def get_application(self, job_id: str) -> Optional[Application]:
        """Get an application by job_id."""
        pass
    
    @abstractmethod
    async def job_already_applied(self, job_id: str) -> bool:
        """Check if already applied to a job."""
        pass
    
    @abstractmethod
    async def get_applications(
        self,
        limit: int = 100,
        status: Optional[ApplicationStatus] = None,
        since: Optional[datetime] = None,
    ) -> list[Application]:
        """Get application records."""
        pass
    
    @abstractmethod
    async def get_today_count(self) -> int:
        """Get today's application count."""
        pass
    
    # Statistics
    @abstractmethod
    async def increment_daily_stats(self, dt: Optional[date] = None) -> None:
        """Increment daily counter."""
        pass
    
    @abstractmethod
    async def get_daily_stats(self, dt: Optional[date] = None) -> int:
        """Get daily application count."""
        pass
</file>

<file path="src/application/use_cases/__init__.py">
# Use Cases Package
from .bot_orchestrator import BotOrchestrator, BotState
from .apply_to_job import ApplyToJobUseCase

__all__ = ["BotOrchestrator", "BotState", "ApplyToJobUseCase"]
</file>

<file path="src/application/use_cases/apply_to_job.py">
"""
Apply to Job Use Case - Full job application workflow.

Handles the complete Easy Apply flow including:
- Opening job listing
- Parsing form fields
- Getting AI answers
- Filling and submitting the form
"""

import asyncio
import logging
from dataclasses import dataclass
from enum import Enum
from typing import Optional

from src.domain.entities import Job, Candidate, Application, ApplicationStatus
from src.infrastructure.browser import CamoufoxAdapter
from src.infrastructure.ai import OpenAIAdapter, PromptBuilder
from src.infrastructure.parsers import JobParser


logger = logging.getLogger(__name__)


class ApplicationResult(Enum):
    """Result of an application attempt."""
    SUCCESS = "success"
    SKIPPED = "skipped"
    FAILED = "failed"
    ALREADY_APPLIED = "already_applied"


@dataclass
class ApplyResult:
    """Detailed result of application attempt."""
    result: ApplicationResult
    job: Optional[Job] = None
    message: str = ""
    tokens_used: int = 0


class ApplyToJobUseCase:
    """
    Use case for applying to a single job.
    
    Orchestrates the full Easy Apply flow:
    1. Parse job listing
    2. Click Easy Apply
    3. For each form page:
       a. Parse form fields
       b. Get AI answers for questions
       c. Fill in answers
       d. Click Next/Submit
    4. Confirm submission
    """
    
    # Selectors
    EASY_APPLY_BUTTON = 'button.jobs-apply-button'
    NEXT_BUTTON = 'button[aria-label="Continue to next step"]'
    REVIEW_BUTTON = 'button[aria-label="Review your application"]'
    SUBMIT_BUTTON = 'button[aria-label="Submit application"]'
    CLOSE_BUTTON = 'button[aria-label="Dismiss"]'
    
    MAX_FORM_PAGES = 10  # Safety limit

    def __init__(
        self,
        browser: CamoufoxAdapter,
        ai: OpenAIAdapter,
        candidate: Candidate,
    ) -> None:
        """
        Initialize the use case.
        
        Args:
            browser: Browser adapter.
            ai: AI adapter.
            candidate: Candidate profile for AI context.
        """
        self.browser = browser
        self.ai = ai
        self.candidate = candidate
        self.prompt_builder = PromptBuilder(candidate)
        self.job_parser = JobParser(browser.page)

    async def execute(self, job_url: Optional[str] = None) -> ApplyResult:
        """
        Execute the job application.
        
        Args:
            job_url: URL of the job to apply to (uses current page if None).
            
        Returns:
            ApplyResult with outcome details.
        """
        total_tokens = 0
        
        try:
            # Navigate to job if URL provided
            if job_url:
                await self.browser.navigate(job_url)
                await asyncio.sleep(2)
            
            # Parse job listing
            job = await self.job_parser.parse_job_listing()
            if not job:
                return ApplyResult(
                    result=ApplicationResult.FAILED,
                    message="NÃ£o foi possÃ­vel parsear a vaga",
                )
            
            # Click Easy Apply button
            if not await self._click_easy_apply():
                return ApplyResult(
                    result=ApplicationResult.SKIPPED,
                    job=job,
                    message="BotÃ£o Easy Apply nÃ£o encontrado",
                )
            
            await asyncio.sleep(2)
            
            # Process form pages
            for page_num in range(self.MAX_FORM_PAGES):
                logger.info(f"Processing form page {page_num + 1}")
                
                # Parse current form fields
                fields = await self.job_parser.parse_form_fields()
                
                # Answer each field
                for field in fields:
                    if field.field_type == "file":
                        # Handle file upload
                        if self.candidate.resume_path:
                            await self.browser.upload_file_invisible(
                                self.candidate.resume_path,
                            )
                    elif field.field_type in ("select", "radio"):
                        # Answer select/radio with AI
                        prompt = self.prompt_builder.build_for_select_question(
                            field.label,
                            field.options,
                            job,
                        )
                        selected, tokens = await self.ai.get_selected_option(
                            prompt,
                            field.options,
                        )
                        total_tokens += tokens
                        await self._fill_select_field(field.name, selected)
                    elif field.field_type in ("text", "textarea"):
                        # Answer text with AI
                        prompt = self.prompt_builder.build_for_text_question(
                            field.label,
                            job,
                        )
                        response = await self.ai.answer_text_question(prompt)
                        total_tokens += response.tokens_used
                        await self._fill_text_field(field.name, response.content)
                
                await asyncio.sleep(1)
                
                # Try to proceed to next step
                if await self._click_submit():
                    # Application submitted!
                    await self._close_modal()
                    return ApplyResult(
                        result=ApplicationResult.SUCCESS,
                        job=job,
                        message="Candidatura enviada com sucesso",
                        tokens_used=total_tokens,
                    )
                elif await self._click_review():
                    # Go to review page, then submit
                    await asyncio.sleep(1)
                    if await self._click_submit():
                        await self._close_modal()
                        return ApplyResult(
                            result=ApplicationResult.SUCCESS,
                            job=job,
                            message="Candidatura enviada com sucesso",
                            tokens_used=total_tokens,
                        )
                elif await self._click_next():
                    # Continue to next form page
                    await asyncio.sleep(1)
                    continue
                else:
                    # No navigation button found
                    break
            
            return ApplyResult(
                result=ApplicationResult.FAILED,
                job=job,
                message="Fluxo de formulÃ¡rio nÃ£o completado",
                tokens_used=total_tokens,
            )
            
        except Exception as e:
            logger.error(f"Application failed: {e}")
            return ApplyResult(
                result=ApplicationResult.FAILED,
                message=str(e),
                tokens_used=total_tokens,
            )

    async def _click_easy_apply(self) -> bool:
        """Click the Easy Apply button."""
        try:
            button = await self.browser.page.wait_for_selector(
                self.EASY_APPLY_BUTTON,
                timeout=5000,
            )
            if button:
                await self.browser.human.click_element(button)
                return True
        except Exception:
            pass
        return False

    async def _click_next(self) -> bool:
        """Click the Next button."""
        try:
            button = await self.browser.page.query_selector(self.NEXT_BUTTON)
            if button:
                await self.browser.human.click_element(button)
                return True
        except Exception:
            pass
        return False

    async def _click_review(self) -> bool:
        """Click the Review button."""
        try:
            button = await self.browser.page.query_selector(self.REVIEW_BUTTON)
            if button:
                await self.browser.human.click_element(button)
                return True
        except Exception:
            pass
        return False

    async def _click_submit(self) -> bool:
        """Click the Submit button."""
        try:
            button = await self.browser.page.query_selector(self.SUBMIT_BUTTON)
            if button:
                await self.browser.human.click_element(button)
                return True
        except Exception:
            pass
        return False

    async def _close_modal(self) -> None:
        """Close the confirmation modal."""
        try:
            button = await self.browser.page.query_selector(self.CLOSE_BUTTON)
            if button:
                await asyncio.sleep(1)
                await self.browser.human.click_element(button)
        except Exception:
            pass

    async def _fill_text_field(self, name: str, value: str) -> None:
        """Fill a text input field."""
        try:
            selector = f'input[name="{name}"], textarea[name="{name}"]'
            element = await self.browser.page.query_selector(selector)
            if element:
                await self.browser.human.click_element(element)
                await element.fill("")  # Clear first
                await self.browser.human.type_text(value)
        except Exception as e:
            logger.warning(f"Failed to fill field {name}: {e}")

    async def _fill_select_field(self, name: str, value: str) -> None:
        """Fill a select dropdown."""
        try:
            selector = f'select[name="{name}"]'
            element = await self.browser.page.query_selector(selector)
            if element:
                await element.select_option(label=value)
        except Exception as e:
            logger.warning(f"Failed to select {name}: {e}")
</file>

<file path="src/application/use_cases/bot_orchestrator.py">
"""
Bot Orchestrator - Main workflow orchestration.

Manages the start/stop lifecycle and coordinates between components.
"""

import asyncio
import logging
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Callable, Optional

from src.config.settings import Settings
from src.domain.entities import Candidate
from src.domain.services import OpSecService
from src.domain.value_objects import Credentials, JobFilter
from src.infrastructure.browser import CamoufoxAdapter, CookieManager
from src.infrastructure.storage import SQLiteAdapter
from src.infrastructure.ai import OpenAIAdapter
from src.infrastructure.security import CryptoService
from src.infrastructure.parsers import ResumeParser

from .apply_to_job import ApplyToJobUseCase, ApplicationResult


logger = logging.getLogger(__name__)


class BotState(Enum):
    """Bot operational states."""
    IDLE = "idle"
    STARTING = "starting"
    RUNNING = "running"
    PAUSED = "paused"
    STOPPING = "stopping"
    ERROR = "error"


@dataclass
class BotStatus:
    """Current bot status for display."""
    state: BotState
    applications_today: int = 0
    daily_limit: int = 50
    consecutive_errors: int = 0
    last_activity: Optional[datetime] = None
    current_job: str = ""
    message: str = ""


EventCallback = Callable[[str, dict], None]


class BotOrchestrator:
    """
    Main bot orchestrator that coordinates all components.
    
    Manages:
    - Browser lifecycle
    - AI initialization
    - Job search and application loop
    - OpSec compliance
    - Error handling and recovery
    """
    
    def __init__(self, settings: Settings) -> None:
        """
        Initialize the orchestrator.
        
        Args:
            settings: Application settings.
        """
        self.settings = settings
        
        # State
        self._state = BotState.IDLE
        self._stop_requested = False
        self._event_callbacks: list[EventCallback] = []
        
        # Candidate context
        self.candidate: Optional[Candidate] = None
        self.job_filter: Optional[JobFilter] = None
        
        # Components (lazy initialized)
        self._storage: Optional[SQLiteAdapter] = None
        self._browser: Optional[CamoufoxAdapter] = None
        self._ai: Optional[OpenAIAdapter] = None
        self._crypto: Optional[CryptoService] = None
        self._opsec: Optional[OpSecService] = None
        self._apply_use_case: Optional[ApplyToJobUseCase] = None

    @property
    def status(self) -> BotStatus:
        """Get current bot status."""
        opsec_status = self._opsec.get_status() if self._opsec else {}
        return BotStatus(
            state=self._state,
            applications_today=opsec_status.get("applications_today", 0),
            daily_limit=opsec_status.get("daily_limit", self.settings.daily_limit),
            consecutive_errors=opsec_status.get("consecutive_errors", 0),
            last_activity=datetime.now() if self._state == BotState.RUNNING else None,
        )

    def add_event_listener(self, callback: EventCallback) -> None:
        """Add an event listener for bot events."""
        self._event_callbacks.append(callback)

    def _emit_event(self, event: str, data: dict) -> None:
        """Emit an event to all listeners."""
        for callback in self._event_callbacks:
            try:
                callback(event, data)
            except Exception as e:
                logger.error(f"Event callback error: {e}")

    async def initialize(self) -> None:
        """Initialize all components."""
        self._state = BotState.STARTING
        self._emit_event("state_change", {"state": self._state.value})
        
        try:
            # Initialize storage
            self._storage = SQLiteAdapter(self.settings.database_path)
            await self._storage.initialize()
            self._emit_event("log", {"message": "Base de dados inicializada"})
            
            # Initialize crypto
            self._crypto = CryptoService(self.settings.encryption_key_path)
            self._crypto.initialize()
            self._emit_event("log", {"message": "Criptografia configurada"})
            
            # Initialize OpSec
            self._opsec = OpSecService(self.settings)
            
            # Load today's count from database
            today_count = await self._storage.get_today_count()
            self._opsec.state.applications_today = today_count
            
            # Initialize browser
            cookie_manager = CookieManager(self.settings.auth_file_path)
            self._browser = CamoufoxAdapter(self.settings, cookie_manager)
            await self._browser.start()
            self._emit_event("log", {"message": "Navegador iniciado"})
            
            # Initialize AI
            if self.settings.openai_api_key:
                self._ai = OpenAIAdapter(self.settings)
                self._ai.initialize()
                self._emit_event("log", {"message": "IA configurada"})
            else:
                self._emit_event("log", {"message": "âš ï¸ API Key nÃ£o configurada"})
            
            # Load stored job filter
            self.job_filter = await self._storage.get_job_filter()
            
        except Exception as e:
            self._emit_event("error", {"message": str(e)})
            raise

    async def verify_session(self, credentials: Optional[Credentials] = None) -> bool:
        """Video session verification."""
        if self._state == BotState.IDLE:
            await self.initialize()
            
        return await self._ensure_logged_in(credentials)


    async def start(
        self,
        credentials: Optional[Credentials] = None,
        job_filter: Optional[JobFilter] = None,
        candidate: Optional[Candidate] = None,
    ) -> None:
        """
        Start the bot automation loop.
        
        Args:
            credentials: LinkedIn credentials (uses stored if None).
            job_filter: Job search filters.
            candidate: Candidate profile for AI context.
        """
        if self._state == BotState.RUNNING:
            return
        
        self._stop_requested = False
        
        # Initialize if needed
        if self._state == BotState.IDLE:
            await self.initialize()
        
        # Update candidate
        if candidate:
            self.candidate = candidate
        
        # Update job filter
        if job_filter:
            self.job_filter = job_filter
            if self._storage:
                await self._storage.save_job_filter(job_filter)
        
        # Handle login
        if not await self._ensure_logged_in(credentials):
            self._state = BotState.ERROR
            self._emit_event("error", {"message": "Falha no login"})
            return
        
        self._state = BotState.RUNNING
        self._emit_event("state_change", {"state": self._state.value})
        
        # Initialize apply use case
        if self._browser and self._ai and self.candidate:
            self._apply_use_case = ApplyToJobUseCase(
                browser=self._browser,
                ai=self._ai,
                candidate=self.candidate,
            )
        
        # Start main loop
        await self._run_loop()

    async def _ensure_logged_in(self, credentials: Optional[Credentials]) -> bool:
        """Ensure we're logged into LinkedIn."""
        if not self._browser:
            return False
        
        # Check if already logged in
        if await self._browser.is_logged_in():
            self._emit_event("log", {"message": "âœ… SessÃ£o ativa encontrada"})
            return True
        
        # Try to get credentials
        if not credentials and self._storage:
            credentials = await self._storage.get_credentials()
            if credentials and self._crypto:
                credentials = self._crypto.try_decrypt_credentials(credentials)
        
        if not credentials:
            self._emit_event("log", {"message": "âŒ Credenciais nÃ£o configuradas"})
            return False
        
        # Attempt login
        self._emit_event("log", {"message": "ðŸ” Fazendo login..."})
        success = await self._browser.login(credentials.username, credentials.password)
        
        if success:
            self._emit_event("log", {"message": "âœ… Login bem-sucedido"})
        else:
            self._emit_event("log", {"message": "âŒ Falha no login"})
        
        return success

    async def _run_loop(self) -> None:
        """Main automation loop."""
        if not self._browser or not self._opsec or not self.job_filter:
            return
        
        self._emit_event("log", {"message": "ðŸš€ Iniciando busca de vagas..."})
        
        # Navigate to job search
        await self._browser.search_jobs(
            keywords=list(self.job_filter.keywords),
            location=self.job_filter.location,
            remote_only=self.job_filter.remote_only,
        )
        
        await asyncio.sleep(3)
        
        while not self._stop_requested:
            # Check OpSec limits
            can_apply, reason = self._opsec.can_apply()
            if not can_apply:
                self._emit_event("log", {"message": f"â¸ï¸ {reason}"})
                
                if "Limite diÃ¡rio" in reason:
                    self._state = BotState.IDLE
                    self._emit_event("state_change", {"state": self._state.value})
                    break
                elif "Pausa" in reason:
                    self._state = BotState.PAUSED
                    self._emit_event("state_change", {"state": self._state.value})
                    # Wait for pause to end
                    await asyncio.sleep(60)
                    self._state = BotState.RUNNING
                    continue
                else:
                    break
            
            # Wait between applications
            await self._opsec.wait_before_application()
            
            # Here we would find and process jobs
            # For now, emit a placeholder message
            self._emit_event("log", {"message": "ðŸ” Buscando prÃ³xima vaga..."})
            
            await asyncio.sleep(5)  # Placeholder - would be actual job processing
            
            if self._stop_requested:
                break
        
        self._state = BotState.IDLE
        self._emit_event("state_change", {"state": self._state.value})
        self._emit_event("log", {"message": "â¹ï¸ Bot parado"})

    async def stop(self) -> None:
        """Request graceful stop of the bot."""
        self._stop_requested = True
        self._state = BotState.STOPPING
        self._emit_event("state_change", {"state": self._state.value})
        self._emit_event("log", {"message": "â³ Parando bot graciosamente..."})

    async def shutdown(self) -> None:
        """Shutdown all components."""
        await self.stop()
        
        if self._browser:
            await self._browser.stop()
            
        if self._storage:
            await self._storage.close()
        
        self._state = BotState.IDLE
        self._emit_event("log", {"message": "ðŸ‘‹ Bot encerrado"})

    async def save_credentials(self, credentials: Credentials) -> None:
        """Save encrypted credentials."""
        if self._crypto and self._storage:
            encrypted = self._crypto.encrypt_credentials(credentials)
            await self._storage.save_credentials(encrypted)
            self._emit_event("log", {"message": "ðŸ” Credenciais salvas"})

    def load_resume(self, file_path: str) -> Optional[Candidate]:
        """Load and parse a resume file."""
        from pathlib import Path
        
        path = Path(file_path)
        if not path.exists():
            return None
        
        try:
            text = ResumeParser.extract_text(path)
            contact = ResumeParser.extract_contact_info(text)
            skills = ResumeParser.extract_skills(text)
            
            self.candidate = Candidate(
                name=contact.get("name") or "",
                email=contact.get("email") or "",
                phone=contact.get("phone") or "",
                resume_text=text,
                resume_path=path,
                skills=skills,
            )
            
            self._emit_event("log", {"message": f"ðŸ“„ CurrÃ­culo carregado: {path.name}"})
            return self.candidate
            
        except Exception as e:
            self._emit_event("error", {"message": f"Erro ao carregar currÃ­culo: {e}"})
            return None
</file>

<file path="src/application/__init__.py">
# Application Package
</file>

<file path="src/config/__init__.py">
# Config Package
</file>

<file path="src/config/settings.py">
"""
BOTLink Configuration Module

Environment-based configuration with fail-fast validation (GLOBAL_RULES Â§1.1).
All settings are loaded from environment variables with sensible defaults.
"""

from pathlib import Path
from typing import Literal

from pydantic import Field, field_validator
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    """Application settings with validation."""

    model_config = SettingsConfigDict(
        env_prefix="BOTLINK_",
        env_file=".env",
        env_file_encoding="utf-8",
        extra="ignore",
    )

    # Environment
    env: Literal["development", "production"] = Field(
        default="development",
        description="Application environment",
    )
    log_level: Literal["DEBUG", "INFO", "WARNING", "ERROR"] = Field(
        default="INFO",
        description="Logging level",
    )
    data_dir: Path = Field(
        default=Path("./data"),
        description="Directory for runtime data (db, cookies, etc.)",
    )

    # OpenAI Configuration
    openai_api_key: str = Field(
        default="",
        alias="OPENAI_API_KEY",
        description="OpenAI API key for GPT-4o",
    )

    # OpSec Limits (RNF-01 to RNF-05)
    daily_limit: int = Field(
        default=50,
        ge=1,
        le=100,
        description="Maximum applications per day (RNF-01)",
    )
    warmup_enabled: bool = Field(
        default=True,
        description="Enable warm-up progression for new accounts (RNF-02)",
    )
    min_action_delay: float = Field(
        default=1.5,
        description="Minimum delay between actions in seconds (RNF-03)",
    )
    max_action_delay: float = Field(
        default=4.0,
        description="Maximum delay between actions in seconds (RNF-03)",
    )
    min_application_delay: float = Field(
        default=120.0,
        description="Minimum delay between applications in seconds (RNF-03)",
    )
    max_application_delay: float = Field(
        default=600.0,
        description="Maximum delay between applications in seconds (RNF-03)",
    )
    pause_after_applications: int = Field(
        default=10,
        description="Pause after this many applications (RNF-04)",
    )
    pause_duration_min: int = Field(
        default=15,
        description="Minimum pause duration in minutes (RNF-04)",
    )
    pause_duration_max: int = Field(
        default=30,
        description="Maximum pause duration in minutes (RNF-04)",
    )
    max_consecutive_errors: int = Field(
        default=3,
        description="Abort after this many consecutive errors (RNF-05)",
    )

    # Browser Settings
    headless: bool = Field(
        default=False,
        description="Run browser in headless mode",
    )
    use_camoufox: bool = Field(
        default=True,
        description="Use Camoufox for stealth browsing",
    )

    @field_validator("data_dir", mode="before")
    @classmethod
    def ensure_path(cls, v: str | Path) -> Path:
        """Convert string to Path."""
        return Path(v)

    def ensure_data_dir(self) -> None:
        """Create data directory if it doesn't exist."""
        self.data_dir.mkdir(parents=True, exist_ok=True)

    @property
    def database_path(self) -> Path:
        """Path to SQLite database."""
        return self.data_dir / "botlink.db"

    @property
    def auth_file_path(self) -> Path:
        """Path to authentication cookies file."""
        return self.data_dir / "auth.json"

    @property
    def encryption_key_path(self) -> Path:
        """Path to encryption key file."""
        return self.data_dir / ".key"


def get_settings() -> Settings:
    """
    Get validated settings instance.
    
    Raises:
        ValidationError: If required settings are missing or invalid.
    """
    settings = Settings()
    settings.ensure_data_dir()
    return settings


# Singleton instance for easy import
settings = get_settings()
</file>

<file path="src/domain/entities/__init__.py">
# Domain Entities
from .job import Job
from .candidate import Candidate
from .application import Application, ApplicationStatus

__all__ = ["Job", "Candidate", "Application", "ApplicationStatus"]
</file>

<file path="src/domain/entities/application.py">
"""
Application Entity - Represents a job application record.
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional


class ApplicationStatus(Enum):
    """Status of a job application."""
    
    SUCESSO = "SUCESSO"
    FALHA = "FALHA"
    PULADO = "PULADO"
    PENDING = "PENDING"


@dataclass
class Application:
    """
    Application entity representing a job application record.
    
    Corresponds to the `candidaturas` table in the database schema.
    
    Attributes:
        id: Database primary key (None for new applications)
        job_id: LinkedIn job ID (unique constraint)
        empresa: Company name
        titulo: Job title
        localizacao: Job location
        data_hora: Application timestamp
        status: Application status
        motivo_log: Log message (AI response, error details)
        tokens_ia: Token count for cost tracking
    """
    
    job_id: str
    empresa: str
    titulo: str
    localizacao: str
    status: ApplicationStatus
    id: Optional[int] = None
    data_hora: datetime = field(default_factory=datetime.now)
    motivo_log: str = ""
    tokens_ia: int = 0

    def __post_init__(self) -> None:
        """Validate and normalize application data."""
        if not self.job_id:
            raise ValueError("job_id is required")
        
        # Convert string status to enum if needed
        if isinstance(self.status, str):
            self.status = ApplicationStatus(self.status)

    @property
    def is_successful(self) -> bool:
        """Check if application was successful."""
        return self.status == ApplicationStatus.SUCESSO

    @property
    def is_failed(self) -> bool:
        """Check if application failed."""
        return self.status == ApplicationStatus.FALHA

    @property
    def display_status(self) -> str:
        """Human-readable status with emoji."""
        status_map = {
            ApplicationStatus.SUCESSO: "âœ… Sucesso",
            ApplicationStatus.FALHA: "âŒ Falha",
            ApplicationStatus.PULADO: "â­ï¸ Pulado",
            ApplicationStatus.PENDING: "â³ Pendente",
        }
        return status_map.get(self.status, str(self.status.value))

    def to_dict(self) -> dict:
        """Convert to dictionary for database storage."""
        return {
            "job_id": self.job_id,
            "empresa": self.empresa,
            "titulo": self.titulo,
            "localizacao": self.localizacao,
            "data_hora": self.data_hora.isoformat(),
            "status": self.status.value,
            "motivo_log": self.motivo_log,
            "tokens_ia": self.tokens_ia,
        }

    @classmethod
    def from_dict(cls, data: dict) -> "Application":
        """Create Application from dictionary (database row)."""
        return cls(
            id=data.get("id"),
            job_id=data["job_id"],
            empresa=data["empresa"],
            titulo=data["titulo"],
            localizacao=data["localizacao"],
            data_hora=datetime.fromisoformat(data["data_hora"])
            if isinstance(data["data_hora"], str)
            else data["data_hora"],
            status=ApplicationStatus(data["status"]),
            motivo_log=data.get("motivo_log", ""),
            tokens_ia=data.get("tokens_ia", 0),
        )
</file>

<file path="src/domain/entities/candidate.py">
"""
Candidate Entity - Represents the job seeker's profile.
"""

from dataclasses import dataclass, field
from pathlib import Path
from typing import Optional


@dataclass
class Candidate:
    """
    Candidate entity representing the job seeker's profile.
    
    This is the knowledge base used by the AI to answer application questions.
    
    Attributes:
        name: Full name
        email: Contact email
        phone: Contact phone
        resume_text: Extracted text from resume PDF/DOCX
        resume_path: Path to the uploaded resume file
        bio: Extended bio/cover letter text
        skills: List of skills
        experience_years: Total years of experience
        attachments: Paths to additional files (portfolio, certificates)
    """
    
    name: str = ""
    email: str = ""
    phone: str = ""
    resume_text: str = ""
    resume_path: Optional[Path] = None
    bio: str = ""
    skills: list[str] = field(default_factory=list)
    experience_years: int = 0
    attachments: list[Path] = field(default_factory=list)

    @property
    def is_complete(self) -> bool:
        """Check if candidate profile has minimum required information."""
        return bool(self.name and self.resume_text)

    @property
    def context_for_ai(self) -> str:
        """
        Generate context string for AI prompt construction.
        
        Returns:
            Formatted string with all candidate information for AI context.
        """
        parts = []
        
        if self.name:
            parts.append(f"Name: {self.name}")
        if self.email:
            parts.append(f"Email: {self.email}")
        if self.phone:
            parts.append(f"Phone: {self.phone}")
        if self.experience_years:
            parts.append(f"Years of Experience: {self.experience_years}")
        if self.skills:
            parts.append(f"Skills: {', '.join(self.skills)}")
        
        if self.resume_text:
            parts.append(f"\n--- RESUME ---\n{self.resume_text}")
            
        if self.bio:
            parts.append(f"\n--- BIO/COVER LETTER ---\n{self.bio}")
            
        return "\n".join(parts)

    def add_attachment(self, path: Path) -> None:
        """Add an attachment file path."""
        if path not in self.attachments:
            self.attachments.append(path)

    def remove_attachment(self, path: Path) -> None:
        """Remove an attachment file path."""
        if path in self.attachments:
            self.attachments.remove(path)
</file>

<file path="src/domain/entities/job.py">
"""
Job Entity - Represents a LinkedIn job posting.
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional


@dataclass
class Job:
    """
    Job entity representing a LinkedIn job posting.
    
    Attributes:
        job_id: Unique LinkedIn job ID (e.g., "37481923")
        title: Job title
        company: Company name
        location: Job location
        description: Full job description text
        url: LinkedIn job URL
        is_remote: Whether the job is remote
        is_easy_apply: Whether the job supports Easy Apply
        questions: List of application questions extracted from the form
        scraped_at: When the job was scraped
    """
    
    job_id: str
    title: str
    company: str
    location: str
    description: str = ""
    url: str = ""
    is_remote: bool = False
    is_easy_apply: bool = True
    questions: list[dict] = field(default_factory=list)
    scraped_at: datetime = field(default_factory=datetime.now)

    def __post_init__(self) -> None:
        """Validate job data after initialization."""
        if not self.job_id:
            raise ValueError("job_id is required")
        if not self.title:
            raise ValueError("title is required")
        if not self.company:
            raise ValueError("company is required")

    @property
    def display_name(self) -> str:
        """Human-readable job display name."""
        return f"{self.title} @ {self.company}"

    def matches_filter(
        self,
        keywords: Optional[list[str]] = None,
        location: Optional[str] = None,
        remote_only: bool = False,
    ) -> bool:
        """
        Check if job matches the given filters.
        
        Args:
            keywords: List of keywords to match against title/description
            location: Location to match
            remote_only: Only match remote jobs
            
        Returns:
            True if job matches all provided filters
        """
        if remote_only and not self.is_remote:
            return False
            
        if location and location.lower() not in self.location.lower():
            return False
            
        if keywords:
            text = f"{self.title} {self.description}".lower()
            if not any(kw.lower() in text for kw in keywords):
                return False
                
        return True
</file>

<file path="src/domain/services/__init__.py">
# Domain Services
from .opsec_service import OpSecService

__all__ = ["OpSecService"]
</file>

<file path="src/domain/services/opsec_service.py">
"""
OpSec Service - Operational Security for Rate Limiting and Anti-Detection.

Implements RNF-01 to RNF-05 from the PRD:
- RNF-01: Daily limit (40-50 applications)
- RNF-02: Warm-up progression for new accounts
- RNF-03: Random delays between actions
- RNF-04: Mandatory pauses every 10 applications
- RNF-05: Abort on consecutive errors
"""

import asyncio
import random
from dataclasses import dataclass, field
from datetime import date, datetime
from typing import Optional

from src.config.settings import Settings


@dataclass
class OpSecState:
    """Current operational security state."""
    
    today: date = field(default_factory=date.today)
    applications_today: int = 0
    consecutive_errors: int = 0
    account_age_days: int = 0
    last_application_time: Optional[datetime] = None
    is_paused: bool = False
    pause_until: Optional[datetime] = None


class OpSecService:
    """
    Operational Security service for safe automation.
    
    This service enforces rate limits, delays, and anti-detection
    measures to avoid LinkedIn account blocking.
    """
    
    # Warm-up progression: day -> max applications
    WARMUP_SCHEDULE = {
        1: 10,
        2: 20,
        3: 30,
    }
    DEFAULT_LIMIT = 40

    def __init__(self, settings: Settings) -> None:
        """Initialize OpSec service with settings."""
        self.settings = settings
        self.state = OpSecState()

    def get_daily_limit(self) -> int:
        """
        Get the daily application limit based on account age (RNF-01, RNF-02).
        
        Returns:
            Maximum allowed applications for today.
        """
        if not self.settings.warmup_enabled:
            return self.settings.daily_limit
            
        if self.state.account_age_days in self.WARMUP_SCHEDULE:
            return self.WARMUP_SCHEDULE[self.state.account_age_days]
            
        return min(self.DEFAULT_LIMIT, self.settings.daily_limit)

    def can_apply(self) -> tuple[bool, str]:
        """
        Check if we can submit another application.
        
        Returns:
            Tuple of (can_apply, reason_if_blocked)
        """
        # Check if we need to reset daily counter
        if self.state.today != date.today():
            self.state.today = date.today()
            self.state.applications_today = 0
            self.state.consecutive_errors = 0
            
        # Check paused state
        if self.state.is_paused:
            if self.state.pause_until and datetime.now() < self.state.pause_until:
                remaining = (self.state.pause_until - datetime.now()).seconds // 60
                return False, f"Pausa obrigatÃ³ria. Retorno em {remaining} minutos."
            else:
                self.state.is_paused = False
                self.state.pause_until = None
        
        # Check daily limit (RNF-01)
        limit = self.get_daily_limit()
        if self.state.applications_today >= limit:
            return False, f"Limite diÃ¡rio atingido ({limit} candidaturas)."
            
        # Check consecutive errors (RNF-05)
        if self.state.consecutive_errors >= self.settings.max_consecutive_errors:
            return False, f"Muitos erros consecutivos ({self.state.consecutive_errors}). SessÃ£o abortada."
            
        # Check if pause is needed (RNF-04)
        if (
            self.state.applications_today > 0
            and self.state.applications_today % self.settings.pause_after_applications == 0
        ):
            pause_minutes = random.randint(
                self.settings.pause_duration_min,
                self.settings.pause_duration_max,
            )
            self.state.is_paused = True
            self.state.pause_until = datetime.now() + asyncio.timedelta(
                minutes=pause_minutes
            ) if hasattr(asyncio, 'timedelta') else datetime.now()
            # Fallback: use datetime.timedelta
            from datetime import timedelta
            self.state.pause_until = datetime.now() + timedelta(minutes=pause_minutes)
            return False, f"Pausa de {pause_minutes} minutos apÃ³s {self.settings.pause_after_applications} candidaturas."
            
        return True, ""

    async def wait_before_action(self) -> float:
        """
        Wait random delay before performing an action (RNF-03).
        
        Returns:
            Actual delay in seconds.
        """
        delay = random.uniform(
            self.settings.min_action_delay,
            self.settings.max_action_delay,
        )
        await asyncio.sleep(delay)
        return delay

    async def wait_before_application(self) -> float:
        """
        Wait random delay before submitting application (RNF-03).
        
        Returns:
            Actual delay in seconds.
        """
        delay = random.uniform(
            self.settings.min_application_delay,
            self.settings.max_application_delay,
        )
        await asyncio.sleep(delay)
        return delay

    def record_success(self) -> None:
        """Record a successful application."""
        self.state.applications_today += 1
        self.state.consecutive_errors = 0
        self.state.last_application_time = datetime.now()

    def record_failure(self) -> None:
        """Record a failed application."""
        self.state.consecutive_errors += 1
        self.state.last_application_time = datetime.now()

    def record_skip(self) -> None:
        """Record a skipped job (doesn't count toward limits)."""
        self.state.consecutive_errors = 0

    def set_account_age(self, days: int) -> None:
        """Set the account age for warm-up calculation."""
        self.state.account_age_days = days

    def get_status(self) -> dict:
        """Get current OpSec status for display."""
        limit = self.get_daily_limit()
        return {
            "applications_today": self.state.applications_today,
            "daily_limit": limit,
            "remaining": limit - self.state.applications_today,
            "consecutive_errors": self.state.consecutive_errors,
            "is_paused": self.state.is_paused,
            "account_age_days": self.state.account_age_days,
            "warmup_active": (
                self.settings.warmup_enabled
                and self.state.account_age_days in self.WARMUP_SCHEDULE
            ),
        }

    def reset_daily(self) -> None:
        """Reset daily counters (for testing or manual reset)."""
        self.state.applications_today = 0
        self.state.consecutive_errors = 0
        self.state.today = date.today()

    def force_pause(self, minutes: int) -> None:
        """Force a pause for the specified minutes."""
        from datetime import timedelta
        self.state.is_paused = True
        self.state.pause_until = datetime.now() + timedelta(minutes=minutes)
</file>

<file path="src/domain/value_objects/__init__.py">
# Domain Value Objects
from .credentials import Credentials
from .job_filter import JobFilter

__all__ = ["Credentials", "JobFilter"]
</file>

<file path="src/domain/value_objects/credentials.py">
"""
Credentials Value Object - Immutable encrypted credentials.
"""

from dataclasses import dataclass
from typing import Optional


@dataclass(frozen=True)
class Credentials:
    """
    Immutable value object for LinkedIn credentials.
    
    Credentials are stored encrypted; this object holds either
    encrypted or decrypted values depending on context.
    
    Attributes:
        username: LinkedIn email/username
        password: LinkedIn password
        is_encrypted: Whether the password is currently encrypted
    """
    
    username: str
    password: str
    is_encrypted: bool = False

    def __post_init__(self) -> None:
        """Validate credentials."""
        if not self.username:
            raise ValueError("Username is required")
        if not self.password:
            raise ValueError("Password is required")

    @property
    def is_valid(self) -> bool:
        """Check if credentials appear valid (non-empty)."""
        return bool(self.username and self.password)

    def masked(self) -> "Credentials":
        """Return credentials with masked password for display."""
        masked_pw = "*" * min(len(self.password), 8) if self.password else ""
        return Credentials(
            username=self.username,
            password=masked_pw,
            is_encrypted=self.is_encrypted,
        )

    def with_encrypted_password(self, encrypted: str) -> "Credentials":
        """Create new credentials with encrypted password."""
        return Credentials(
            username=self.username,
            password=encrypted,
            is_encrypted=True,
        )

    def with_decrypted_password(self, decrypted: str) -> "Credentials":
        """Create new credentials with decrypted password."""
        return Credentials(
            username=self.username,
            password=decrypted,
            is_encrypted=False,
        )
</file>

<file path="src/domain/value_objects/job_filter.py">
"""
JobFilter Value Object - Immutable job search filters.
"""

from dataclasses import dataclass, field
from typing import Optional


@dataclass(frozen=True)
class JobFilter:
    """
    Immutable value object for job search filters.
    
    Corresponds to FE-01 job panel configuration.
    
    Attributes:
        keywords: List of job title keywords to search
        location: Target location (city, state, country)
        remote_only: Filter for remote jobs only
        easy_apply_only: Filter for Easy Apply jobs only
    """
    
    keywords: tuple[str, ...] = field(default_factory=tuple)
    location: str = ""
    remote_only: bool = False
    easy_apply_only: bool = True

    def __post_init__(self) -> None:
        """Convert mutable lists to immutable tuples."""
        if isinstance(self.keywords, list):
            object.__setattr__(self, "keywords", tuple(self.keywords))

    @property
    def is_configured(self) -> bool:
        """Check if any filters are set."""
        return bool(self.keywords or self.location)

    @property
    def search_query(self) -> str:
        """Generate LinkedIn search query string."""
        return " OR ".join(self.keywords) if self.keywords else ""

    def to_dict(self) -> dict:
        """Convert to dictionary for storage."""
        return {
            "keywords": list(self.keywords),
            "location": self.location,
            "remote_only": self.remote_only,
            "easy_apply_only": self.easy_apply_only,
        }

    @classmethod
    def from_dict(cls, data: dict) -> "JobFilter":
        """Create JobFilter from dictionary."""
        return cls(
            keywords=tuple(data.get("keywords", [])),
            location=data.get("location", ""),
            remote_only=data.get("remote_only", False),
            easy_apply_only=data.get("easy_apply_only", True),
        )

    def with_keywords(self, keywords: list[str]) -> "JobFilter":
        """Create new filter with updated keywords."""
        return JobFilter(
            keywords=tuple(keywords),
            location=self.location,
            remote_only=self.remote_only,
            easy_apply_only=self.easy_apply_only,
        )

    def with_location(self, location: str) -> "JobFilter":
        """Create new filter with updated location."""
        return JobFilter(
            keywords=self.keywords,
            location=location,
            remote_only=self.remote_only,
            easy_apply_only=self.easy_apply_only,
        )
</file>

<file path="src/domain/__init__.py">
# Domain Package
</file>

<file path="src/infrastructure/ai/__init__.py">
# AI Package
from .openai_adapter import OpenAIAdapter
from .prompt_builder import PromptBuilder

__all__ = ["OpenAIAdapter", "PromptBuilder"]
</file>

<file path="src/infrastructure/ai/openai_adapter.py">
"""
OpenAI Adapter - GPT-4o integration with JSON mode.

Implements BE-06: Force AI responses in JSON format for form filling.
"""

import json
from dataclasses import dataclass
from typing import Any, Optional

from openai import AsyncOpenAI
from pydantic import BaseModel

from src.config.settings import Settings
from .prompt_builder import PromptResult


@dataclass
class AIResponse:
    """Response from the AI."""
    content: str
    json_data: Optional[dict] = None
    tokens_used: int = 0
    model: str = ""


class OpenAIAdapter:
    """
    OpenAI API adapter for GPT-4o.
    
    Features:
    - Structured outputs (JSON mode)
    - Token tracking for cost control
    - Async API calls
    """
    
    DEFAULT_MODEL = "gpt-4o"
    MAX_TOKENS = 1000

    def __init__(self, settings: Settings) -> None:
        """
        Initialize the adapter.
        
        Args:
            settings: Application settings with API key.
        """
        self.settings = settings
        self._client: Optional[AsyncOpenAI] = None

    def initialize(self) -> None:
        """Initialize the OpenAI client."""
        if not self.settings.openai_api_key:
            raise ValueError("OpenAI API key not configured")
            
        self._client = AsyncOpenAI(api_key=self.settings.openai_api_key)

    @property
    def client(self) -> AsyncOpenAI:
        """Get the OpenAI client."""
        if not self._client:
            raise RuntimeError("OpenAI adapter not initialized. Call initialize() first.")
        return self._client

    async def complete(
        self,
        prompt: PromptResult,
        json_mode: bool = False,
        max_tokens: Optional[int] = None,
    ) -> AIResponse:
        """
        Send a completion request to GPT-4o.
        
        Args:
            prompt: The prompt to send.
            json_mode: Whether to force JSON output.
            max_tokens: Maximum response tokens.
            
        Returns:
            AIResponse with content and token usage.
        """
        messages = [
            {"role": "system", "content": prompt.system_prompt},
            {"role": "user", "content": prompt.user_prompt},
        ]
        
        kwargs: dict[str, Any] = {
            "model": self.DEFAULT_MODEL,
            "messages": messages,
            "max_tokens": max_tokens or self.MAX_TOKENS,
            "temperature": 0.7,
        }
        
        if json_mode:
            kwargs["response_format"] = {"type": "json_object"}
        
        response = await self.client.chat.completions.create(**kwargs)
        
        content = response.choices[0].message.content or ""
        tokens_used = response.usage.total_tokens if response.usage else 0
        
        # Try to parse JSON if in json_mode
        json_data = None
        if json_mode:
            try:
                json_data = json.loads(content)
            except json.JSONDecodeError:
                pass
        
        return AIResponse(
            content=content,
            json_data=json_data,
            tokens_used=tokens_used,
            model=self.DEFAULT_MODEL,
        )

    async def answer_text_question(
        self,
        prompt: PromptResult,
    ) -> AIResponse:
        """Answer a text question (free-form response)."""
        return await self.complete(prompt, json_mode=False)

    async def answer_select_question(
        self,
        prompt: PromptResult,
    ) -> AIResponse:
        """Answer a select/radio question (JSON response with selected option)."""
        return await self.complete(prompt, json_mode=True)

    async def get_selected_option(
        self,
        prompt: PromptResult,
        options: list[str],
    ) -> tuple[str, int]:
        """
        Get the selected option from a list.
        
        Args:
            prompt: The prompt to send.
            options: Available options.
            
        Returns:
            Tuple of (selected_option, tokens_used).
        """
        response = await self.answer_select_question(prompt)
        
        if response.json_data and "selected_option" in response.json_data:
            selected = response.json_data["selected_option"]
            # Find closest match in options
            for opt in options:
                if opt.lower() == selected.lower():
                    return opt, response.tokens_used
            # Return first close match
            for opt in options:
                if selected.lower() in opt.lower() or opt.lower() in selected.lower():
                    return opt, response.tokens_used
        
        # Default to first option if parsing fails
        return options[0] if options else "", response.tokens_used

    async def health_check(self) -> bool:
        """Check if the API is accessible."""
        try:
            response = await self.client.chat.completions.create(
                model=self.DEFAULT_MODEL,
                messages=[{"role": "user", "content": "Hi"}],
                max_tokens=5,
            )
            return bool(response.choices)
        except Exception:
            return False


class StructuredAnswerSchema(BaseModel):
    """Schema for structured answer responses."""
    selected_option: str


class CoverLetterSchema(BaseModel):
    """Schema for cover letter generation."""
    content: str
    key_points: list[str]
</file>

<file path="src/infrastructure/ai/prompt_builder.py">
"""
Prompt Builder - Context-aware prompt construction.

Implements BE-05: Build prompts with candidate context and constraints.
"""

from dataclasses import dataclass
from typing import Optional

from src.domain.entities import Candidate, Job
from src.infrastructure.parsers.job_parser import FormField


@dataclass
class PromptResult:
    """Result of prompt construction."""
    system_prompt: str
    user_prompt: str


class PromptBuilder:
    """
    Builds prompts for the AI to answer application questions.
    
    Constructs context-aware prompts including:
    - Candidate resume and bio
    - Job description
    - Specific question with options
    - Output constraints (JSON format)
    """
    
    SYSTEM_PROMPT_BASE = """VocÃª Ã© um assistente especializado em ajudar candidatos a responder perguntas de formulÃ¡rios de candidatura a vagas de emprego.

VocÃª receberÃ¡:
1. O perfil do candidato (currÃ­culo, bio, habilidades)
2. A descriÃ§Ã£o da vaga
3. Uma pergunta especÃ­fica do formulÃ¡rio

Suas responsabilidades:
- Responder de forma profissional e concisa
- Usar informaÃ§Ãµes reais do perfil do candidato
- Adaptar o tom para contexto profissional brasileiro
- Seguir as restriÃ§Ãµes de formato especificadas

IMPORTANTE:
- Nunca invente informaÃ§Ãµes que nÃ£o estÃ£o no perfil
- Se nÃ£o souber uma resposta, use o valor padrÃ£o fornecido
- Respostas devem ser diretas e objetivas"""

    SYSTEM_PROMPT_JSON = """

VocÃª DEVE responder APENAS em formato JSON vÃ¡lido, sem texto adicional.
O JSON deve seguir exatamente o schema especificado na pergunta."""

    def __init__(self, candidate: Candidate) -> None:
        """
        Initialize with candidate context.
        
        Args:
            candidate: Candidate profile for context.
        """
        self.candidate = candidate

    def build_for_text_question(
        self,
        question: str,
        job: Optional[Job] = None,
        max_length: Optional[int] = None,
    ) -> PromptResult:
        """
        Build prompt for a text/textarea question.
        
        Args:
            question: The question text.
            job: Optional job context.
            max_length: Optional character limit.
            
        Returns:
            PromptResult with system and user prompts.
        """
        system = self.SYSTEM_PROMPT_BASE
        
        user_parts = [
            "## PERFIL DO CANDIDATO",
            self.candidate.context_for_ai,
        ]
        
        if job:
            user_parts.extend([
                "\n## VAGA",
                f"**Empresa:** {job.company}",
                f"**Cargo:** {job.title}",
                f"**Local:** {job.location}",
            ])
            if job.description:
                user_parts.append(f"\n**DescriÃ§Ã£o:**\n{job.description[:2000]}")
        
        user_parts.extend([
            "\n## PERGUNTA",
            question,
        ])
        
        if max_length:
            user_parts.append(f"\n**Limite:** mÃ¡ximo {max_length} caracteres")
        
        user_parts.append(
            "\n## INSTRUÃ‡Ã•ES\n"
            "Responda a pergunta acima de forma profissional e concisa, "
            "baseando-se no perfil do candidato."
        )
        
        return PromptResult(
            system_prompt=system,
            user_prompt="\n".join(user_parts),
        )

    def build_for_select_question(
        self,
        question: str,
        options: list[str],
        job: Optional[Job] = None,
    ) -> PromptResult:
        """
        Build prompt for a select/dropdown question.
        
        Args:
            question: The question text.
            options: Available options to choose from.
            job: Optional job context.
            
        Returns:
            PromptResult with system and user prompts.
        """
        system = self.SYSTEM_PROMPT_BASE + self.SYSTEM_PROMPT_JSON
        
        options_str = "\n".join(f"- {opt}" for opt in options)
        
        user_parts = [
            "## PERFIL DO CANDIDATO",
            self.candidate.context_for_ai,
        ]
        
        if job:
            user_parts.extend([
                "\n## VAGA",
                f"**Empresa:** {job.company}",
                f"**Cargo:** {job.title}",
            ])
        
        user_parts.extend([
            "\n## PERGUNTA",
            question,
            "\n## OPÃ‡Ã•ES DISPONÃVEIS",
            options_str,
            '\n## FORMATO DE RESPOSTA',
            'Responda APENAS com JSON no formato:',
            '{"selected_option": "opÃ§Ã£o escolhida exatamente como listada acima"}',
        ])
        
        return PromptResult(
            system_prompt=system,
            user_prompt="\n".join(user_parts),
        )

    def build_for_radio_question(
        self,
        question: str,
        options: list[str],
        job: Optional[Job] = None,
    ) -> PromptResult:
        """
        Build prompt for a radio button question.
        
        Same as select, but for radio buttons.
        """
        return self.build_for_select_question(question, options, job)

    def build_for_form_field(
        self,
        field: FormField,
        job: Optional[Job] = None,
    ) -> PromptResult:
        """
        Build prompt for any form field type.
        
        Args:
            field: The form field to answer.
            job: Optional job context.
            
        Returns:
            PromptResult with system and user prompts.
        """
        if field.field_type in ("select", "radio"):
            return self.build_for_select_question(
                field.label,
                field.options,
                job,
            )
        else:
            return self.build_for_text_question(
                field.label,
                job,
            )

    def build_for_cover_letter(
        self,
        job: Job,
        max_words: int = 200,
    ) -> PromptResult:
        """
        Build prompt for generating a cover letter.
        
        Args:
            job: The job to apply to.
            max_words: Word limit.
            
        Returns:
            PromptResult with system and user prompts.
        """
        system = self.SYSTEM_PROMPT_BASE
        
        user_parts = [
            "## PERFIL DO CANDIDATO",
            self.candidate.context_for_ai,
            "\n## VAGA",
            f"**Empresa:** {job.company}",
            f"**Cargo:** {job.title}",
            f"**Local:** {job.location}",
        ]
        
        if job.description:
            user_parts.append(f"\n**DescriÃ§Ã£o:**\n{job.description[:2000]}")
        
        user_parts.extend([
            "\n## TAREFA",
            f"Escreva uma carta de apresentaÃ§Ã£o concisa (mÃ¡ximo {max_words} palavras) "
            "para esta vaga, destacando:",
            "1. Por que vocÃª Ã© um bom candidato",
            "2. ExperiÃªncias relevantes do seu currÃ­culo",
            "3. MotivaÃ§Ã£o para a vaga",
            "\nTom: profissional mas caloroso. Evite clichÃªs.",
        ])
        
        return PromptResult(
            system_prompt=system,
            user_prompt="\n".join(user_parts),
        )
</file>

<file path="src/infrastructure/browser/__init__.py">
# Browser Package
from .camoufox_adapter import CamoufoxAdapter
from .human_simulator import HumanSimulator
from .cookie_manager import CookieManager

__all__ = ["CamoufoxAdapter", "HumanSimulator", "CookieManager"]
</file>

<file path="src/infrastructure/browser/camoufox_adapter.py">
"""
Camoufox Adapter - Stealth browser automation with Playwright.

Primary browser adapter implementing:
- BE-01: Cookie management (via CookieManager)
- BE-02: Human simulation (via HumanSimulator)
- BE-03: Invisible file upload

Uses Camoufox (Firefox fork) for fingerprint evasion when available,
with fallback to regular Firefox.
"""

import asyncio
from pathlib import Path
from typing import Any, Optional

from playwright.async_api import (
    Browser,
    BrowserContext,
    Page,
    Playwright,
    async_playwright,
)

from src.config.settings import Settings
from .cookie_manager import CookieManager
from .human_simulator import HumanSimulator


class CamoufoxAdapter:
    """
    Stealth browser adapter using Playwright with Camoufox.
    
    Provides high-level browser automation with anti-detection features.
    """
    
    # LinkedIn URLs
    LINKEDIN_BASE = "https://www.linkedin.com"
    LINKEDIN_LOGIN = "https://www.linkedin.com/login"
    LINKEDIN_JOBS = "https://www.linkedin.com/jobs"
    LINKEDIN_FEED = "https://www.linkedin.com/feed"
    
    # Selectors
    SELECTOR_LOGIN_EMAIL = 'input[name="session_key"]'
    SELECTOR_LOGIN_PASSWORD = 'input[name="session_password"]'
    SELECTOR_LOGIN_BUTTON = 'button[type="submit"]'
    SELECTOR_EASY_APPLY_BUTTON = 'button.jobs-apply-button'
    SELECTOR_SUBMIT_BUTTON = 'button[aria-label="Submit application"]'
    SELECTOR_NEXT_BUTTON = 'button[aria-label="Continue to next step"]'
    SELECTOR_REVIEW_BUTTON = 'button[aria-label="Review your application"]'

    def __init__(
        self,
        settings: Settings,
        cookie_manager: CookieManager,
    ) -> None:
        """
        Initialize the adapter.
        
        Args:
            settings: Application settings.
            cookie_manager: Cookie manager for session persistence.
        """
        self.settings = settings
        self.cookie_manager = cookie_manager
        
        self._playwright: Optional[Playwright] = None
        self._browser: Optional[Browser] = None
        self._context: Optional[BrowserContext] = None
        self._page: Optional[Page] = None
        self._human: Optional[HumanSimulator] = None

    async def start(self) -> None:
        """Start the browser and create a new context."""
        self._playwright = await async_playwright().start()
        
        # Try Camoufox first, fallback to Firefox
        browser_type = self._playwright.firefox
        
        launch_options: dict[str, Any] = {
            "headless": self.settings.headless,
        }
        
        # Add Camoufox-specific options if available
        if self.settings.use_camoufox:
            launch_options["args"] = [
                "--disable-blink-features=AutomationControlled",
            ]
        
        self._browser = await browser_type.launch(**launch_options)
        
        # Create context with anti-detection settings
        context_options: dict[str, Any] = {
            "viewport": {"width": 1920, "height": 1080},
            "user_agent": (
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) "
                "Gecko/20100101 Firefox/121.0"
            ),
            "locale": "pt-BR",
            "timezone_id": "America/Sao_Paulo",
        }
        
        # Load existing session if available
        if self.cookie_manager.has_saved_session():
            storage_state = self.cookie_manager.get_storage_state_path()
            if storage_state:
                context_options["storage_state"] = storage_state
        
        self._context = await self._browser.new_context(**context_options)
        self._page = await self._context.new_page()
        self._human = HumanSimulator(self._page)
        
        # Additional stealth measures
        await self._apply_stealth_patches()

    async def _apply_stealth_patches(self) -> None:
        """Apply JavaScript patches to avoid detection."""
        if not self._page:
            return
            
        # Hide webdriver property
        await self._page.add_init_script("""
            Object.defineProperty(navigator, 'webdriver', {
                get: () => undefined
            });
            
            // Override permissions query
            const originalQuery = window.navigator.permissions.query;
            window.navigator.permissions.query = (parameters) => (
                parameters.name === 'notifications' ?
                    Promise.resolve({ state: Notification.permission }) :
                    originalQuery(parameters)
            );
        """)

    async def stop(self) -> None:
        """Stop the browser and clean up resources."""
        if self._context:
            # Save cookies before closing
            await self.cookie_manager.save_cookies(self._context)
            await self._context.close()
            
        if self._browser:
            await self._browser.close()
            
        if self._playwright:
            await self._playwright.stop()
        
        self._page = None
        self._context = None
        self._browser = None
        self._playwright = None
        self._human = None

    @property
    def page(self) -> Page:
        """Get the current page."""
        if not self._page:
            raise RuntimeError("Browser not started. Call start() first.")
        return self._page

    @property
    def human(self) -> HumanSimulator:
        """Get the human simulator."""
        if not self._human:
            raise RuntimeError("Browser not started. Call start() first.")
        return self._human

    async def navigate(self, url: str) -> None:
        """Navigate to a URL with human-like delay."""
        await self.human.wait_human(0.5, 1.5)
        await self.page.goto(url, wait_until="domcontentloaded")
        await self.human.random_scroll()

    async def is_logged_in(self) -> bool:
        """Check if currently logged into LinkedIn."""
        try:
            await self.page.goto(self.LINKEDIN_FEED, wait_until="domcontentloaded")
            await asyncio.sleep(2)
            
            # Check for login page redirect
            current_url = self.page.url
            if "login" in current_url or "authwall" in current_url:
                return False
                
            # Check for feed elements
            feed_element = await self.page.query_selector('div[data-view-name="feed-root"]')
            return feed_element is not None
            
        except Exception:
            return False

    async def login(self, username: str, password: str) -> bool:
        """
        Log into LinkedIn with credentials.
        
        Args:
            username: LinkedIn email.
            password: LinkedIn password.
            
        Returns:
            True if login was successful.
        """
        try:
            await self.navigate(self.LINKEDIN_LOGIN)
            await asyncio.sleep(2)
            
            # Find and fill email
            email_input = await self.page.wait_for_selector(
                self.SELECTOR_LOGIN_EMAIL,
                timeout=10000,
            )
            if email_input:
                await self.human.click_element(email_input)
                await self.human.type_text(username)
            
            await self.human.wait_human(0.5, 1.0)
            
            # Find and fill password
            password_input = await self.page.wait_for_selector(
                self.SELECTOR_LOGIN_PASSWORD,
            )
            if password_input:
                await self.human.click_element(password_input)
                await self.human.type_text(password)
            
            await self.human.wait_human(0.5, 1.0)
            
            # Click login button
            login_button = await self.page.wait_for_selector(
                self.SELECTOR_LOGIN_BUTTON,
            )
            if login_button:
                await self.human.click_element(login_button)
            
            # Wait for navigation
            await asyncio.sleep(5)
            
            # Verify login
            is_logged = await self.is_logged_in()
            
            if is_logged and self._context:
                await self.cookie_manager.save_cookies(self._context)
                
            return is_logged
            
        except Exception as e:
            print(f"Login failed: {e}")
            return False

    async def search_jobs(
        self,
        keywords: list[str],
        location: str = "",
        remote_only: bool = False,
    ) -> str:
        """
        Navigate to LinkedIn job search with filters.
        
        Args:
            keywords: Search keywords.
            location: Location filter.
            remote_only: Only remote jobs.
            
        Returns:
            URL of the search results page.
        """
        search_query = " ".join(keywords)
        url = f"{self.LINKEDIN_JOBS}/search/?keywords={search_query}"
        
        if location:
            url += f"&location={location}"
        if remote_only:
            url += "&f_WRA=1"  # LinkedIn remote filter
        
        # Easy Apply filter
        url += "&f_AL=true"
        
        await self.navigate(url)
        return url

    async def upload_file_invisible(
        self,
        file_path: Path,
        input_selector: str = 'input[type="file"]',
    ) -> bool:
        """
        Upload file without opening file dialog (BE-03).
        
        Args:
            file_path: Path to the file to upload.
            input_selector: CSS selector for the file input.
            
        Returns:
            True if upload was successful.
        """
        try:
            # Find the file input (may be hidden)
            file_input = await self.page.query_selector(input_selector)
            
            if file_input:
                await file_input.set_input_files(str(file_path))
                return True
            
            # Try to find any file input
            file_inputs = await self.page.query_selector_all('input[type="file"]')
            if file_inputs:
                await file_inputs[0].set_input_files(str(file_path))
                return True
                
            return False
            
        except Exception:
            return False

    async def take_screenshot(self, path: Path) -> None:
        """Take a screenshot for debugging."""
        await self.page.screenshot(path=str(path))

    async def get_page_content(self) -> str:
        """Get the current page HTML content."""
        return await self.page.content()
</file>

<file path="src/infrastructure/browser/cookie_manager.py">
"""
Cookie Manager - Session persistence for LinkedIn.

Implements BE-01: Cookie management with auth.json.
Saves and loads browser cookies to avoid repeated logins.
"""

import json
from pathlib import Path
from typing import Any, Optional

from playwright.async_api import BrowserContext


class CookieManager:
    """
    Manages browser session cookies for LinkedIn.
    
    Persists cookies to auth.json after successful login,
    and restores them on subsequent runs to avoid re-authentication.
    """
    
    def __init__(self, auth_file_path: Path) -> None:
        """
        Initialize cookie manager.
        
        Args:
            auth_file_path: Path to the auth.json file for cookie storage.
        """
        self.auth_file_path = auth_file_path

    def has_saved_session(self) -> bool:
        """Check if there's a saved session available."""
        return self.auth_file_path.exists()

    async def save_cookies(self, context: BrowserContext) -> None:
        """
        Save current browser cookies to file.
        
        Args:
            context: Playwright browser context.
        """
        cookies = await context.cookies()
        storage_state = await context.storage_state()
        
        data = {
            "cookies": cookies,
            "storage_state": storage_state,
        }
        
        self.auth_file_path.parent.mkdir(parents=True, exist_ok=True)
        self.auth_file_path.write_text(json.dumps(data, indent=2))
        
        # Restrict permissions
        try:
            self.auth_file_path.chmod(0o600)
        except OSError:
            pass

    async def load_cookies(self, context: BrowserContext) -> bool:
        """
        Load saved cookies into browser context.
        
        Args:
            context: Playwright browser context.
            
        Returns:
            True if cookies were loaded successfully.
        """
        if not self.has_saved_session():
            return False
            
        try:
            data = json.loads(self.auth_file_path.read_text())
            cookies = data.get("cookies", [])
            
            if cookies:
                await context.add_cookies(cookies)
                return True
                
        except (json.JSONDecodeError, KeyError, OSError):
            return False
            
        return False

    def get_storage_state_path(self) -> Optional[str]:
        """
        Get path to storage state file if it exists.
        
        Returns:
            Absolute path to auth file or None.
        """
        if self.has_saved_session():
            return str(self.auth_file_path.absolute())
        return None

    def clear_session(self) -> None:
        """Delete saved session cookies."""
        if self.auth_file_path.exists():
            self.auth_file_path.unlink()

    def get_session_info(self) -> dict[str, Any]:
        """
        Get information about the saved session.
        
        Returns:
            Dictionary with session metadata.
        """
        if not self.has_saved_session():
            return {
                "exists": False,
                "path": str(self.auth_file_path),
            }
            
        try:
            data = json.loads(self.auth_file_path.read_text())
            cookies = data.get("cookies", [])
            
            # Find LinkedIn session cookies
            linkedin_cookies = [
                c for c in cookies
                if "linkedin" in c.get("domain", "").lower()
            ]
            
            return {
                "exists": True,
                "path": str(self.auth_file_path),
                "cookie_count": len(cookies),
                "linkedin_cookies": len(linkedin_cookies),
                "has_li_at": any(
                    c.get("name") == "li_at" for c in linkedin_cookies
                ),
            }
            
        except (json.JSONDecodeError, OSError):
            return {
                "exists": True,
                "path": str(self.auth_file_path),
                "error": "Failed to read session file",
            }
</file>

<file path="src/infrastructure/browser/human_simulator.py">
"""
Human Simulator - Bezier curves and natural mouse movement.

Implements BE-02: Simulation of human behavior to avoid detection.
- Mouse movement via Bezier curves
- Random scroll patterns
- Natural typing with variable speed
"""

import asyncio
import math
import random
from dataclasses import dataclass
from typing import Optional

from playwright.async_api import Page, ElementHandle


@dataclass
class Point:
    """2D point for mouse coordinates."""
    x: float
    y: float


class HumanSimulator:
    """
    Simulates human-like interactions with the browser.
    
    Key techniques:
    - Bezier curve mouse movements (not straight lines)
    - Random micro-movements and overshoots
    - Variable typing speed with occasional pauses
    - Natural scrolling patterns
    """
    
    # Mouse movement parameters
    MOUSE_STEPS_MIN = 20
    MOUSE_STEPS_MAX = 40
    MOUSE_OVERSHOOT_CHANCE = 0.3
    
    # Typing parameters
    TYPING_DELAY_MIN = 0.05  # 50ms
    TYPING_DELAY_MAX = 0.15  # 150ms
    TYPING_PAUSE_CHANCE = 0.1
    TYPING_PAUSE_MIN = 0.3  # 300ms
    TYPING_PAUSE_MAX = 0.8  # 800ms
    
    # Scroll parameters
    SCROLL_STEP_MIN = 100
    SCROLL_STEP_MAX = 300

    def __init__(self, page: Page) -> None:
        """Initialize with Playwright page."""
        self.page = page
        self._current_mouse: Point = Point(0, 0)

    @staticmethod
    def bezier_point(
        t: float,
        p0: Point,
        p1: Point,
        p2: Point,
        p3: Point,
    ) -> Point:
        """
        Calculate point on cubic Bezier curve.
        
        Args:
            t: Parameter from 0 to 1
            p0: Start point
            p1: Control point 1
            p2: Control point 2
            p3: End point
            
        Returns:
            Point on the curve at parameter t
        """
        u = 1 - t
        tt = t * t
        uu = u * u
        uuu = uu * u
        ttt = tt * t
        
        x = uuu * p0.x + 3 * uu * t * p1.x + 3 * u * tt * p2.x + ttt * p3.x
        y = uuu * p0.y + 3 * uu * t * p1.y + 3 * u * tt * p2.y + ttt * p3.y
        
        return Point(x, y)

    def generate_bezier_path(
        self,
        start: Point,
        end: Point,
        steps: Optional[int] = None,
    ) -> list[Point]:
        """
        Generate natural mouse path using Bezier curves.
        
        Args:
            start: Starting position
            end: Target position
            steps: Number of points (random if None)
            
        Returns:
            List of points forming the path
        """
        if steps is None:
            steps = random.randint(self.MOUSE_STEPS_MIN, self.MOUSE_STEPS_MAX)
        
        # Generate control points for natural curve
        dist = math.sqrt((end.x - start.x) ** 2 + (end.y - start.y) ** 2)
        spread = dist * 0.3  # Control point spread
        
        # Randomize control points
        cp1 = Point(
            start.x + (end.x - start.x) * 0.3 + random.uniform(-spread, spread),
            start.y + (end.y - start.y) * 0.3 + random.uniform(-spread, spread),
        )
        cp2 = Point(
            start.x + (end.x - start.x) * 0.7 + random.uniform(-spread, spread),
            start.y + (end.y - start.y) * 0.7 + random.uniform(-spread, spread),
        )
        
        # Generate path points
        path = []
        for i in range(steps + 1):
            t = i / steps
            # Add easing (slow start and end)
            t = t * t * (3 - 2 * t)
            point = self.bezier_point(t, start, cp1, cp2, end)
            # Add micro-jitter
            point.x += random.uniform(-1, 1)
            point.y += random.uniform(-1, 1)
            path.append(point)
            
        return path

    async def move_mouse_to(
        self,
        x: float,
        y: float,
        overshoot: bool = True,
    ) -> None:
        """
        Move mouse to target using natural Bezier curve.
        
        Args:
            x: Target X coordinate
            y: Target Y coordinate
            overshoot: Whether to overshoot and correct
        """
        target = Point(x, y)
        
        # Sometimes overshoot the target
        if overshoot and random.random() < self.MOUSE_OVERSHOOT_CHANCE:
            offset = random.uniform(5, 15)
            angle = random.uniform(0, 2 * math.pi)
            overshoot_point = Point(
                x + math.cos(angle) * offset,
                y + math.sin(angle) * offset,
            )
            
            # Move to overshoot point
            path = self.generate_bezier_path(self._current_mouse, overshoot_point)
            for point in path:
                await self.page.mouse.move(point.x, point.y)
                await asyncio.sleep(random.uniform(0.001, 0.005))
            
            self._current_mouse = overshoot_point
            await asyncio.sleep(random.uniform(0.05, 0.1))
        
        # Move to actual target
        path = self.generate_bezier_path(self._current_mouse, target)
        for point in path:
            await self.page.mouse.move(point.x, point.y)
            await asyncio.sleep(random.uniform(0.001, 0.005))
        
        self._current_mouse = target

    async def click_element(
        self,
        element: ElementHandle,
        offset_variance: int = 5,
    ) -> None:
        """
        Click element with natural mouse movement.
        
        Args:
            element: Element to click
            offset_variance: Random offset from center
        """
        box = await element.bounding_box()
        if not box:
            await element.click()
            return
        
        # Calculate target with offset
        x = box["x"] + box["width"] / 2 + random.uniform(-offset_variance, offset_variance)
        y = box["y"] + box["height"] / 2 + random.uniform(-offset_variance, offset_variance)
        
        await self.move_mouse_to(x, y)
        await asyncio.sleep(random.uniform(0.05, 0.15))
        await self.page.mouse.click(x, y)

    async def type_text(
        self,
        text: str,
        element: Optional[ElementHandle] = None,
    ) -> None:
        """
        Type text with human-like delays.
        
        Args:
            text: Text to type
            element: Optional element to click first
        """
        if element:
            await self.click_element(element)
            await asyncio.sleep(random.uniform(0.1, 0.2))
        
        for char in text:
            # Variable typing speed
            delay = random.uniform(self.TYPING_DELAY_MIN, self.TYPING_DELAY_MAX)
            
            # Occasional pause (thinking)
            if random.random() < self.TYPING_PAUSE_CHANCE:
                await asyncio.sleep(
                    random.uniform(self.TYPING_PAUSE_MIN, self.TYPING_PAUSE_MAX)
                )
            
            await self.page.keyboard.type(char, delay=delay * 1000)

    async def scroll_page(
        self,
        direction: str = "down",
        amount: Optional[int] = None,
    ) -> None:
        """
        Scroll page with natural pattern.
        
        Args:
            direction: 'up' or 'down'
            amount: Scroll amount (random if None)
        """
        if amount is None:
            amount = random.randint(self.SCROLL_STEP_MIN, self.SCROLL_STEP_MAX)
        
        if direction == "up":
            amount = -amount
        
        # Scroll in small increments
        steps = random.randint(3, 6)
        step_amount = amount // steps
        
        for _ in range(steps):
            await self.page.mouse.wheel(0, step_amount)
            await asyncio.sleep(random.uniform(0.05, 0.15))

    async def random_scroll(self) -> None:
        """Perform random scrolling to simulate reading."""
        scroll_count = random.randint(2, 5)
        
        for _ in range(scroll_count):
            direction = random.choice(["down", "down", "down", "up"])  # Bias toward down
            await self.scroll_page(direction)
            await asyncio.sleep(random.uniform(0.5, 2.0))

    async def hover_element(self, element: ElementHandle) -> None:
        """Hover over element with natural movement."""
        box = await element.bounding_box()
        if box:
            x = box["x"] + box["width"] / 2
            y = box["y"] + box["height"] / 2
            await self.move_mouse_to(x, y, overshoot=False)

    async def wait_human(self, min_sec: float = 0.5, max_sec: float = 2.0) -> None:
        """Wait a random human-like duration."""
        await asyncio.sleep(random.uniform(min_sec, max_sec))
</file>

<file path="src/infrastructure/parsers/__init__.py">
# Parsers Package
from .resume_parser import ResumeParser
from .job_parser import JobParser

__all__ = ["ResumeParser", "JobParser"]
</file>

<file path="src/infrastructure/parsers/job_parser.py">
"""
Job Parser - LinkedIn job page and form extraction.

Implements BE-04: Extract questions and options from Easy Apply forms.
Parses job descriptions, requirements, and application form fields.
"""

import re
from dataclasses import dataclass, field
from typing import Optional

from playwright.async_api import Page, ElementHandle

from src.domain.entities import Job


@dataclass
class FormField:
    """Represents a form field in the Easy Apply form."""
    
    field_type: str  # text, select, radio, checkbox, file, textarea
    label: str
    name: str = ""
    options: list[str] = field(default_factory=list)
    required: bool = False
    current_value: str = ""


class JobParser:
    """
    Parser for LinkedIn job postings and Easy Apply forms.
    
    Extracts job details and form fields for AI processing.
    """
    
    # Selectors for job details
    SELECTOR_JOB_TITLE = 'h1.job-title, h1.jobs-unified-top-card__job-title'
    SELECTOR_COMPANY = '.job-company-name, .jobs-unified-top-card__company-name'
    SELECTOR_LOCATION = '.job-location, .jobs-unified-top-card__bullet'
    SELECTOR_DESCRIPTION = '.job-description, .jobs-description__content'
    SELECTOR_JOB_ID = 'input[name="jobId"], [data-job-id]'
    
    # Selectors for Easy Apply form
    SELECTOR_FORM_SECTION = '.jobs-easy-apply-content, .jobs-easy-apply-form-section'
    SELECTOR_FORM_LABEL = 'label'
    SELECTOR_TEXT_INPUT = 'input[type="text"], input[type="email"], input[type="tel"]'
    SELECTOR_SELECT = 'select'
    SELECTOR_RADIO = 'input[type="radio"]'
    SELECTOR_CHECKBOX = 'input[type="checkbox"]'
    SELECTOR_TEXTAREA = 'textarea'
    SELECTOR_FILE_INPUT = 'input[type="file"]'

    def __init__(self, page: Page) -> None:
        """Initialize with Playwright page."""
        self.page = page

    async def parse_job_listing(self) -> Optional[Job]:
        """
        Parse the current job listing page.
        
        Returns:
            Job entity with extracted details, or None if parsing fails.
        """
        try:
            # Get job ID from URL or page
            job_id = await self._extract_job_id()
            if not job_id:
                return None
            
            # Get title
            title_elem = await self.page.query_selector(self.SELECTOR_JOB_TITLE)
            title = await title_elem.inner_text() if title_elem else "Unknown"
            
            # Get company
            company_elem = await self.page.query_selector(self.SELECTOR_COMPANY)
            company = await company_elem.inner_text() if company_elem else "Unknown"
            
            # Get location
            location_elem = await self.page.query_selector(self.SELECTOR_LOCATION)
            location = await location_elem.inner_text() if location_elem else ""
            
            # Get description
            desc_elem = await self.page.query_selector(self.SELECTOR_DESCRIPTION)
            description = await desc_elem.inner_text() if desc_elem else ""
            
            # Check for remote indicators
            is_remote = any(
                word in (description.lower() + location.lower())
                for word in ["remote", "remoto", "home office", "trabalho remoto"]
            )
            
            return Job(
                job_id=job_id,
                title=title.strip(),
                company=company.strip(),
                location=location.strip(),
                description=description.strip(),
                url=self.page.url,
                is_remote=is_remote,
                is_easy_apply=True,  # We're on Easy Apply flow
            )
            
        except Exception as e:
            print(f"Failed to parse job listing: {e}")
            return None

    async def _extract_job_id(self) -> Optional[str]:
        """Extract job ID from URL or page."""
        # Try URL first
        url = self.page.url
        match = re.search(r'/jobs/view/(\d+)', url)
        if match:
            return match.group(1)
        
        match = re.search(r'currentJobId=(\d+)', url)
        if match:
            return match.group(1)
        
        # Try page element
        elem = await self.page.query_selector('[data-job-id]')
        if elem:
            return await elem.get_attribute('data-job-id')
        
        return None

    async def parse_form_fields(self) -> list[FormField]:
        """
        Parse the current Easy Apply form fields.
        
        Returns:
            List of FormField objects with labels and options.
        """
        fields: list[FormField] = []
        
        try:
            # Find form section
            form_section = await self.page.query_selector(self.SELECTOR_FORM_SECTION)
            if not form_section:
                form_section = self.page
            
            # Parse text inputs
            text_inputs = await form_section.query_selector_all(self.SELECTOR_TEXT_INPUT)
            for input_elem in text_inputs:
                field = await self._parse_text_input(input_elem)
                if field:
                    fields.append(field)
            
            # Parse textareas
            textareas = await form_section.query_selector_all(self.SELECTOR_TEXTAREA)
            for textarea_elem in textareas:
                field = await self._parse_textarea(textarea_elem)
                if field:
                    fields.append(field)
            
            # Parse select dropdowns
            selects = await form_section.query_selector_all(self.SELECTOR_SELECT)
            for select_elem in selects:
                field = await self._parse_select(select_elem)
                if field:
                    fields.append(field)
            
            # Parse radio button groups
            radio_groups = await self._find_radio_groups(form_section)
            fields.extend(radio_groups)
            
            # Parse file inputs
            file_inputs = await form_section.query_selector_all(self.SELECTOR_FILE_INPUT)
            for file_elem in file_inputs:
                field = await self._parse_file_input(file_elem)
                if field:
                    fields.append(field)
                    
        except Exception as e:
            print(f"Failed to parse form fields: {e}")
        
        return fields

    async def _parse_text_input(self, elem: ElementHandle) -> Optional[FormField]:
        """Parse a text input field."""
        try:
            name = await elem.get_attribute("name") or ""
            input_id = await elem.get_attribute("id") or ""
            required = await elem.get_attribute("required") is not None
            current = await elem.input_value()
            
            # Find associated label
            label = await self._find_label(elem, input_id)
            
            return FormField(
                field_type="text",
                label=label,
                name=name,
                required=required,
                current_value=current,
            )
        except Exception:
            return None

    async def _parse_textarea(self, elem: ElementHandle) -> Optional[FormField]:
        """Parse a textarea field."""
        try:
            name = await elem.get_attribute("name") or ""
            input_id = await elem.get_attribute("id") or ""
            required = await elem.get_attribute("required") is not None
            current = await elem.input_value()
            
            label = await self._find_label(elem, input_id)
            
            return FormField(
                field_type="textarea",
                label=label,
                name=name,
                required=required,
                current_value=current,
            )
        except Exception:
            return None

    async def _parse_select(self, elem: ElementHandle) -> Optional[FormField]:
        """Parse a select dropdown."""
        try:
            name = await elem.get_attribute("name") or ""
            select_id = await elem.get_attribute("id") or ""
            required = await elem.get_attribute("required") is not None
            
            # Get options
            options: list[str] = []
            option_elems = await elem.query_selector_all("option")
            for opt in option_elems:
                opt_text = await opt.inner_text()
                if opt_text.strip():
                    options.append(opt_text.strip())
            
            label = await self._find_label(elem, select_id)
            
            return FormField(
                field_type="select",
                label=label,
                name=name,
                options=options,
                required=required,
            )
        except Exception:
            return None

    async def _find_radio_groups(self, container: ElementHandle) -> list[FormField]:
        """Find and parse radio button groups."""
        fields: list[FormField] = []
        
        try:
            radios = await container.query_selector_all(self.SELECTOR_RADIO)
            groups: dict[str, list[str]] = {}
            
            for radio in radios:
                name = await radio.get_attribute("name") or ""
                if not name:
                    continue
                    
                if name not in groups:
                    groups[name] = []
                
                # Get label text
                parent = await radio.evaluate_handle("el => el.closest('label')")
                if parent:
                    label_text = await parent.inner_text()
                    groups[name].append(label_text.strip())
            
            for name, options in groups.items():
                fields.append(FormField(
                    field_type="radio",
                    label=name,  # Will need label from fieldset/legend
                    name=name,
                    options=options,
                ))
                
        except Exception:
            pass
        
        return fields

    async def _parse_file_input(self, elem: ElementHandle) -> Optional[FormField]:
        """Parse a file input field."""
        try:
            name = await elem.get_attribute("name") or ""
            accept = await elem.get_attribute("accept") or ""
            
            return FormField(
                field_type="file",
                label=f"Upload ({accept})" if accept else "Upload",
                name=name,
            )
        except Exception:
            return None

    async def _find_label(self, elem: ElementHandle, for_id: str) -> str:
        """Find label text for a form element."""
        try:
            # Try label[for=id]
            if for_id:
                label_elem = await self.page.query_selector(f'label[for="{for_id}"]')
                if label_elem:
                    return (await label_elem.inner_text()).strip()
            
            # Try parent label
            parent_label = await elem.evaluate_handle("el => el.closest('label')")
            if parent_label:
                return (await parent_label.inner_text()).strip()
            
            # Try aria-label
            aria_label = await elem.get_attribute("aria-label")
            if aria_label:
                return aria_label
            
            # Try placeholder
            placeholder = await elem.get_attribute("placeholder")
            if placeholder:
                return placeholder
                
        except Exception:
            pass
        
        return "Unknown field"
</file>

<file path="src/infrastructure/parsers/resume_parser.py">
"""
Resume Parser - PDF and DOCX text extraction.

Implements FE-03: Extract text from resume files for AI context.
Uses PyMuPDF (fitz) for PDF and python-docx for DOCX.
"""

import re
from pathlib import Path
from typing import Optional

import fitz  # PyMuPDF
from docx import Document


class ResumeParser:
    """
    Parser for extracting text from resume files.
    
    Supports PDF and DOCX formats.
    """
    
    SUPPORTED_EXTENSIONS = {".pdf", ".docx", ".doc"}

    @classmethod
    def is_supported(cls, file_path: Path) -> bool:
        """Check if file type is supported."""
        return file_path.suffix.lower() in cls.SUPPORTED_EXTENSIONS

    @classmethod
    def extract_text(cls, file_path: Path) -> str:
        """
        Extract text from a resume file.
        
        Args:
            file_path: Path to the PDF or DOCX file.
            
        Returns:
            Extracted text content.
            
        Raises:
            ValueError: If file type is not supported.
            FileNotFoundError: If file doesn't exist.
        """
        if not file_path.exists():
            raise FileNotFoundError(f"File not found: {file_path}")
            
        suffix = file_path.suffix.lower()
        
        if suffix == ".pdf":
            return cls._extract_pdf(file_path)
        elif suffix in {".docx", ".doc"}:
            return cls._extract_docx(file_path)
        else:
            raise ValueError(f"Unsupported file type: {suffix}")

    @staticmethod
    def _extract_pdf(file_path: Path) -> str:
        """Extract text from PDF using PyMuPDF."""
        text_parts = []
        
        with fitz.open(str(file_path)) as doc:
            for page in doc:
                text = page.get_text()
                if text:
                    text_parts.append(text)
        
        return "\n\n".join(text_parts)

    @staticmethod
    def _extract_docx(file_path: Path) -> str:
        """Extract text from DOCX using python-docx."""
        doc = Document(str(file_path))
        text_parts = []
        
        for paragraph in doc.paragraphs:
            if paragraph.text.strip():
                text_parts.append(paragraph.text)
        
        # Also extract from tables
        for table in doc.tables:
            for row in table.rows:
                row_text = []
                for cell in row.cells:
                    if cell.text.strip():
                        row_text.append(cell.text.strip())
                if row_text:
                    text_parts.append(" | ".join(row_text))
        
        return "\n".join(text_parts)

    @classmethod
    def extract_contact_info(cls, text: str) -> dict[str, Optional[str]]:
        """
        Extract basic contact information from resume text.
        
        Args:
            text: Resume text content.
            
        Returns:
            Dictionary with extracted email, phone, and name.
        """
        info: dict[str, Optional[str]] = {
            "email": None,
            "phone": None,
            "name": None,
        }
        
        # Email pattern
        email_match = re.search(
            r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}',
            text
        )
        if email_match:
            info["email"] = email_match.group()
        
        # Phone pattern (various formats)
        phone_match = re.search(
            r'(?:\+?55\s?)?(?:\(?0?\d{2}\)?\s?)?(?:9\s?)?\d{4}[-.\s]?\d{4}',
            text
        )
        if phone_match:
            info["phone"] = phone_match.group()
        
        # Name: usually first non-empty line
        lines = text.strip().split('\n')
        for line in lines[:5]:  # Check first 5 lines
            line = line.strip()
            # Name is typically just letters and spaces
            if line and re.match(r'^[A-Za-zÃ€-Ã¿\s]+$', line) and len(line) > 3:
                info["name"] = line
                break
        
        return info

    @classmethod
    def extract_skills(cls, text: str) -> list[str]:
        """
        Extract likely skills from resume text.
        
        Args:
            text: Resume text content.
            
        Returns:
            List of identified skills.
        """
        # Common tech skills to look for
        common_skills = [
            "Python", "Java", "JavaScript", "TypeScript", "C#", "C++",
            "React", "Angular", "Vue", "Node.js", "Django", "Flask",
            "SQL", "PostgreSQL", "MySQL", "MongoDB", "Redis",
            "AWS", "Azure", "GCP", "Docker", "Kubernetes",
            "Git", "Linux", "CI/CD", "REST", "GraphQL",
            "Scrum", "Agile", "TDD", "Clean Code",
        ]
        
        found_skills = []
        text_lower = text.lower()
        
        for skill in common_skills:
            if skill.lower() in text_lower:
                found_skills.append(skill)
        
        return found_skills
</file>

<file path="src/infrastructure/security/__init__.py">
# Security Package
from .crypto import CryptoService

__all__ = ["CryptoService"]
</file>

<file path="src/infrastructure/security/crypto.py">
"""
Crypto Service - Credential encryption using Fernet.

Provides symmetric encryption for storing LinkedIn credentials locally.
Implements FE-02 requirement for encrypted credential storage.
"""

from pathlib import Path
from typing import Optional

from cryptography.fernet import Fernet, InvalidToken

from src.domain.value_objects import Credentials


class CryptoService:
    """
    Cryptographic service for credential encryption.
    
    Uses Fernet symmetric encryption from the cryptography library.
    The encryption key is stored locally in a separate file.
    """
    
    def __init__(self, key_path: Path) -> None:
        """
        Initialize the crypto service.
        
        Args:
            key_path: Path to store/load the encryption key.
        """
        self.key_path = key_path
        self._fernet: Optional[Fernet] = None

    def initialize(self) -> None:
        """Initialize or load the encryption key."""
        if self.key_path.exists():
            key = self.key_path.read_bytes()
        else:
            key = Fernet.generate_key()
            self.key_path.parent.mkdir(parents=True, exist_ok=True)
            self.key_path.write_bytes(key)
            # Restrict file permissions (Unix only)
            try:
                self.key_path.chmod(0o600)
            except OSError:
                pass  # Windows doesn't support chmod
                
        self._fernet = Fernet(key)

    @property
    def fernet(self) -> Fernet:
        """Get the Fernet instance."""
        if not self._fernet:
            raise RuntimeError("CryptoService not initialized. Call initialize() first.")
        return self._fernet

    def encrypt(self, data: str) -> str:
        """
        Encrypt a string.
        
        Args:
            data: Plain text to encrypt.
            
        Returns:
            Base64-encoded encrypted string.
        """
        encrypted = self.fernet.encrypt(data.encode("utf-8"))
        return encrypted.decode("utf-8")

    def decrypt(self, encrypted_data: str) -> str:
        """
        Decrypt a string.
        
        Args:
            encrypted_data: Base64-encoded encrypted string.
            
        Returns:
            Decrypted plain text.
            
        Raises:
            InvalidToken: If decryption fails (wrong key or corrupted data).
        """
        decrypted = self.fernet.decrypt(encrypted_data.encode("utf-8"))
        return decrypted.decode("utf-8")

    def try_decrypt(self, encrypted_data: str) -> Optional[str]:
        """
        Try to decrypt a string, returning None on failure.
        
        Args:
            encrypted_data: Base64-encoded encrypted string.
            
        Returns:
            Decrypted plain text or None if decryption fails.
        """
        try:
            return self.decrypt(encrypted_data)
        except (InvalidToken, Exception):
            return None

    def encrypt_credentials(self, credentials: Credentials) -> Credentials:
        """
        Encrypt credentials password.
        
        Args:
            credentials: Credentials with plain text password.
            
        Returns:
            New Credentials with encrypted password.
        """
        if credentials.is_encrypted:
            return credentials
            
        encrypted_password = self.encrypt(credentials.password)
        return credentials.with_encrypted_password(encrypted_password)

    def decrypt_credentials(self, credentials: Credentials) -> Credentials:
        """
        Decrypt credentials password.
        
        Args:
            credentials: Credentials with encrypted password.
            
        Returns:
            New Credentials with decrypted password.
            
        Raises:
            InvalidToken: If decryption fails.
        """
        if not credentials.is_encrypted:
            return credentials
            
        decrypted_password = self.decrypt(credentials.password)
        return credentials.with_decrypted_password(decrypted_password)

    def try_decrypt_credentials(self, credentials: Credentials) -> Optional[Credentials]:
        """
        Try to decrypt credentials, returning None on failure.
        
        Args:
            credentials: Credentials with encrypted password.
            
        Returns:
            New Credentials with decrypted password or None if decryption fails.
        """
        try:
            return self.decrypt_credentials(credentials)
        except (InvalidToken, Exception):
            return None
</file>

<file path="src/infrastructure/storage/__init__.py">
# Storage Package
from .sqlite_adapter import SQLiteAdapter
from .migrations import run_migrations

__all__ = ["SQLiteAdapter", "run_migrations"]
</file>

<file path="src/infrastructure/storage/migrations.py">
"""
Database Migrations - Schema setup and versioning.

Implements the schema defined in PRD Section 7.
"""

import sqlite3
from pathlib import Path
from typing import Optional


SCHEMA_VERSION = 1

SCHEMA_SQL = """
-- Configuration key-value store
CREATE TABLE IF NOT EXISTS config (
    key TEXT PRIMARY KEY,
    value TEXT
);

-- Job applications log (candidaturas)
CREATE TABLE IF NOT EXISTS candidaturas (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    job_id TEXT UNIQUE,
    empresa TEXT,
    titulo TEXT,
    localizacao TEXT,
    data_hora DATETIME DEFAULT CURRENT_TIMESTAMP,
    status TEXT CHECK(status IN ('SUCESSO', 'FALHA', 'PULADO', 'PENDING')),
    motivo_log TEXT,
    tokens_ia INTEGER DEFAULT 0
);

-- Daily statistics
CREATE TABLE IF NOT EXISTS estatisticas_diarias (
    data DATE PRIMARY KEY,
    quantidade INTEGER DEFAULT 0
);

-- Schema version tracking
CREATE TABLE IF NOT EXISTS schema_version (
    version INTEGER PRIMARY KEY
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_candidaturas_job_id ON candidaturas(job_id);
CREATE INDEX IF NOT EXISTS idx_candidaturas_status ON candidaturas(status);
CREATE INDEX IF NOT EXISTS idx_candidaturas_data_hora ON candidaturas(data_hora);
"""


def run_migrations(db_path: Path, conn: Optional[sqlite3.Connection] = None) -> None:
    """
    Run database migrations to ensure schema is up to date.
    
    Args:
        db_path: Path to the SQLite database file.
        conn: Optional existing connection to use.
    """
    should_close = conn is None
    if conn is None:
        conn = sqlite3.connect(str(db_path))
    
    try:
        cursor = conn.cursor()
        
        # Check current version
        cursor.execute(
            "SELECT name FROM sqlite_master WHERE type='table' AND name='schema_version'"
        )
        version_table_exists = cursor.fetchone() is not None
        
        current_version = 0
        if version_table_exists:
            cursor.execute("SELECT MAX(version) FROM schema_version")
            row = cursor.fetchone()
            current_version = row[0] if row and row[0] else 0
        
        # Run migrations if needed
        if current_version < SCHEMA_VERSION:
            cursor.executescript(SCHEMA_SQL)
            
            # Record new version
            cursor.execute(
                "INSERT OR REPLACE INTO schema_version (version) VALUES (?)",
                (SCHEMA_VERSION,)
            )
            conn.commit()
            
    finally:
        if should_close:
            conn.close()


async def run_migrations_async(db_path: Path) -> None:
    """
    Async version of run_migrations for use with aiosqlite.
    
    Args:
        db_path: Path to the SQLite database file.
    """
    import aiosqlite
    
    async with aiosqlite.connect(str(db_path)) as db:
        # Check current version
        cursor = await db.execute(
            "SELECT name FROM sqlite_master WHERE type='table' AND name='schema_version'"
        )
        version_table_exists = await cursor.fetchone() is not None
        
        current_version = 0
        if version_table_exists:
            cursor = await db.execute("SELECT MAX(version) FROM schema_version")
            row = await cursor.fetchone()
            current_version = row[0] if row and row[0] else 0
        
        # Run migrations if needed
        if current_version < SCHEMA_VERSION:
            await db.executescript(SCHEMA_SQL)
            
            # Record new version
            await db.execute(
                "INSERT OR REPLACE INTO schema_version (version) VALUES (?)",
                (SCHEMA_VERSION,)
            )
            await db.commit()
</file>

<file path="src/infrastructure/storage/sqlite_adapter.py">
"""
SQLite Adapter - Database operations for BOTLink.

Implements BE-07: SQLite with job_id uniqueness.
"""

import json
from datetime import date, datetime
from pathlib import Path
from typing import Any, Optional

import aiosqlite

from src.domain.entities import Application, ApplicationStatus
from src.domain.value_objects import Credentials, JobFilter
from .migrations import run_migrations


class SQLiteAdapter:
    """
    SQLite database adapter for BOTLink.
    
    Provides async CRUD operations for applications, config, and statistics.
    """
    
    def __init__(self, db_path: Path) -> None:
        """
        Initialize the adapter.
        
        Args:
            db_path: Path to the SQLite database file.
        """
        self.db_path = db_path
        self._connection: Optional[aiosqlite.Connection] = None

    async def initialize(self) -> None:
        """Initialize database and run migrations."""
        # Ensure parent directory exists
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        
        # Run migrations synchronously first
        run_migrations(self.db_path)
        
        # Open async connection
        self._connection = await aiosqlite.connect(str(self.db_path))
        self._connection.row_factory = aiosqlite.Row

    async def close(self) -> None:
        """Close the database connection."""
        if self._connection:
            await self._connection.close()
            self._connection = None

    @property
    def conn(self) -> aiosqlite.Connection:
        """Get the active connection or raise error."""
        if not self._connection:
            raise RuntimeError("Database not initialized. Call initialize() first.")
        return self._connection

    # ==================== Config Operations ====================
    
    async def get_config(self, key: str, default: Optional[str] = None) -> Optional[str]:
        """Get a config value by key."""
        cursor = await self.conn.execute(
            "SELECT value FROM config WHERE key = ?",
            (key,)
        )
        row = await cursor.fetchone()
        return row["value"] if row else default

    async def set_config(self, key: str, value: str) -> None:
        """Set a config value."""
        await self.conn.execute(
            "INSERT OR REPLACE INTO config (key, value) VALUES (?, ?)",
            (key, value)
        )
        await self.conn.commit()

    async def get_config_json(self, key: str, default: Any = None) -> Any:
        """Get a config value as parsed JSON."""
        value = await self.get_config(key)
        if value is None:
            return default
        try:
            return json.loads(value)
        except json.JSONDecodeError:
            return default

    async def set_config_json(self, key: str, value: Any) -> None:
        """Set a config value as JSON string."""
        await self.set_config(key, json.dumps(value))

    # ==================== Credentials Operations ====================

    async def save_credentials(self, credentials: Credentials) -> None:
        """Save encrypted credentials to config."""
        await self.set_config("linkedin_username", credentials.username)
        await self.set_config("linkedin_password", credentials.password)

    async def get_credentials(self) -> Optional[Credentials]:
        """Get stored credentials."""
        username = await self.get_config("linkedin_username")
        password = await self.get_config("linkedin_password")
        if username and password:
            return Credentials(
                username=username,
                password=password,
                is_encrypted=True,
            )
        return None

    # ==================== Job Filter Operations ====================

    async def save_job_filter(self, job_filter: JobFilter) -> None:
        """Save job filter configuration."""
        await self.set_config_json("job_filter", job_filter.to_dict())

    async def get_job_filter(self) -> Optional[JobFilter]:
        """Get stored job filter."""
        data = await self.get_config_json("job_filter")
        if data:
            return JobFilter.from_dict(data)
        return None

    # ==================== Application Operations ====================

    async def save_application(self, application: Application) -> int:
        """
        Save an application record.
        
        Returns:
            The ID of the inserted/updated record.
        """
        cursor = await self.conn.execute(
            """
            INSERT OR REPLACE INTO candidaturas 
            (job_id, empresa, titulo, localizacao, data_hora, status, motivo_log, tokens_ia)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """,
            (
                application.job_id,
                application.empresa,
                application.titulo,
                application.localizacao,
                application.data_hora.isoformat(),
                application.status.value,
                application.motivo_log,
                application.tokens_ia,
            )
        )
        await self.conn.commit()
        return cursor.lastrowid or 0

    async def get_application(self, job_id: str) -> Optional[Application]:
        """Get an application by job_id."""
        cursor = await self.conn.execute(
            "SELECT * FROM candidaturas WHERE job_id = ?",
            (job_id,)
        )
        row = await cursor.fetchone()
        if row:
            return Application.from_dict(dict(row))
        return None

    async def job_already_applied(self, job_id: str) -> bool:
        """Check if we've already applied to a job."""
        cursor = await self.conn.execute(
            "SELECT 1 FROM candidaturas WHERE job_id = ?",
            (job_id,)
        )
        return await cursor.fetchone() is not None

    async def get_applications(
        self,
        limit: int = 100,
        status: Optional[ApplicationStatus] = None,
        since: Optional[datetime] = None,
    ) -> list[Application]:
        """Get application records with optional filters."""
        query = "SELECT * FROM candidaturas WHERE 1=1"
        params: list[Any] = []
        
        if status:
            query += " AND status = ?"
            params.append(status.value)
            
        if since:
            query += " AND data_hora >= ?"
            params.append(since.isoformat())
            
        query += " ORDER BY data_hora DESC LIMIT ?"
        params.append(limit)
        
        cursor = await self.conn.execute(query, params)
        rows = await cursor.fetchall()
        return [Application.from_dict(dict(row)) for row in rows]

    async def get_today_count(self) -> int:
        """Get count of applications made today."""
        today = date.today().isoformat()
        cursor = await self.conn.execute(
            "SELECT COUNT(*) FROM candidaturas WHERE DATE(data_hora) = ?",
            (today,)
        )
        row = await cursor.fetchone()
        return row[0] if row else 0

    # ==================== Statistics Operations ====================

    async def increment_daily_stats(self, dt: Optional[date] = None) -> None:
        """Increment the daily application counter."""
        target_date = (dt or date.today()).isoformat()
        await self.conn.execute(
            """
            INSERT INTO estatisticas_diarias (data, quantidade)
            VALUES (?, 1)
            ON CONFLICT(data) DO UPDATE SET quantidade = quantidade + 1
            """,
            (target_date,)
        )
        await self.conn.commit()

    async def get_daily_stats(self, dt: Optional[date] = None) -> int:
        """Get application count for a specific day."""
        target_date = (dt or date.today()).isoformat()
        cursor = await self.conn.execute(
            "SELECT quantidade FROM estatisticas_diarias WHERE data = ?",
            (target_date,)
        )
        row = await cursor.fetchone()
        return row["quantidade"] if row else 0

    async def get_stats_range(
        self,
        start: date,
        end: date,
    ) -> list[dict]:
        """Get statistics for a date range."""
        cursor = await self.conn.execute(
            """
            SELECT data, quantidade 
            FROM estatisticas_diarias 
            WHERE data BETWEEN ? AND ?
            ORDER BY data
            """,
            (start.isoformat(), end.isoformat())
        )
        rows = await cursor.fetchall()
        return [{"date": row["data"], "count": row["quantidade"]} for row in rows]
</file>

<file path="src/infrastructure/__init__.py">
# Infrastructure Package
</file>

<file path="src/presentation/gui/components/__init__.py">
# GUI Components
from .job_panel import JobPanel
from .credentials import CredentialsPanel
from .resume_upload import ResumeUpload
from .profile import ProfilePanel
from .controls import ControlsPanel
from .log_dashboard import LogDashboard
from .theme_toggle import ThemeToggle

__all__ = [
    "JobPanel",
    "CredentialsPanel", 
    "ResumeUpload",
    "ProfilePanel",
    "ControlsPanel",
    "LogDashboard",
    "ThemeToggle",
]
</file>

<file path="src/presentation/gui/components/controls.py">
"""
Controls Panel Component - FE-05

Start/Stop bot controls with status display.
"""

import flet as ft
from typing import Callable, Optional

from ..styles import Theme


def create_controls_panel(
    on_start: Optional[Callable[[], None]] = None,
    on_stop: Optional[Callable[[], None]] = None,
    is_running: bool = False,
) -> tuple[ft.Container, dict]:
    """
    Create bot control panel.
    
    Features:
    - Start button (green)
    - Stop button (red, graceful shutdown)
    - Status indicator
    - Daily progress display
    
    Returns:
        Tuple of (container, controls_dict) for external updates
    """
    _is_running = is_running
    _applications_today = 0
    _daily_limit = 50
    
    async def _on_start_click(e) -> None:
        if on_start:
            await on_start()
    
    async def _on_stop_click(e) -> None:
        if on_stop:
            await on_stop()
    
    start_button = ft.ElevatedButton(
        "Iniciar BOT",
        icon="play_arrow",
        bgcolor=Theme.SUCCESS,
        color="white",
        on_click=_on_start_click,
        disabled=_is_running,
    )
    
    stop_button = ft.ElevatedButton(
        "Parar BOT",
        icon="stop",
        bgcolor=Theme.ERROR,
        color="white",
        on_click=_on_stop_click,
        disabled=not _is_running,
    )
    
    status_indicator = ft.Container(
        width=12,
        height=12,
        border_radius=6,
        bgcolor=Theme.SUCCESS if _is_running else Theme.DARK_TEXT_SECONDARY,
    )
    
    status_text = ft.Text(
        "Em execuÃ§Ã£o" if _is_running else "Parado",
        weight="bold",
    )
    
    progress_bar = ft.ProgressBar(
        value=_applications_today / max(_daily_limit, 1),
        color=Theme.PRIMARY,
        bgcolor=Theme.DARK_CARD,
    )
    
    progress_text = ft.Text(
        f"{_applications_today} / {_daily_limit} candidaturas hoje",
    )
    
    container = ft.Container(
        content=ft.Column([
            ft.Text("ðŸ¤– Controles", size=18, weight=ft.FontWeight.BOLD),
            ft.Row([start_button, stop_button], spacing=Theme.SPACING_MD),
            ft.Row([status_indicator, status_text]),
            ft.Divider(),
            ft.Text("Progresso DiÃ¡rio", size=14),
            progress_bar,
            progress_text,
        ], spacing=Theme.SPACING_MD),
        bgcolor=Theme.DARK_CARD,
        border_radius=Theme.RADIUS_LG,
        padding=Theme.SPACING_MD,
    )
    
    controls = {
        "start_button": start_button,
        "stop_button": stop_button,
        "status_indicator": status_indicator,
        "status_text": status_text,
        "progress_bar": progress_bar,
        "progress_text": progress_text,
    }
    
    return container, controls


class ControlsPanel:
    """Wrapper class for controls panel."""
    
    def __init__(
        self,
        on_start: Optional[Callable[[], None]] = None,
        on_stop: Optional[Callable[[], None]] = None,
        is_running: bool = False,
    ):
        self.container, self._controls = create_controls_panel(on_start, on_stop, is_running)
        self._is_running = is_running
    
    def set_running(self, is_running: bool) -> None:
        """Update running state."""
        self._is_running = is_running
        self._controls["start_button"].disabled = is_running
        self._controls["stop_button"].disabled = not is_running
        self._controls["status_indicator"].bgcolor = (
            Theme.SUCCESS if is_running else Theme.DARK_TEXT_SECONDARY
        )
        self._controls["status_text"].value = (
            "Em execuÃ§Ã£o" if is_running else "Parado"
        )
        self.container.update()
    
    def set_progress(self, applications_today: int, daily_limit: int) -> None:
        """Update progress display."""
        self._controls["progress_bar"].value = applications_today / max(daily_limit, 1)
        self._controls["progress_text"].value = f"{applications_today} / {daily_limit} candidaturas hoje"
        self.container.update()
    
    def __getattr__(self, name):
        return getattr(self.container, name)
</file>

<file path="src/presentation/gui/components/credentials.py">
"""
Credentials Panel Component - FE-02

LinkedIn login credentials with encryption.
"""

import flet as ft
from typing import Callable, Optional

from src.domain.value_objects import Credentials
from ..styles import Theme


def create_credentials_panel(
    on_credentials_save: Optional[Callable[[Credentials], None]] = None,
    on_verify_session: Optional[Callable[[], None]] = None,
    session_valid: bool = False,
) -> ft.Container:
    """
    Create credentials panel for LinkedIn login.
    
    Features:
    - Username/email input
    - Password input (hidden)
    - Session verification button
    - Save credentials locally (encrypted)
    """
    _session_valid = session_valid
    
    username_input = ft.TextField(
        label="Email ou UsuÃ¡rio LinkedIn",
        hint_text="seu.email@exemplo.com",
        border_radius=Theme.RADIUS_MD,
        prefix_icon="person",
    )
    
    password_input = ft.TextField(
        label="Senha",
        password=True,
        can_reveal_password=True,
        border_radius=Theme.RADIUS_MD,
        prefix_icon="lock",
    )
    
    status_icon = ft.Icon(
        "check_circle" if _session_valid else "warning",
        color=Theme.SUCCESS if _session_valid else Theme.WARNING,
    )
    
    status_text = ft.Text(
        "SessÃ£o ativa" if _session_valid else "SessÃ£o nÃ£o verificada",
    )
    
    session_status = ft.Row([status_icon, status_text])
    
    async def _on_save(e) -> None:
        """Save credentials."""
        username = username_input.value
        password = password_input.value
        
        if not username or not password:
            return
        
        credentials = Credentials(username=username, password=password)
        
        if on_credentials_save:
            await on_credentials_save(credentials)
        
        # Clear password from UI
        password_input.value = ""
        password_input.update()
    
    async def _on_verify(e) -> None:
        """Verify session."""
        if on_verify_session:
            await on_verify_session()
    
    save_button = ft.ElevatedButton(
        "Salvar Credenciais",
        icon="save",
        on_click=_on_save,
    )
    
    verify_button = ft.OutlinedButton(
        "Verificar SessÃ£o",
        icon="refresh",
        on_click=_on_verify,
    )
    
    container = ft.Container(
        content=ft.Column([
            ft.Text("ðŸ” Credenciais LinkedIn", size=18, weight="bold"),
            username_input,
            password_input,
            ft.Row([save_button, verify_button], spacing=Theme.SPACING_MD),
            session_status,
        ], spacing=Theme.SPACING_MD),
        bgcolor=Theme.DARK_CARD,
        border_radius=Theme.RADIUS_LG,
        padding=Theme.SPACING_MD,
    )
    
    controls = {
        "status_icon": status_icon,
        "status_text": status_text,
    }
    
    return container, controls


class CredentialsPanel:
    """Wrapper class for credentials panel."""
    
    def __init__(
        self,
        on_credentials_save: Optional[Callable[[Credentials], None]] = None,
        on_verify_session: Optional[Callable[[], None]] = None,
        session_valid: bool = False,
    ):
        self.container, self._controls = create_credentials_panel(
            on_credentials_save, on_verify_session, session_valid
        )
    
    def set_status(self, valid: bool) -> None:
        """Update session status."""
        self._controls["status_icon"].name = "check_circle" if valid else "warning"
        self._controls["status_icon"].color = Theme.SUCCESS if valid else Theme.WARNING
        self._controls["status_text"].value = "SessÃ£o ativa" if valid else "SessÃ£o nÃ£o verificada"
        self.container.update()
    
    def __getattr__(self, name):
        return getattr(self.container, name)
</file>

<file path="src/presentation/gui/components/job_panel.py">
"""
Job Panel Component - FE-01

Job search configuration with tags, location, and filters.
"""

import flet as ft
from typing import Callable, Optional

from src.domain.value_objects import JobFilter
from ..styles import Theme


def create_job_panel(
    on_filter_change: Optional[Callable[[JobFilter], None]] = None,
    initial_filter: Optional[JobFilter] = None,
) -> ft.Container:
    """
    Create job search configuration panel.
    
    Features:
    - Multiple keyword tags input
    - Location input
    - Remote only checkbox
    """
    _filter = initial_filter or JobFilter()
    _keywords: list[str] = list(_filter.keywords)
    _location = _filter.location
    _remote_only = _filter.remote_only
    
    keywords_row = ft.Row(controls=[], wrap=True, spacing=Theme.SPACING_SM)
    
    def _build_keyword_chips() -> list[ft.Chip]:
        """Build keyword chip controls."""
        return [
            ft.Chip(
                label=ft.Text(kw),
                on_delete=lambda e, k=kw: _remove_keyword(k),
            )
            for kw in _keywords
        ]
    
    def _emit_change() -> None:
        """Emit filter change event."""
        if on_filter_change:
            job_filter = JobFilter(
                keywords=tuple(_keywords),
                location=_location,
                remote_only=_remote_only,
            )
            on_filter_change(job_filter)
    
    def _add_keyword(e) -> None:
        """Add a keyword tag."""
        nonlocal _keywords
        keyword = keyword_input.value.strip() if keyword_input.value else ""
        if keyword and keyword not in _keywords:
            _keywords.append(keyword)
            keyword_input.value = ""
            keywords_row.controls = _build_keyword_chips()
            _emit_change()
            keyword_input.update()
            keywords_row.update()
    
    def _remove_keyword(keyword: str) -> None:
        """Remove a keyword tag."""
        nonlocal _keywords
        if keyword in _keywords:
            _keywords.remove(keyword)
            keywords_row.controls = _build_keyword_chips()
            _emit_change()
            keywords_row.update()
    
    def _on_location_change(e) -> None:
        """Handle location change."""
        nonlocal _location
        _location = e.control.value or ""
        _emit_change()
    
    def _on_remote_change(e) -> None:
        """Handle remote checkbox change."""
        nonlocal _remote_only
        _remote_only = e.control.value
        _emit_change()
    
    keyword_input = ft.TextField(
        label="Adicionar cargo/palavra-chave",
        hint_text="Ex: Backend Python, DevOps",
        border_radius=Theme.RADIUS_MD,
        on_submit=_add_keyword,
        suffix=ft.IconButton(
            icon="add",
            on_click=_add_keyword,
        ),
    )
    
    keywords_row.controls = _build_keyword_chips()
    
    location_input = ft.TextField(
        label="LocalizaÃ§Ã£o",
        hint_text="Ex: SÃ£o Paulo, SP, Brasil",
        value=_location,
        border_radius=Theme.RADIUS_MD,
        on_change=_on_location_change,
    )
    
    remote_checkbox = ft.Checkbox(
        label="Apenas vagas remotas",
        value=_remote_only,
        on_change=_on_remote_change,
    )
    
    return ft.Container(
        content=ft.Column([
            ft.Text("ðŸŽ¯ ConfiguraÃ§Ã£o de Vagas", size=18, weight="bold"),
            keyword_input,
            keywords_row,
            location_input,
            remote_checkbox,
        ], spacing=Theme.SPACING_MD),
        bgcolor=Theme.DARK_CARD,
        border_radius=Theme.RADIUS_LG,
        padding=Theme.SPACING_MD,
    )


# For backward compatibility
class JobPanel:
    """Wrapper class for job panel."""
    
    def __init__(
        self,
        on_filter_change: Optional[Callable[[JobFilter], None]] = None,
        initial_filter: Optional[JobFilter] = None,
    ):
        self.container = create_job_panel(on_filter_change, initial_filter)
    
    def __getattr__(self, name):
        return getattr(self.container, name)
</file>

<file path="src/presentation/gui/components/log_dashboard.py">
"""
Log Dashboard Component - FE-06

Application log display with filtering.
"""

import flet as ft
from datetime import datetime
from typing import Optional

from src.domain.entities import Application, ApplicationStatus
from ..styles import Theme


def create_log_dashboard() -> tuple[ft.Container, dict]:
    """
    Create log dashboard for application history.
    
    Features:
    - DataTable with application records
    - Console log output
    - Refresh button
    
    Returns:
        Tuple of (container, controls_dict) for external updates
    """
    _applications: list[Application] = []
    
    log_table = ft.DataTable(
        columns=[
            ft.DataColumn(ft.Text("Data/Hora")),
            ft.DataColumn(ft.Text("Empresa")),
            ft.DataColumn(ft.Text("Vaga")),
            ft.DataColumn(ft.Text("Status")),
        ],
        rows=[],
        border=ft.border.all(1, Theme.DARK_CARD),
        border_radius=Theme.RADIUS_MD,
    )
    
    logs_column = ft.Column(
        controls=[],
        scroll="auto",
        height=200,
        spacing=Theme.SPACING_XS,
    )
    
    def _on_refresh(e) -> None:
        """Refresh log data."""
        pass  # Would rebuild table
    
    container = ft.Container(
        content=ft.Column([
            ft.Row([
                ft.Text("ðŸ“Š Log de Candidaturas", size=18, weight="bold"),
                ft.IconButton(
                    icon="refresh",
                    on_click=_on_refresh,
                    tooltip="Atualizar",
                ),
            ], alignment="spaceBetween"),
            ft.Container(
                content=log_table,
                height=150,
                border=ft.border.all(1, Theme.DARK_CARD),
                border_radius=Theme.RADIUS_MD,
            ),
            ft.Divider(),
            ft.Text("Console", size=14),
            ft.Container(
                content=logs_column,
                bgcolor=Theme.DARK_BG,
                border_radius=Theme.RADIUS_MD,
                padding=Theme.SPACING_SM,
            ),
        ], spacing=Theme.SPACING_MD),
        bgcolor=Theme.DARK_CARD,
        border_radius=Theme.RADIUS_LG,
        padding=Theme.SPACING_MD,
    )
    
    controls = {
        "log_table": log_table,
        "logs_column": logs_column,
    }
    
    return container, controls


class LogDashboard:
    """Wrapper class for log dashboard."""
    
    def __init__(self):
        self.container, self._controls = create_log_dashboard()
        self._applications: list[Application] = []
    
    def add_log(self, message: str, level: str = "info") -> None:
        """Add a log message to the console."""
        timestamp = datetime.now().strftime("%H:%M:%S")
        
        colors = {
            "info": Theme.DARK_TEXT,
            "success": Theme.SUCCESS,
            "warning": Theme.WARNING,
            "error": Theme.ERROR,
        }
        
        self._controls["logs_column"].controls.append(
            ft.Text(
                f"[{timestamp}] {message}",
                size=12,
                color=colors.get(level, Theme.DARK_TEXT),
            )
        )
        
        # Keep only last 100 logs
        if len(self._controls["logs_column"].controls) > 100:
            self._controls["logs_column"].controls = self._controls["logs_column"].controls[-100:]
        
        try:
            self._controls["logs_column"].update()
        except Exception:
            pass  # May fail if not attached to page yet
    
    def set_applications(self, applications: list[Application]) -> None:
        """Update displayed applications."""
        self._applications = applications
        # Would rebuild table here
    
    def clear_logs(self) -> None:
        """Clear the console logs."""
        self._controls["logs_column"].controls = []
        try:
            self._controls["logs_column"].update()
        except Exception:
            pass
    
    def __getattr__(self, name):
        return getattr(self.container, name)
</file>

<file path="src/presentation/gui/components/profile.py">
"""
Profile Panel Component - FE-04

Extended profile with bio and attachments.
"""

import flet as ft
from pathlib import Path
from typing import Callable, Optional

from ..styles import Theme


def create_profile_panel(
    page: ft.Page,
    on_bio_change: Optional[Callable[[str], None]] = None,
    initial_bio: str = "",
) -> ft.Container:
    """
    Create extended profile panel.
    
    Features:
    - Bio/cover letter textarea
    - Additional attachments list
    """
    _attachments: list[Path] = []
    
    attachments_list = ft.Column(controls=[], spacing=Theme.SPACING_XS)
    
    def _on_bio_change_handler(e) -> None:
        """Handle bio text change."""
        if on_bio_change:
            on_bio_change(e.control.value or "")
    
    def _on_attachment_picked(e) -> None:
        """Handle attachment file selection."""
        if not e.files:
            return
        
        for file in e.files:
            path = Path(file.path)
            if path not in _attachments:
                _attachments.append(path)
                attachments_list.controls.append(
                    ft.Row([
                        ft.Icon("insert_drive_file", size=16),
                        ft.Text(file.name, expand=True),
                    ])
                )
        
        attachments_list.update()
    
    bio_input = ft.TextField(
        label="Bio / Carta de ApresentaÃ§Ã£o",
        hint_text="Descreva seu perfil profissional, projetos relevantes...",
        multiline=True,
        min_lines=6,
        max_lines=12,
        value=initial_bio,
        border_radius=Theme.RADIUS_MD,
        on_change=_on_bio_change_handler,
    )
    
    file_picker = ft.FilePicker()
    file_picker.on_result = _on_attachment_picked
    page.overlay.append(file_picker)
    
    return ft.Container(
        content=ft.Column([
            ft.Text("ðŸ“ Perfil Estendido", size=18, weight="bold"),
            bio_input,
            ft.Text("Anexos Extras (PortfÃ³lio, Certificados):", size=14),
            ft.OutlinedButton(
                "Adicionar Anexo",
                icon="attach_file",
                on_click=lambda _: file_picker.pick_files(
                    dialog_title="Selecione arquivo adicional",
                ),
            ),
            attachments_list,
        ], spacing=Theme.SPACING_MD),
        bgcolor=Theme.DARK_CARD,
        border_radius=Theme.RADIUS_LG,
        padding=Theme.SPACING_MD,
    )


class ProfilePanel:
    """Wrapper class for profile panel."""
    
    def __init__(
        self,
        on_bio_change: Optional[Callable[[str], None]] = None,
        initial_bio: str = "",
    ):
        self.on_bio_change = on_bio_change
        self.initial_bio = initial_bio
        self.container: Optional[ft.Container] = None
    
    def build(self, page: ft.Page) -> ft.Container:
        """Build the component with page reference."""
        self.container = create_profile_panel(page, self.on_bio_change, self.initial_bio)
        return self.container
    
    def __getattr__(self, name):
        if self.container:
            return getattr(self.container, name)
        raise AttributeError(f"ProfilePanel has no attribute '{name}'")
</file>

<file path="src/presentation/gui/components/resume_upload.py">
"""
Resume Upload Component - FE-03

PDF/DOCX resume upload with text extraction preview.
"""

import flet as ft
from pathlib import Path
from typing import Callable, Optional

from src.domain.entities import Candidate
from src.infrastructure.parsers import ResumeParser
from ..styles import Theme


def create_resume_upload(
    page: ft.Page,
    on_resume_loaded: Optional[Callable[[Candidate], None]] = None,
) -> ft.Container:
    """
    Create resume upload component.
    
    Features:
    - File picker for PDF/DOCX
    - Text extraction preview
    - Skill detection display
    """
    _candidate: Optional[Candidate] = None
    
    file_name = ft.Text("Nenhum arquivo selecionado")
    
    preview_text = ft.TextField(
        label="Texto extraÃ­do",
        multiline=True,
        min_lines=5,
        max_lines=10,
        read_only=True,
        border_radius=Theme.RADIUS_MD,
    )
    
    skills_row = ft.Row(controls=[], wrap=True, spacing=Theme.SPACING_XS)
    
    def _on_file_picked(e) -> None:
        """Handle file selection."""
        nonlocal _candidate
        
        if not e.files:
            return
        
        file = e.files[0]
        file_name.value = file.name
        
        try:
            path = Path(file.path)
            text = ResumeParser.extract_text(path)
            contact = ResumeParser.extract_contact_info(text)
            skills = ResumeParser.extract_skills(text)
            
            # Update preview
            preview_text.value = text[:2000] + ("..." if len(text) > 2000 else "")
            
            # Update skills chips
            skills_row.controls = [
                ft.Chip(label=ft.Text(skill), selected=True)
                for skill in skills[:10]
            ]
            
            # Create candidate
            _candidate = Candidate(
                name=contact.get("name") or "",
                email=contact.get("email") or "",
                phone=contact.get("phone") or "",
                resume_text=text,
                resume_path=path,
                skills=skills,
            )
            
            if on_resume_loaded:
                on_resume_loaded(_candidate)
            
        except Exception as ex:
            preview_text.value = f"Erro ao processar arquivo: {ex}"
        
        file_name.update()
        preview_text.update()
        skills_row.update()
    
    file_picker = ft.FilePicker()
    file_picker.on_result = _on_file_picked
    page.overlay.append(file_picker)
    
    return ft.Container(
        content=ft.Column([
            ft.Text("ðŸ“„ Upload de CurrÃ­culo", size=18, weight="bold"),
            ft.Row([
                ft.ElevatedButton(
                    "Selecionar Arquivo",
                    icon="upload_file",
                    on_click=lambda _: file_picker.pick_files(
                        allowed_extensions=["pdf", "docx", "doc"],
                        dialog_title="Selecione seu currÃ­culo",
                    ),
                ),
                file_name,
            ], spacing=Theme.SPACING_MD),
            preview_text,
            ft.Text("Habilidades detectadas:", size=14),
            skills_row,
        ], spacing=Theme.SPACING_MD),
        bgcolor=Theme.DARK_CARD,
        border_radius=Theme.RADIUS_LG,
        padding=Theme.SPACING_MD,
    )


class ResumeUpload:
    """Wrapper class for resume upload."""
    
    def __init__(
        self,
        on_resume_loaded: Optional[Callable[[Candidate], None]] = None,
    ):
        self.on_resume_loaded = on_resume_loaded
        self.container: Optional[ft.Container] = None
    
    def build(self, page: ft.Page) -> ft.Container:
        """Build the component with page reference."""
        self.container = create_resume_upload(page, self.on_resume_loaded)
        return self.container
    
    def __getattr__(self, name):
        if self.container:
            return getattr(self.container, name)
        raise AttributeError(f"ResumeUpload has no attribute '{name}'")
</file>

<file path="src/presentation/gui/components/theme_toggle.py">
"""
Theme Toggle Component - FE-07

Dark/Light mode toggle switch.
"""

import flet as ft
from typing import Callable, Optional

from ..styles import Theme


def create_theme_toggle(
    on_theme_change: Optional[Callable[[bool], None]] = None,
    initial_dark: bool = True,
) -> ft.Row:
    """
    Create theme toggle switch.
    
    Features:
    - Toggle between dark and light modes
    """
    _is_dark = initial_dark
    
    def _on_toggle(e) -> None:
        nonlocal _is_dark
        _is_dark = e.control.value
        
        if on_theme_change:
            on_theme_change(_is_dark)
    
    return ft.Row([
        ft.Icon("wb_sunny", color=Theme.WARNING),
        ft.Switch(
            value=_is_dark,
            on_change=_on_toggle,
        ),
        ft.Icon("nightlight_round", color=Theme.PRIMARY),
    ])


class ThemeToggle:
    """Wrapper class for theme toggle."""
    
    def __init__(
        self,
        on_theme_change: Optional[Callable[[bool], None]] = None,
        initial_dark: bool = True,
    ):
        self.row = create_theme_toggle(on_theme_change, initial_dark)
        self._is_dark = initial_dark
    
    @property
    def is_dark(self) -> bool:
        return self._is_dark
    
    def __getattr__(self, name):
        return getattr(self.row, name)
</file>

<file path="src/presentation/gui/styles/__init__.py">
# Styles Package
from .theme import Theme

__all__ = ["Theme"]
</file>

<file path="src/presentation/gui/styles/theme.py">
"""
Theme Configuration for BOTLink GUI.

Implements FE-07: Dark and Light mode support.
"""

import flet as ft


class Theme:
    """Theme configuration for the application."""
    
    # Color palette
    PRIMARY = "#6366f1"  # Indigo
    PRIMARY_VARIANT = "#4f46e5"
    SECONDARY = "#10b981"  # Emerald
    SECONDARY_VARIANT = "#059669"
    
    ERROR = "#ef4444"  # Red
    WARNING = "#f59e0b"  # Amber
    SUCCESS = "#22c55e"  # Green
    INFO = "#3b82f6"  # Blue
    
    # Dark theme
    DARK_BG = "#0f172a"  # Slate 900
    DARK_SURFACE = "#1e293b"  # Slate 800
    DARK_CARD = "#334155"  # Slate 700
    DARK_TEXT = "#f8fafc"  # Slate 50
    DARK_TEXT_SECONDARY = "#94a3b8"  # Slate 400
    
    # Light theme
    LIGHT_BG = "#f8fafc"  # Slate 50
    LIGHT_SURFACE = "#ffffff"
    LIGHT_CARD = "#f1f5f9"  # Slate 100
    LIGHT_TEXT = "#0f172a"  # Slate 900
    LIGHT_TEXT_SECONDARY = "#64748b"  # Slate 500
    
    # Spacing
    SPACING_XS = 4
    SPACING_SM = 8
    SPACING_MD = 16
    SPACING_LG = 24
    SPACING_XL = 32
    
    # Border radius
    RADIUS_SM = 4
    RADIUS_MD = 8
    RADIUS_LG = 12
    RADIUS_XL = 16
    
    @classmethod
    def get_flet_theme(cls, dark: bool = True) -> ft.Theme:
        """Get Flet theme configuration."""
        return ft.Theme(
            color_scheme_seed=cls.PRIMARY,
            color_scheme=ft.ColorScheme(
                primary=cls.PRIMARY,
                secondary=cls.SECONDARY,
                error=cls.ERROR,
            ),
        )
    
    @classmethod
    def card_style(cls, dark: bool = True) -> dict:
        """Get card styling."""
        return {
            "bgcolor": cls.DARK_CARD if dark else cls.LIGHT_CARD,
            "border_radius": cls.RADIUS_LG,
            "padding": cls.SPACING_MD,
        }
    
    @classmethod
    def button_style(cls, variant: str = "primary") -> ft.ButtonStyle:
        """Get button styling."""
        colors = {
            "primary": cls.PRIMARY,
            "secondary": cls.SECONDARY,
            "error": cls.ERROR,
            "success": cls.SUCCESS,
        }
        return ft.ButtonStyle(
            color="white",
            bgcolor=colors.get(variant, cls.PRIMARY),
            shape=ft.RoundedRectangleBorder(radius=cls.RADIUS_MD),
            padding=ft.padding.symmetric(horizontal=cls.SPACING_LG, vertical=cls.SPACING_MD),
        )
</file>

<file path="src/presentation/gui/__init__.py">
# GUI Package
from .app import BotLinkApp

__all__ = ["BotLinkApp"]
</file>

<file path="src/presentation/gui/app.py">
"""
BOTLink Main Application - Flet GUI

Main application window orchestrating all components.
"""

import asyncio
import flet as ft
from typing import Optional

from src.config.settings import get_settings
from src.domain.entities import Candidate
from src.domain.value_objects import Credentials, JobFilter
from src.application.use_cases import BotOrchestrator, BotState

from .components import (
    JobPanel,
    CredentialsPanel,
    ResumeUpload,
    ProfilePanel,
    ControlsPanel,
    LogDashboard,
    ThemeToggle,
)
from .styles import Theme


class BotLinkApp:
    """
    Main BOTLink application.
    
    Orchestrates all GUI components and connects to the bot orchestrator.
    """
    
    def __init__(self):
        self.settings = get_settings()
        self.orchestrator: Optional[BotOrchestrator] = None
        
        # Components
        self.job_panel: Optional[JobPanel] = None
        self.credentials_panel: Optional[CredentialsPanel] = None
        self.resume_upload: Optional[ResumeUpload] = None
        self.profile_panel: Optional[ProfilePanel] = None
        self.controls_panel: Optional[ControlsPanel] = None
        self.log_dashboard: Optional[LogDashboard] = None
        self.theme_toggle: Optional[ThemeToggle] = None
        
        # State
        self._candidate: Optional[Candidate] = None
        self._job_filter: Optional[JobFilter] = None

    async def main(self, page: ft.Page) -> None:
        """Main entry point for Flet app."""
        self.page = page
        
        # Configure page
        page.title = "BOTLink - AutomaÃ§Ã£o Cognitiva de Candidaturas"
        page.theme_mode = "dark"
        page.theme = Theme.get_flet_theme(dark=True)
        page.padding = Theme.SPACING_LG
        
        # Initialize orchestrator
        self.orchestrator = BotOrchestrator(self.settings)
        self.orchestrator.add_event_listener(self._on_bot_event)
        
        # Build UI
        await self._build_ui()

    async def _build_ui(self) -> None:
        """Build the main UI layout."""
        # Theme toggle
        self.theme_toggle = ThemeToggle(on_theme_change=self._on_theme_change)
        
        # Header
        header = ft.Container(
            content=ft.Row([
                ft.Row([
                    ft.Icon("smart_toy", size=32, color=Theme.PRIMARY),
                    ft.Text("BOTLink", size=28, weight="bold"),
                ]),
                self.theme_toggle.row,
            ], alignment="spaceBetween"),
            padding=Theme.SPACING_MD,
        )
        
        # Initialize components
        self.job_panel = JobPanel(on_filter_change=self._on_filter_change)
        self.credentials_panel = CredentialsPanel(
            on_credentials_save=self._on_credentials_save,
            on_verify_session=self._on_verify_session,
        )
        self.resume_upload = ResumeUpload(on_resume_loaded=self._on_resume_loaded)
        self.profile_panel = ProfilePanel(on_bio_change=self._on_bio_change)
        self.controls_panel = ControlsPanel(
            on_start=self._on_start,
            on_stop=self._on_stop,
        )
        self.log_dashboard = LogDashboard()
        
        # Build components that need page reference
        resume_container = self.resume_upload.build(self.page)
        profile_container = self.profile_panel.build(self.page)
        
        # Layout - Two columns
        left_column = ft.Column([
            self.job_panel.container,
            self.credentials_panel.container,
            self.controls_panel.container,
        ], spacing=Theme.SPACING_MD, expand=True, scroll="auto")
        
        right_column = ft.Column([
            resume_container,
            profile_container,
            self.log_dashboard.container,
        ], spacing=Theme.SPACING_MD, expand=True, scroll="auto")
        
        main_content = ft.Row([
            ft.Container(content=left_column, expand=1),
            ft.Container(content=right_column, expand=1),
        ], spacing=Theme.SPACING_LG, expand=True)

        # Add to page
        self.page.add(
            header,
            ft.Divider(),
            main_content,
        )
        
        # Log welcome message
        self.log_dashboard.add_log("ðŸ‘‹ BOTLink iniciado. Configure suas preferÃªncias e clique em Iniciar.", "info")

    def _on_theme_change(self, is_dark: bool) -> None:
        """Handle theme change."""
        self.page.theme_mode = "dark" if is_dark else "light"
        self.page.update()

    async def _on_filter_change(self, job_filter: JobFilter) -> None:
        """Handle job filter change."""
        self._job_filter = job_filter
        if self.log_dashboard:
            keywords = ", ".join(job_filter.keywords) if job_filter.keywords else "Nenhum"
            self.log_dashboard.add_log(f"ðŸŽ¯ Filtros atualizados: {keywords}")

    async def _on_credentials_save(self, credentials: Credentials) -> None:
        """Handle credentials save."""
        if self.orchestrator:
            await self.orchestrator.save_credentials(credentials)
        if self.log_dashboard:
            self.log_dashboard.add_log("ðŸ” Credenciais salvas", "success")

    async def _on_verify_session(self) -> None:
        """Handle session verification request."""
        if self.log_dashboard:
            self.log_dashboard.add_log("ðŸ” Verificando sessÃ£o...")
            
        if self.orchestrator:
            try:
                # Attempt verification
                is_valid = await self.orchestrator.verify_session()
                
                # Update UI
                if self.credentials_panel:
                    self.credentials_panel.set_status(is_valid)
                
                if self.log_dashboard:
                    if is_valid:
                        self.log_dashboard.add_log("âœ… SessÃ£o verificada com sucesso!", "success")
                    else:
                        self.log_dashboard.add_log("âŒ Falha na verificaÃ§Ã£o da sessÃ£o", "error")
            except Exception as e:
                if self.log_dashboard:
                    self.log_dashboard.add_log(f"Erro na verificaÃ§Ã£o: {e}", "error")

    def _on_resume_loaded(self, candidate: Candidate) -> None:
        """Handle resume loaded."""
        self._candidate = candidate
        if self.log_dashboard:
            self.log_dashboard.add_log(f"ðŸ“„ CurrÃ­culo carregado: {candidate.name}", "success")

    def _on_bio_change(self, bio: str) -> None:
        """Handle bio text change."""
        if self._candidate:
            self._candidate.bio = bio

    async def _on_start(self) -> None:
        """Handle start button click."""
        if not self._candidate:
            if self.log_dashboard:
                self.log_dashboard.add_log("âš ï¸ Carregue um currÃ­culo primeiro", "warning")
            return
        
        if not self._job_filter or not self._job_filter.is_configured:
            if self.log_dashboard:
                self.log_dashboard.add_log("âš ï¸ Configure os filtros de vagas", "warning")
            return
        
        if self.orchestrator:
            asyncio.create_task(self.orchestrator.start(
                job_filter=self._job_filter,
                candidate=self._candidate,
            ))

    async def _on_stop(self) -> None:
        """Handle stop button click."""
        if self.orchestrator:
            await self.orchestrator.stop()

    def _on_bot_event(self, event: str, data: dict) -> None:
        """Handle bot events."""
        if event == "log":
            if self.log_dashboard:
                self.log_dashboard.add_log(data.get("message", ""))
        elif event == "error":
            if self.log_dashboard:
                self.log_dashboard.add_log(data.get("message", "Erro"), "error")
        elif event == "state_change":
            state = data.get("state", "")
            is_running = state == BotState.RUNNING.value
            if self.controls_panel:
                self.controls_panel.set_running(is_running)

def run_app() -> None:
    """Run the BOTLink application."""
    app = BotLinkApp()
    ft.app(target=app.main, view=ft.AppView.WEB_BROWSER, port=8553)
</file>

<file path="src/presentation/__init__.py">
# Presentation Package
</file>

<file path="src/__init__.py">
# BOTLink Source Package
</file>

<file path="src/main.py">
"""
BOTLink - Cognitive Automation for Job Applications

Entry point for the application.
"""

import logging
import sys

from src.presentation.gui import BotLinkApp
import flet as ft


def setup_logging() -> None:
    """Configure logging for the application."""
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
        handlers=[
            logging.StreamHandler(sys.stdout),
        ]
    )


def main() -> None:
    """Main entry point."""
    setup_logging()
    
    app = BotLinkApp()
    # Run in web browser mode for localhost testing
    ft.app(target=app.main, view=ft.AppView.WEB_BROWSER, port=8553)


if __name__ == "__main__":
    main()
</file>

<file path="tests/unit/__init__.py">
# Unit Tests Package
</file>

<file path="tests/unit/test_entities.py">
"""
Unit tests for domain entities.
"""

import pytest
from datetime import datetime

from src.domain.entities import Job, Candidate, Application, ApplicationStatus
from src.domain.value_objects import Credentials, JobFilter


class TestJob:
    """Tests for Job entity."""
    
    def test_create_job(self):
        """Should create job with required fields."""
        job = Job(
            job_id="12345",
            title="Backend Developer",
            company="Tech Corp",
            location="SÃ£o Paulo, SP",
        )
        
        assert job.job_id == "12345"
        assert job.title == "Backend Developer"
        assert job.company == "Tech Corp"
    
    def test_job_requires_job_id(self):
        """Should raise error without job_id."""
        with pytest.raises(ValueError, match="job_id is required"):
            Job(job_id="", title="Test", company="Test", location="Test")
    
    def test_display_name(self):
        """Should return formatted display name."""
        job = Job(
            job_id="123",
            title="Dev",
            company="Corp",
            location="SP",
        )
        assert job.display_name == "Dev @ Corp"
    
    def test_matches_filter_remote_only(self):
        """Should filter remote jobs."""
        remote_job = Job(
            job_id="1",
            title="Dev",
            company="Corp",
            location="Remote",
            is_remote=True,
        )
        office_job = Job(
            job_id="2",
            title="Dev",
            company="Corp",
            location="SÃ£o Paulo",
            is_remote=False,
        )
        
        assert remote_job.matches_filter(remote_only=True) is True
        assert office_job.matches_filter(remote_only=True) is False


class TestCandidate:
    """Tests for Candidate entity."""
    
    def test_is_complete(self):
        """Should check completeness."""
        incomplete = Candidate()
        complete = Candidate(name="John", resume_text="My resume...")
        
        assert incomplete.is_complete is False
        assert complete.is_complete is True
    
    def test_context_for_ai(self):
        """Should generate AI context string."""
        candidate = Candidate(
            name="John Doe",
            email="john@example.com",
            skills=["Python", "SQL"],
            resume_text="Experience in backend development...",
        )
        
        context = candidate.context_for_ai
        
        assert "John Doe" in context
        assert "john@example.com" in context
        assert "Python, SQL" in context
        assert "Experience in backend" in context


class TestApplication:
    """Tests for Application entity."""
    
    def test_create_application(self):
        """Should create application with required fields."""
        app = Application(
            job_id="12345",
            empresa="Tech Corp",
            titulo="Developer",
            localizacao="SP",
            status=ApplicationStatus.SUCESSO,
        )
        
        assert app.job_id == "12345"
        assert app.status == ApplicationStatus.SUCESSO
    
    def test_status_from_string(self):
        """Should convert string status to enum."""
        app = Application(
            job_id="123",
            empresa="Corp",
            titulo="Dev",
            localizacao="SP",
            status="SUCESSO",  # type: ignore
        )
        
        assert app.status == ApplicationStatus.SUCESSO
    
    def test_display_status(self):
        """Should return emoji status."""
        app = Application(
            job_id="123",
            empresa="Corp",
            titulo="Dev",
            localizacao="SP",
            status=ApplicationStatus.SUCESSO,
        )
        
        assert "âœ…" in app.display_status
    
    def test_to_dict(self):
        """Should convert to dictionary."""
        app = Application(
            job_id="123",
            empresa="Corp",
            titulo="Dev",
            localizacao="SP",
            status=ApplicationStatus.SUCESSO,
        )
        
        data = app.to_dict()
        
        assert data["job_id"] == "123"
        assert data["status"] == "SUCESSO"


class TestCredentials:
    """Tests for Credentials value object."""
    
    def test_credentials_immutable(self):
        """Credentials should be immutable."""
        creds = Credentials(username="user", password="pass")
        
        with pytest.raises(Exception):
            creds.username = "other"  # type: ignore
    
    def test_masked_password(self):
        """Should mask password for display."""
        creds = Credentials(username="user", password="secretpassword")
        masked = creds.masked()
        
        assert masked.password == "********"
        assert len(masked.password) == 8


class TestJobFilter:
    """Tests for JobFilter value object."""
    
    def test_filter_immutable(self):
        """JobFilter should be immutable."""
        filt = JobFilter(keywords=("Python", "Django"))
        
        with pytest.raises(Exception):
            filt.keywords = ("other",)  # type: ignore
    
    def test_search_query(self):
        """Should generate search query."""
        filt = JobFilter(keywords=("Python", "Django", "Backend"))
        assert filt.search_query == "Python OR Django OR Backend"
    
    def test_is_configured(self):
        """Should check if configured."""
        empty = JobFilter()
        configured = JobFilter(keywords=("Dev",))
        
        assert empty.is_configured is False
        assert configured.is_configured is True
</file>

<file path="tests/unit/test_opsec_service.py">
"""
Unit tests for OpSecService.

Tests for RNF-01 to RNF-05 compliance.
"""

import pytest
from datetime import date, datetime, timedelta
from unittest.mock import Mock, patch

from src.config.settings import Settings
from src.domain.services.opsec_service import OpSecService, OpSecState


@pytest.fixture
def settings() -> Settings:
    """Create test settings."""
    return Settings(
        daily_limit=50,
        warmup_enabled=True,
        max_consecutive_errors=3,
        pause_after_applications=10,
        pause_duration_min=15,
        pause_duration_max=30,
        min_action_delay=1.5,
        max_action_delay=4.0,
        min_application_delay=120.0,
        max_application_delay=600.0,
    )


@pytest.fixture
def opsec(settings: Settings) -> OpSecService:
    """Create OpSec service instance."""
    return OpSecService(settings)


class TestDailyLimit:
    """Tests for RNF-01: Daily limit."""
    
    def test_can_apply_when_under_limit(self, opsec: OpSecService):
        """Should allow applications when under daily limit."""
        opsec.state.applications_today = 11  # Use non-multiple of 10 to avoid pause trigger
        can_apply, reason = opsec.can_apply()
        assert can_apply is True
        assert reason == ""
    
    def test_cannot_apply_when_at_limit(self, opsec: OpSecService):
        """Should block applications when at daily limit."""
        opsec.state.applications_today = 50
        can_apply, reason = opsec.can_apply()
        assert can_apply is False
        assert "Limite diÃ¡rio" in reason
    
    def test_resets_counter_on_new_day(self, opsec: OpSecService):
        """Should reset counter when day changes."""
        opsec.state.applications_today = 50
        opsec.state.today = date.today() - timedelta(days=1)
        
        can_apply, _ = opsec.can_apply()
        
        assert opsec.state.applications_today == 0
        assert opsec.state.today == date.today()


class TestWarmup:
    """Tests for RNF-02: Account warm-up."""
    
    def test_warmup_day_1_limit(self, opsec: OpSecService):
        """Day 1 should limit to 10 applications."""
        opsec.state.account_age_days = 1
        limit = opsec.get_daily_limit()
        assert limit == 10
    
    def test_warmup_day_2_limit(self, opsec: OpSecService):
        """Day 2 should limit to 20 applications."""
        opsec.state.account_age_days = 2
        limit = opsec.get_daily_limit()
        assert limit == 20
    
    def test_warmup_day_3_limit(self, opsec: OpSecService):
        """Day 3 should limit to 30 applications."""
        opsec.state.account_age_days = 3
        limit = opsec.get_daily_limit()
        assert limit == 30
    
    def test_warmup_day_4_plus(self, opsec: OpSecService):
        """Day 4+ should use default limit."""
        opsec.state.account_age_days = 4
        limit = opsec.get_daily_limit()
        assert limit == 40  # DEFAULT_LIMIT


class TestRecordApplications:
    """Tests for application recording."""
    
    def test_record_success_increments_counter(self, opsec: OpSecService):
        """Recording success should increment counter."""
        initial = opsec.state.applications_today
        opsec.record_success()
        assert opsec.state.applications_today == initial + 1
    
    def test_record_success_resets_errors(self, opsec: OpSecService):
        """Recording success should reset consecutive errors."""
        opsec.state.consecutive_errors = 2
        opsec.record_success()
        assert opsec.state.consecutive_errors == 0
    
    def test_record_failure_increments_errors(self, opsec: OpSecService):
        """Recording failure should increment consecutive errors."""
        opsec.record_failure()
        assert opsec.state.consecutive_errors == 1


class TestConsecutiveErrors:
    """Tests for RNF-05: Abort on consecutive errors."""
    
    def test_blocks_after_max_errors(self, opsec: OpSecService):
        """Should block after max consecutive errors."""
        opsec.state.consecutive_errors = 3
        can_apply, reason = opsec.can_apply()
        assert can_apply is False
        assert "erros consecutivos" in reason


class TestStatus:
    """Tests for status reporting."""
    
    def test_get_status_returns_correct_values(self, opsec: OpSecService):
        """Status should return current state values."""
        opsec.state.applications_today = 25
        opsec.state.consecutive_errors = 1
        opsec.state.account_age_days = 2
        
        status = opsec.get_status()
        
        assert status["applications_today"] == 25
        assert status["daily_limit"] == 20  # warmup day 2
        assert status["remaining"] == -5  # over limit due to warmup
        assert status["consecutive_errors"] == 1
        assert status["warmup_active"] is True
</file>

<file path="tests/__init__.py">
# Tests Package
</file>

<file path=".env.example">
# BOTLink Environment Configuration
# Copy this file to .env and fill in your values

# OpenAI API Configuration
OPENAI_API_KEY=sk-your-api-key-here

# Application Settings
BOTLINK_ENV=development
BOTLINK_LOG_LEVEL=INFO
BOTLINK_DATA_DIR=./data

# OpSec Limits (do not change unless you understand the risks)
BOTLINK_DAILY_LIMIT=50
BOTLINK_WARMUP_ENABLED=true

# Browser Settings
BOTLINK_HEADLESS=false
BOTLINK_USE_CAMOUFOX=true
</file>

<file path=".gitignore">
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual Environment
venv/
.venv/
ENV/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# Testing
.pytest_cache/
.coverage
htmlcov/
.tox/
.nox/

# MyPy
.mypy_cache/
.dmypy.json
dmypy.json

# Environment
.env
.env.local
.env.*.local

# BOTLink Data (CRITICAL - contains sensitive data)
data/
*.db
auth.json
cookies.json

# Logs
*.log
logs/

# OS
.DS_Store
Thumbs.db
</file>

<file path="GLOBAL_RULES.md">
---
title: "Global Rules â€“ Regras Gerais para Qualquer Projeto"
version: "12.0"
date: "2025-01-15"
author: "Alest EVC Team"
status: "approved"
last_updated: "2025-01-15"
description: "Documento genÃ©rico e aplicÃ¡vel a qualquer projeto com padrÃµes, prÃ¡ticas e diretrizes de desenvolvimento"
tags: ["development", "standards", "best-practices", "architecture", "quality"]
category: "documentation"
type: "global-rules"
language: "pt-BR"
target_audience: ["developers", "architects", "tech-leads", "qa-engineers"]
complexity: "comprehensive"
maintenance_frequency: "quarterly"
related_docs: ["domains-rules/", "README.md"]
---

# Global Rules â€“ Regras Gerais para Qualquer Projeto (versÃ£o detalhada)

### SumÃ¡rio

#### ðŸ—ï¸ **FUNDAMENTOS** (1-12)
- [1) PrincÃ­pios Productionâ€‘First (obrigatÃ³rios)](#1-princÃ­pios-productionfirst-obrigatÃ³rios)
- [2) Qualidade de CÃ³digo e PadrÃµes](#2-qualidade-de-cÃ³digo-e-padrÃµes)
- [3) DocumentaÃ§Ã£o (padrÃ£o)](#3-documentaÃ§Ã£o-padrÃ£o)
- [4) Arquitetura e OrganizaÃ§Ã£o](#4-arquitetura-e-organizaÃ§Ã£o)
- [5) EstratÃ©gias Comprovadas de ResoluÃ§Ã£o de Problemas](#5-estratÃ©gias-comprovadas-de-resoluÃ§Ã£o-de-problemas)
- [6) Testes Unificados (Unit + Integration + E2E + NFR)](#6-testes-unificados-unit--integration--e2e--nfr)
- [7) CI/CD e Deploy](#7-cicd-e-deploy)
- [8) Observabilidade Completa (Logs, MÃ©tricas, Traces, Dashboards)](#8-observabilidade-completa-logs-mÃ©tricas-traces-dashboards)
- [9) SeguranÃ§a (OWASP Top 10 + prÃ¡ticas)](#9-seguranÃ§a-owasp-top-10--prÃ¡ticas)
- [10) Frontend â€“ PadrÃµes Gerais](#10-frontend--padrÃµes-gerais)
- [11) ModernizaÃ§Ã£o de Legacy](#11-modernizaÃ§Ã£o-de-legacy)
  - [11.1 Processo de AnÃ¡lise Comparativa](#111-processo-de-anÃ¡lise-comparativa)
  - [11.2 Checklist ExecutÃ¡vel de InventÃ¡rio](#112-checklist-executÃ¡vel-de-inventÃ¡rio)
  - [11.3 Regras de Completude](#113-regras-de-completude)
  - [11.4 Processo Integrado e Gates de Qualidade](#114-processo-integrado-e-gates-de-qualidade)
  - [11.5 AnÃ¡lise de Completude ObrigatÃ³ria em MigraÃ§Ãµes](#115-anÃ¡lise-de-completude-obrigatÃ³ria-em-migraÃ§Ãµes)
  - [11.14 ValidaÃ§Ã£o de MigraÃ§Ã£o Frontend (CRÃTICO)](#1114-validaÃ§Ã£o-de-migraÃ§Ã£o-frontend-crÃ­tico)
- [12) PadrÃµes para ResoluÃ§Ã£o em Massa (alto ROI)](#12-padrÃµes-para-resoluÃ§Ã£o-em-massa-alto-roi)

#### ðŸ§ª **DESENVOLVIMENTO & QUALIDADE** (13-32)
- [13) PadrÃµes .NET Enterprise (Backend Moderno)](#13-padrÃµes-net-enterprise-backend-moderno)
- [14) SLO/SLI/SLA e OrÃ§amento de Erros](#14-sloslisl-e-orÃ§amento-de-erros)
- [15) GestÃ£o de Incidentes e Postmortem](#15-gestÃ£o-de-incidentes-e-postmortem)
- [16) Change Management e Feature Flags](#16-change-management-e-feature-flags)
- [17) Dados, Privacidade e LGPD/GDPR](#17-dados-privacidade-e-lgpdgdpr)
- [18) Design de APIs (REST/GraphQL)](#18-design-de-apis-restgraphql)
- [19) Performance e Caching](#19-performance-e-caching)
- [20) SeguranÃ§a AvanÃ§ada](#20-seguranÃ§a-avanÃ§ada)
- [21) Frontend â€“ SeÃ§Ãµes EspecÃ­ficas](#21-frontend--seÃ§Ãµes-especÃ­ficas)
- [22) Kubernetes (produÃ§Ã£o)](#22-kubernetes-produÃ§Ã£o)
- [23) CI/CD AvanÃ§ado](#23-cicd-avanÃ§ado)
- [24) GovernanÃ§a de RepositÃ³rio](#24-governanÃ§a-de-repositÃ³rio)
- [25) ROI, Riscos e Roadmap TÃ©cnico](#25-roi-riscos-e-roadmap-tÃ©cnico)
- [26) Onboarding e Conhecimento](#26-onboarding-e-conhecimento)
- [27) DÃ©bito TÃ©cnico e Triagem](#27-dÃ©bito-tÃ©cnico-e-triagem)
- [28) Multiâ€‘Ambientes e ConfiguraÃ§Ã£o](#28-multi-ambientes-e-configuraÃ§Ã£o)
- [29) Requisitos NÃ£o Funcionais (NFR) e Testes](#29-requisitos-nÃ£o-funcionais-nfr-e-testes)
- [30) Banco de Dados e MigraÃ§Ãµes](#30-banco-de-dados-e-migraÃ§Ãµes)
- [31) InternacionalizaÃ§Ã£o (i18n) e LocalizaÃ§Ã£o (l10n)](#31-internacionalizaÃ§Ã£o-i18n-e-localizaÃ§Ã£o-l10n)
- [32) CORS e Headers de SeguranÃ§a](#32-cors-e-headers-de-seguranÃ§a)

#### ðŸŽ¨ **FRONTEND & UX** (33-47)
- [33) ADR â€“ Template](#33-adr--template)
- [34) PreservaÃ§Ã£o de Identidade Visual (PIV) â€“ Guia Definitivo](#34-preservaÃ§Ã£o-de-identidade-visual-piv--guia-definitivo)
- [35) ModernizaÃ§Ã£o de Legado â€“ EstratÃ©gia Completa](#35-modernizaÃ§Ã£o-de-legado--estratÃ©gia-completa)
- [36) IntegraÃ§Ãµes Externas â€“ PadrÃµes de ResiliÃªncia](#36-integraÃ§Ãµes-externas--padrÃµes-de-resiliÃªncia)
- [37) Storybook e CatÃ¡logo de Componentes (opcional, recomendado)](#37-storybook-e-catÃ¡logo-de-componentes-opcional-recomendado)
- [38) Fluxo de Handoff com Design (Figma)](#38-fluxo-de-handoff-com-design-figma)
- [39) Visual Regression Pipeline](#39-visual-regression-pipeline)
- [40) Performance Visual e UX](#40-performance-visual-e-ux)
- [41) Responsividade Fiel ao Legado](#41-responsividade-fiel-ao-legado)
- [42) CatÃ¡logo de Ãcones e IlustraÃ§Ãµes](#42-catÃ¡logo-de-Ã­cones-e-ilustraÃ§Ãµes)
- [43) GestÃ£o de Assets](#43-gestÃ£o-de-assets)
- [44) Template de AprovaÃ§Ã£o de MudanÃ§as Visuais no PR](#44-template-de-aprovaÃ§Ã£o-de-mudanÃ§as-visuais-no-pr)
- [45) MÃ©tricas de PreservaÃ§Ã£o Visual](#45-mÃ©tricas-de-preservaÃ§Ã£o-visual)
- [46) Guia de Nomenclatura de Classes (BEM/UtilitÃ¡rios)](#46-guia-de-nomenclatura-de-classes-bemutilitÃ¡rios)
- [47) RevisÃµes PeriÃ³dicas de Marca](#47-revisÃµes-periÃ³dicas-de-marca)

#### ðŸ”’ **ARQUITETURA & PADRÃ•ES** (48-58)
- [48) Estrutura de Pastas â€“ Boas PrÃ¡ticas](#48-estrutura-de-pastas--boas-prÃ¡ticas)
- [49) SOLID â€“ AplicaÃ§Ã£o PrÃ¡tica](#49-solid--aplicaÃ§Ã£o-prÃ¡tica)
- [50) DDD â€“ Diretrizes Objetivas](#50-ddd--diretrizes-objetivas)
- [51) CQRS â€“ PadrÃ£o PragmÃ¡tico](#51-cqrs--padrÃ£o-pragmÃ¡tico)
- [52) Clean Architecture â€“ Contratos e Fluxo](#52-clean-architecture--contratos-e-fluxo)
- [53) PadrÃµes de Projeto Relevantes](#53-padrÃµes-de-projeto-relevantes)
- [54) PolÃ­tica de RepositÃ³rios (Sem DuplicaÃ§Ãµes)](#54-polÃ­tica-de-repositÃ³rios-sem-duplicaÃ§Ãµes)
- [55) LiÃ§Ãµes Aprendidas â€“ CatÃ¡logo Resumido (com crossâ€‘refs)](#55-liÃ§Ãµes-aprendidas--catÃ¡logo-resumido-com-crossrefs)
- [56) API Governance e Versionamento](#56-api-governance-e-versionamento)
- [57) ConvenÃ§Ãµes de Commits, Branches e Releases](#57-convenÃ§Ãµes-de-commits-branches-e-releases)
- [58) Dados de Teste, Mascaramento e SÃ­ntese](#58-dados-de-teste-mascaramento-e-sÃ­ntese)

#### ðŸš€ **PRODUÃ‡ÃƒO & DEVOPS** (59-70)
- [59) Taxonomia de Erros e CorrelaÃ§Ã£o](#59-taxonomia-de-erros-e-correlaÃ§Ã£o)
- [60) FinOps/Cloud Cost Management](#60-finopscloud-cost-management)
- [61) Backup/DR â€“ PolÃ­tica e Testes](#61-backupdr--polÃ­tica-e-testes)
- [62) Regras de InteraÃ§Ã£o (Chat/Agente)](#62-regras-de-interaÃ§Ã£o-chatagente)
- [63) Data Governance e Lineage](#63-data-governance-e-lineage)
- [64) Telemetria de Produto](#64-telemetria-de-produto)
- [65) Dev Environment PadrÃ£o](#65-dev-environment-padrÃ£o)
- [66) Monorepo vs Polyrepo](#66-monorepo-vs-polyrepo)
- [67) Multiâ€‘RegiÃ£o](#67-multi-regiÃ£o)
- [68) Mobile (se aplicÃ¡vel)](#68-mobile-se-aplicÃ¡vel)
- [69) Acessibilidade em Canais Digitais - PadrÃµes WCAG e ImplementaÃ§Ã£o](#69-acessibilidade-em-canais-digitais---padrÃµes-wcag-e-implementaÃ§Ã£o)
- [70) (SeÃ§Ã£o vazia - reservada)](#70-seÃ§Ã£o-vazia---reservada)

#### ðŸ“‹ **DOMÃNIOS ESPECÃFICOS** (71-80)
- [71) AI/ML (se aplicÃ¡vel)](#71-aiml-se-aplicÃ¡vel)
- [72) PolÃ­tica de LicenÃ§as](#72-polÃ­tica-de-licenÃ§as)
- [73) Mermaid â€“ PadrÃµes de Uso](#73-mermaid--padrÃµes-de-uso)
- [74) Tailwind CSS + SASS â€“ Abordagem HÃ­brida](#74-tailwind-css--sass--abordagem-hÃ­brida)
- [75) AnÃ¡lise Automatizada de PDFs com MCPs](#75-anÃ¡lise-automatizada-de-pdfs-com-mcps)
- [76) VersÃµes LTS - PolÃ­tica ObrigatÃ³ria](#76-versÃµes-lts---polÃ­tica-obrigatÃ³ria)
- [77) Serverless Framework - PadrÃµes AWS Lambda](#77-serverless-framework---padrÃµes-aws-lambda)
- [78) Micro-frontends - PadrÃµes de FederaÃ§Ã£o e ComunicaÃ§Ã£o](#78-micro-frontends---padrÃµes-de-federaÃ§Ã£o-e-comunicaÃ§Ã£o)
- [79) Edge Computing - EstratÃ©gias de DistribuiÃ§Ã£o e Cache na Borda](#79-edge-computing---estratÃ©gias-de-distribuiÃ§Ã£o-e-cache-na-borda)
- [80) Multi-Cloud - PadrÃµes de Portabilidade e GovernanÃ§a](#80-multi-cloud---padrÃµes-de-portabilidade-e-governanÃ§a)
- [81) Steering Documents - GovernanÃ§a de Projetos EstratÃ©gicos](#81-steering-documents---governanÃ§a-de-projetos-estratÃ©gicos)

## 1) PrincÃ­pios Productionâ€‘First (obrigatÃ³rios)
<!-- tags: production, fundamentals, mandatory, configuration, logging, health-checks -->
<!-- category: core-principles -->
<!-- priority: critical -->
<!-- audience: all-developers -->

**PrincÃ­pios orientadores fundamentais:**
- **Paridade funcional 100% (AS-IS) primeiro**: nenhuma evoluÃ§Ã£o de jornada entra antes de migrar 100% do comportamento atual (funcionalidades, integraÃ§Ãµes e regras), mesmo com UI/arquitetura modernizadas. NÃ£o pode haver perda de capacidade para o usuÃ¡rio final.
- **Contratos claros e estÃ¡veis**: APIs e integraÃ§Ãµes evoluem por contrato (versionado), nÃ£o por convenÃ§Ã£o implÃ­cita.
- **Qualidade como gate, nÃ£o como atividade**: builds, testes e validaÃ§Ãµes bloqueiam merge/deploy automaticamente.
- **Observabilidade e reversibilidade**: toda mudanÃ§a Ã© rastreÃ¡vel (logs/metrics/traces) e reversÃ­vel (feature flags/rollbacks).
- **Simplicidade intencional**: evite soluÃ§Ãµes "clever"; priorize clareza, consistÃªncia e padronizaÃ§Ã£o.

1.1 ConfiguraÃ§Ã£o por ambiente
- VariÃ¡veis de ambiente como fonte de verdade; zero secrets no repositÃ³rio.
- ValidaÃ§Ã£o de configuraÃ§Ã£o no startup (failâ€‘fast com mensagem clara).

Exemplos:
```ts
// Node/TS
function ensureEnv(name: string): string {
  const v = process.env[name];
  if (!v) throw new Error(`Missing env var ${name}`);
  return v;
}
export const config = {
  NODE_ENV: process.env.NODE_ENV ?? 'development',
  PORT: Number(process.env.PORT ?? 3000),
  DATABASE_URL: ensureEnv('DATABASE_URL'),
  LOG_LEVEL: process.env.LOG_LEVEL ?? 'info'
};
```
```csharp
// .NET
var builder = WebApplication.CreateBuilder(args);
string conn = builder.Configuration["ConnectionStrings:Default"]
  ?? throw new InvalidOperationException("Missing ConnectionStrings:Default");
```

1.2 Logging estruturado
- JSON, correlaÃ§Ã£o (correlationId/requestId), nÃ­veis (`error`, `warn`, `info`, `debug`).
- NÃ£o vazar dados sensÃ­veis nos logs.

```ts
// Winston
import winston from 'winston';
export const logger = winston.createLogger({
  level: process.env.LOG_LEVEL ?? 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [new winston.transports.Console()]
});
```

1.3 Health checks e readiness
- Endpoints `/health` (liveness), `/ready` (readiness) e `/live` quando aplicÃ¡vel.
- Readiness sÃ³ true apÃ³s dependÃªncias crÃ­ticas (DB/cache) estarem OK.

1.4 Tratamento de erros
- Taxonomia clara (negÃ³cio vs tÃ©cnica); Problem Details (HTTP APIs).
- Mensagens amigÃ¡veis ao cliente; detalhes tÃ©cnicos nos logs apenas.

1.5 ResiliÃªncia: timeouts/retries/backoff/circuit breaker
- Timeouts sensatos (cliente e servidor). Retries com jitter exponencial para idempotentes.
- Circuit breaker para integraÃ§Ãµes instÃ¡veis.

1.6 Rate limiting e seguranÃ§a transversal
- Rate limit por IP/rota/usuÃ¡rio. Headers de seguranÃ§a, TLS obrigatÃ³rio, CORS restritivo.

Checklist rÃ¡pido (produÃ§Ã£o)
- [ ] Env validated on startup
- [ ] Logs estruturados + correlaÃ§Ã£o
- [ ] Health/Ready/Live habilitados
- [ ] Timeouts + retries + circuit breaker
- [ ] Rate limiting + CORS + headers seguranÃ§a
- [ ] MÃ©tricas/Traces + dashboards
- [ ] CI/CD com quality gates & scans

## 2) Qualidade de CÃ³digo e PadrÃµes
<!-- tags: code-quality, standards, typescript, linting, naming-conventions -->
<!-- category: development-standards -->
<!-- priority: high -->
<!-- audience: all-developers -->
2.1 Tipagem e lint
- TypeScript `strict`; evitar `any` genÃ©rico; preferir unions/literais.
- ESLint/Prettier/netequivalentes com import/order e path aliases quando aplicÃ¡vel.

2.2 Nomenclatura e coesÃ£o
- FunÃ§Ãµes: verbos; variÃ¡veis: substantivos descritivos; componentes puros onde possÃ­vel.
- Evitar comentÃ¡rios Ã³bvios; documentar o â€œporquÃªâ€.

2.3 Zero simulaÃ§Ãµes
- Evitar placeholders; implementar lÃ³gica real; valores configurÃ¡veis via env/feature flags.

2.4 DocumentaÃ§Ã£o mÃ­nima por mudanÃ§a
- Atualizar README/ADR/guia de uso; diagramas quando houver mudanÃ§as arquiteturais.

2.5 Zero Warnings Policy
- **PolÃ­tica obrigatÃ³ria**: Build limpo = 0 warnings (nÃ£o apenas 0 erros).
- **Processo de resoluÃ§Ã£o**:
  ```bash
  # Listar warnings
  dotnet build 2>&1 | grep "warning"  # ou npm run build, mvn clean install
  
  # Para cada warning: entender â†’ documentar â†’ resolver â†’ validar
  ```
- **Warnings comuns e soluÃ§Ãµes**:
  | Warning | Causa | SoluÃ§Ã£o |
  |---------|-------|---------|
  | Nullability | Propriedade nÃ£o inicializada | Inicializar ou tornar nullable |
  | Unused var | VariÃ¡vel nÃ£o usada | Usar, remover ou `_` discard |
  | Missing await | Async sem await | Adicionar `await` ou remover `async` |
  | Deprecated | API antiga | Migrar para nova API |
- **Rationale**: Warnings ignorados acumulam dÃ©bito tÃ©cnico e mascaram problemas reais.

## 3) DocumentaÃ§Ã£o (padrÃ£o)
<!-- tags: documentation, readme, adr, diagrams, changelog -->
<!-- category: documentation -->
<!-- priority: medium -->
<!-- audience: all-developers, architects -->
- DocumentaÃ§Ã£o viva: README por mÃ³dulo/feature, ADRs para decisÃµes (ver SeÃ§Ã£o 35), diagramas atualizados (Mermaid). 
- PadrÃµes resumidos:
  - README por mÃ³dulo: objetivo, como rodar, dependÃªncias, endpoints/rotas, variÃ¡veis de ambiente, troubleshooting.
  - ADR curto (SeÃ§Ã£o 35): contexto â†’ decisÃ£o â†’ consequÃªncias; 1 ADR por decisÃ£o relevante.
  - ComentÃ¡rios de cÃ³digo: explicar â€œporquÃªâ€; evitar comentÃ¡rios Ã³bvios.
  - Diagramas: manter simples e atualizados (fluxos principais e integraÃ§Ãµes).
  - Change log por release (resumo executivo: riscos, rollback, mÃ©tricas de sucesso).

Modelos embutidos (inline):

Visual Approval â€“ Checklist
```markdown
# AprovaÃ§Ã£o de MudanÃ§as Visuais

## Checklist
- [ ] Capturas antes/depois anexadas
- [ ] Impacto em componentes reutilizados listado
- [ ] AprovaÃ§Ã£o do design/branding anexada
- [ ] Testes visuais passam (link do report)

## DescriÃ§Ã£o
Explique objetivo, escopo e impacto visual.
```

Gap Analysis â€“ Template
```markdown
# Gap Analysis â€“ {MÃ³dulo}

## Escopo
## Fluxos de negÃ³cio
## Regras e validaÃ§Ãµes
## IntegraÃ§Ãµes
## UI/Visual (capturas/links)
## Riscos e mitigaÃ§Ã£o
## Plano de migraÃ§Ã£o por fatias
## MÃ©tricas de sucesso
```

Migration Plan â€“ Template
```markdown
# Migration Plan â€“ {MÃ³dulo}

## Fase 1 (Discovery/ACL)
## Fase 2 (Shadow/Canary)
## Fase 3 (Cutover)
## Fase 4 (Decomission)
## Rollback Plan
## Owners e prazos
```

Tokens â€“ Base (Sass)
```scss
:root {
  /* Brand */
  --brand-primary: #1E90FF;
  --brand-secondary: #FF7A59;
  /* Text */
  --text-primary: #222;  --text-secondary: #555;
  /* Surfaces */
  --surface-base: #fff;  --surface-muted: #f7f7f7;
  /* Border */
  --border-strong: #dcdcdc;
  /* Spacing */
  --space-4: 4px; --space-8: 8px; --space-12: 12px; --space-16: 16px; --space-24: 24px; --space-32: 32px; --space-48: 48px;
  /* Typography */
  --font-family-base: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  --font-size-14: 14px; --font-size-16: 16px; --font-size-18: 18px;
  --line-height-140: 1.4; --line-height-150: 1.5;
  /* Radius & Shadows */
  --radius-4: 4px; --radius-8: 8px; --radius-12: 12px;
  --shadow-sm: 0 1px 2px rgba(0,0,0,.06);
  --shadow-md: 0 2px 8px rgba(0,0,0,.08);
  --shadow-lg: 0 6px 24px rgba(0,0,0,.12);
}
```

### 3.1) Diagrams as Code â€“ PrÃ¡ticas ObrigatÃ³rias
**PrincÃ­pios fundamentais**
- **Versionamento**: diagramas devem estar no mesmo repositÃ³rio do cÃ³digo, tratados como artefatos de primeira classe.
- **Descoberta**: estrutura padronizada de pastas e nomenclatura para facilitar localizaÃ§Ã£o.
- **AutomaÃ§Ã£o**: validaÃ§Ã£o e geraÃ§Ã£o automÃ¡tica via CI/CD pipeline.
- **SincronizaÃ§Ã£o**: diagramas devem ser atualizados junto com mudanÃ§as de cÃ³digo.

**3.1.1 Estrutura de pastas obrigatÃ³ria**
```
/docs/
  /architecture/
    /c4-model/
      /01-system-context/
        - overview-v1.md
        - integrations-v2.md
      /02-containers/
        - [service-name]-containers-v1.md
      /03-components/
        - [service-name]-[component]-v1.md
    /flows/
      - [business-process]-flow-v1.md
    /deployment/
      - [environment]-deployment-v1.md
```

**3.1.2 ConvenÃ§Ãµes de nomenclatura**
- **Arquivos**: `[nivel/tipo]-[contexto]-[versao].md` (ex: `01-system-context-v2.md`)
- **Elementos**: Ver seÃ§Ã£o 4.1.6 para convenÃ§Ãµes completas de nomenclatura de elementos de diagrama
- **Versionamento**: incremental (v1, v2, v3) para mudanÃ§as significativas

**3.1.3 Metadados obrigatÃ³rios**
Todo diagrama deve incluir header com:
```markdown
---
title: "[TÃ­tulo do Diagrama]"
version: "v1.0"
date: "2025-01-15"
author: "[Nome do Autor]"
reviewer: "[Nome do Revisor]"
status: "draft|review|approved|deprecated"
last_updated: "2025-01-15"
related_code: "[links para cÃ³digo relevante]"
---
```

**3.1.4 IntegraÃ§Ã£o com cÃ³digo**
- **ComentÃ¡rios bidirecionais**: cÃ³digo deve referenciar diagramas relevantes
- **Links automÃ¡ticos**: usar ferramentas para detectar mudanÃ§as que afetam diagramas
- **ValidaÃ§Ã£o**: pipeline deve verificar se diagramas estÃ£o atualizados apÃ³s mudanÃ§as arquiteturais

**3.1.5 Ferramentas e automaÃ§Ã£o**
- **Mermaid**: ferramenta principal para diagramas (integraÃ§Ã£o nativa com GitHub/GitLab)
- **PlantUML**: alternativa para diagramas mais complexos (C4-PlantUML)
- **ValidaÃ§Ã£o CI/CD**: 
  ```yaml
  - name: Validate Mermaid Diagrams
    run: |
      npm install -g @mermaid-js/mermaid-cli
      find docs/ -name "*.md" -exec mmdc -i {} -o /tmp/validation.png \;
  ```
- **GeraÃ§Ã£o automÃ¡tica**: converter .md para PNG/SVG em releases
- **NotificaÃ§Ãµes**: alertar equipe quando diagramas ficam desatualizados

**3.1.6 Responsabilidades e governanÃ§a**
- **Responsabilidades especÃ­ficas**: ver seÃ§Ã£o 4.1.5 para ownership detalhado por tipo de diagrama
- **Auditoria geral**: revisÃ£o trimestral de diagramas Ã³rfÃ£os ou desatualizados em todo o repositÃ³rio

## 4) Arquitetura e OrganizaÃ§Ã£o
<!-- tags: architecture, organization, clean-architecture, ddd, cqrs, solid -->
<!-- category: architecture -->
<!-- priority: high -->
<!-- audience: architects, senior-developers -->
- Modularidade por domÃ­nio/feature; dependÃªncias para interfaces/abstraÃ§Ãµes.
- DDD/CQRS quando houver ganho: entidades ricas, value objects, eventos; queries otimizadas (ver [SeÃ§Ã£o 52 - DDD](#52-ddd--diretrizes-objetivas) e [SeÃ§Ã£o 53 - CQRS](#53-cqrs--padrÃ£o-pragmÃ¡tico)).
- SeparaÃ§Ã£o de camadas (Domain/Application/Infra/API) em backends enterprise (ver [SeÃ§Ã£o 54 - Clean Architecture](#54-clean-architecture--contratos-e-fluxo)).
- Observabilidade crossâ€‘cutting (logging, mÃ©tricas, tracing) integrada desde o inÃ­cio (ver [SeÃ§Ã£o 8 - Observabilidade](#8-observabilidade-logs-mÃ©tricas-traces)).
- PadrÃµes SOLID aplicados consistentemente (ver [SeÃ§Ã£o 51 - SOLID](#51-solid--aplicaÃ§Ã£o-prÃ¡tica)).

### 4.1) C4 Model â€“ PadrÃ£o de DocumentaÃ§Ã£o Arquitetural
4.1.1 PrincÃ­pios fundamentais
- **Hierarquia de abstraÃ§Ã£o**: 4 nÃ­veis progressivos de detalhamento (System Context â†’ Container â†’ Component â†’ Code).
- **Diagrams as Code**: diagramas versionados junto com o cÃ³digo, tratados como artefatos de primeira classe.
- **PadronizaÃ§Ã£o visual**: convenÃ§Ãµes de cores, formas e nomenclatura consistentes em toda a organizaÃ§Ã£o.
- **Manutenibilidade**: diagramas atualizados automaticamente ou com responsabilidades claras de manutenÃ§Ã£o.

4.1.2 NÃ­veis do C4 Model
**NÃ­vel 1 - System Context (Contexto do Sistema)**
- **Objetivo**: visÃ£o geral do sistema e suas interaÃ§Ãµes com usuÃ¡rios e sistemas externos.
- **AudiÃªncia**: stakeholders, product owners, arquitetos de soluÃ§Ã£o.
- **Elementos**: sistema principal, usuÃ¡rios (personas), sistemas externos.
- **Quando usar**: documentaÃ§Ã£o inicial, apresentaÃ§Ãµes executivas, onboarding de novos membros.

**NÃ­vel 2 - Container (ContÃªineres)**
- **Objetivo**: decomposiÃ§Ã£o do sistema em contÃªineres executÃ¡veis (aplicaÃ§Ãµes, bancos, serviÃ§os).
- **AudiÃªncia**: arquitetos, tech leads, desenvolvedores sÃªnior.
- **Elementos**: aplicaÃ§Ãµes web, APIs, bancos de dados, message brokers, CDNs.
- **Quando usar**: planejamento de deployment, definiÃ§Ã£o de responsabilidades de equipes.

**NÃ­vel 3 - Component (Componentes)**
- **Objetivo**: estrutura interna de cada contÃªiner, mostrando componentes e suas interaÃ§Ãµes.
- **AudiÃªncia**: desenvolvedores, arquitetos de software.
- **Elementos**: controllers, services, repositories, facades, adapters.
- **Quando usar**: design detalhado, code reviews, refatoraÃ§Ãµes arquiteturais.

**NÃ­vel 4 - Code (CÃ³digo)**
- **Objetivo**: implementaÃ§Ã£o especÃ­fica de componentes crÃ­ticos (classes, interfaces, mÃ©todos).
- **AudiÃªncia**: desenvolvedores trabalhando no componente especÃ­fico.
- **Elementos**: classes, interfaces, enums, mÃ©todos principais.
- **Quando usar**: raramente necessÃ¡rio; apenas para lÃ³gicas complexas ou crÃ­ticas.

4.1.3 ImplementaÃ§Ã£o com Mermaid
**System Context - Exemplo**
```mermaid
flowchart TB
    User["ðŸ‘¤ Cliente\n(Pessoa fÃ­sica)"] 
    Admin["ðŸ‘¨â€ðŸ’¼ Administrador\n(FuncionÃ¡rio)"]
    
    System["ðŸ“± E-commerce Platform\n(Sistema principal)"]
    
    Payment["ðŸ’³ Gateway de Pagamento\n(Sistema externo)"]
    Email["ðŸ“§ ServiÃ§o de Email\n(Sistema externo)"]
    
    User -->|"Navega, compra\nvisualiza pedidos"| System
    Admin -->|"Gerencia produtos\nconfigura sistema"| System
    
    System -->|"Processa pagamentos\nvia API REST"| Payment
    System -->|"Envia notificaÃ§Ãµes\nvia SMTP"| Email
    
    classDef person fill:#87CEEB,stroke:#4682B4,color:#1a1a1a
    classDef system fill:#90EE90,stroke:#228B22,color:#1a1a1a
    classDef external fill:#FFB6C1,stroke:#DC143C,color:#1a1a1a
    
    class User,Admin person
    class System system
    class Payment,Email external
```

**Container - Exemplo**
```mermaid
flowchart TB
    subgraph "E-commerce Platform"
        Web["ðŸŒ Web Application\n(React SPA)"]
        API["âš™ï¸ API Gateway\n(Node.js/Express)"]
        Auth["ðŸ” Auth Service\n(Node.js)"]
        DB[("ðŸ’¾ Database\n(PostgreSQL)")]
        Cache[("âš¡ Cache\n(Redis)")]
    end
    
    User["ðŸ‘¤ Cliente"] --> Web
    Web -->|"API calls\n(HTTPS/JSON)"| API
    API --> Auth
    API --> DB
    API --> Cache
    
    classDef person fill:#87CEEB,stroke:#4682B4,color:#1a1a1a
    classDef webapp fill:#98FB98,stroke:#32CD32,color:#1a1a1a
    classDef service fill:#F0E68C,stroke:#DAA520,color:#1a1a1a
    classDef database fill:#DDA0DD,stroke:#9370DB,color:#1a1a1a
    
    class User person
    class Web webapp
    class API,Auth service
    class DB,Cache database
```

4.1.4 ConvenÃ§Ãµes obrigatÃ³rias
**Nomenclatura**
- Sistemas: `PascalCase` (ex: `EcommercePlatform`, `PaymentGateway`)
- ContÃªineres: `PascalCase + Tipo` (ex: `WebApplication`, `ApiGateway`, `UserDatabase`)
- Componentes: `PascalCase` (ex: `UserController`, `PaymentService`, `ProductRepository`)
- Relacionamentos: verbos no presente (ex: "envia", "consulta", "armazena")

**Cores padronizadas**
- Pessoas/Atores: `#87CEEB` (azul claro)
- Sistema principal: `#90EE90` (verde claro)
- Sistemas externos: `#FFB6C1` (rosa claro)
- Web Applications: `#98FB98` (verde menta)
- APIs/Services: `#F0E68C` (amarelo claro)
- Databases: `#DDA0DD` (roxo claro)
- **Texto sempre**: `color:#1a1a1a` para legibilidade

**Ãcones recomendados**
- Pessoas: ðŸ‘¤, ðŸ‘¨â€ðŸ’¼, ðŸ‘©â€ðŸ’»
- Web: ðŸŒ, ðŸ’», ðŸ“±
- APIs: âš™ï¸, ðŸ”§, ðŸ› ï¸
- Databases: ðŸ’¾, ðŸ—„ï¸, ðŸ“Š
- SeguranÃ§a: ðŸ”, ðŸ›¡ï¸, ðŸ”‘
- ComunicaÃ§Ã£o: ðŸ“§, ðŸ“ž, ðŸ’¬

4.1.5 Responsabilidades e manutenÃ§Ã£o
**Ownership por nÃ­vel**
- **System Context**: Arquiteto de SoluÃ§Ã£o + Product Owner
  - **Responsabilidades**: definir escopo do sistema, identificar stakeholders, mapear integraÃ§Ãµes externas
  - **FrequÃªncia de revisÃ£o**: trimestral ou quando hÃ¡ mudanÃ§as de negÃ³cio significativas
  - **CritÃ©rios de atualizaÃ§Ã£o**: novos sistemas externos, mudanÃ§as de personas, alteraÃ§Ãµes de escopo

- **Container**: Tech Lead + Arquiteto de Software
  - **Responsabilidades**: definir arquitetura de deployment, tecnologias, protocolos de comunicaÃ§Ã£o
  - **FrequÃªncia de revisÃ£o**: a cada release major ou mudanÃ§a arquitetural
  - **CritÃ©rios de atualizaÃ§Ã£o**: novos serviÃ§os, mudanÃ§as de tecnologia, alteraÃ§Ãµes de deployment

- **Component**: Desenvolvedores SÃªnior da equipe
  - **Responsabilidades**: estrutura interna dos serviÃ§os, padrÃµes de design, interfaces
  - **FrequÃªncia de revisÃ£o**: a cada sprint ou refatoraÃ§Ã£o significativa
  - **CritÃ©rios de atualizaÃ§Ã£o**: novos componentes, mudanÃ§as de responsabilidades, refatoraÃ§Ãµes

- **Code**: Desenvolvedor responsÃ¡vel pelo componente
  - **Responsabilidades**: implementaÃ§Ã£o especÃ­fica, apenas para componentes crÃ­ticos
  - **FrequÃªncia de revisÃ£o**: conforme necessÃ¡rio, raramente usado
  - **CritÃ©rios de atualizaÃ§Ã£o**: mudanÃ§as em lÃ³gicas complexas ou algoritmos crÃ­ticos

**Templates obrigatÃ³rios por nÃ­vel**

**Template System Context**
```markdown
# System Context - [Nome do Sistema]

## Metadados
- **VersÃ£o**: v1.0
- **Data**: [YYYY-MM-DD]
- **Autor**: [Nome]
- **Revisor**: [Arquiteto de SoluÃ§Ã£o]
- **Status**: draft|approved|deprecated

## DescriÃ§Ã£o
[PropÃ³sito do sistema em 2-3 frases]

## Stakeholders
### UsuÃ¡rios PrimÃ¡rios
- **[Persona]**: [DescriÃ§Ã£o do papel e necessidades]

### UsuÃ¡rios SecundÃ¡rios
- **[Persona]**: [DescriÃ§Ã£o do papel e necessidades]

### Sistemas Externos
- **[Sistema]**: [PropÃ³sito da integraÃ§Ã£o]

## Diagrama
[Mermaid diagram aqui]

## Fluxos Principais
1. **[Fluxo]**: [DescriÃ§Ã£o]
2. **[Fluxo]**: [DescriÃ§Ã£o]

## IntegraÃ§Ãµes
| Sistema | Protocolo | Dados | FrequÃªncia |
|---------|-----------|-------|------------|
| [Nome] | [REST/SOAP/etc] | [Tipo] | [Tempo real/Batch] |

## PrÃ³ximos Passos
- [ ] Definir containers (NÃ­vel 2)
- [ ] Validar com stakeholders
```

**Template Container**
```markdown
# Container Diagram - [Nome do Sistema]

## Metadados
- **VersÃ£o**: v1.0
- **Data**: [YYYY-MM-DD]
- **Autor**: [Nome]
- **Revisor**: [Tech Lead]
- **Status**: draft|approved|deprecated
- **Relacionado**: [Link para System Context]

## Arquitetura
[DescriÃ§Ã£o da estratÃ©gia arquitetural]

## Containers
### [Nome do Container]
- **Tipo**: Web App|API|Database|Service
- **Tecnologia**: [Stack tecnolÃ³gico]
- **Responsabilidades**: [O que faz]
- **Dados**: [Que dados manipula]
- **Escalabilidade**: [EstratÃ©gia de escala]

## Diagrama
[Mermaid diagram aqui]

## Protocolos de ComunicaÃ§Ã£o
| De | Para | Protocolo | Formato | AutenticaÃ§Ã£o |
|----|------|-----------|---------|-------------|
| [Container] | [Container] | [HTTP/gRPC/etc] | [JSON/XML] | [JWT/OAuth] |

## Deployment
- **Ambiente**: [Docker/K8s/VM]
- **DependÃªncias**: [ServiÃ§os externos]
- **ConfiguraÃ§Ã£o**: [VariÃ¡veis de ambiente]

## PrÃ³ximos Passos
- [ ] Definir componentes internos (NÃ­vel 3)
- [ ] Validar com equipe de desenvolvimento
```

**Template Component**
```markdown
# Component Diagram - [Nome do Container]

## Metadados
- **VersÃ£o**: v1.0
- **Data**: [YYYY-MM-DD]
- **Autor**: [Nome]
- **Revisor**: [Desenvolvedor SÃªnior]
- **Status**: draft|approved|deprecated
- **Relacionado**: [Link para Container Diagram]

## Arquitetura Interna
[PadrÃµes arquiteturais utilizados: MVC, Clean Architecture, etc.]

## Componentes
### [Nome do Componente]
- **Tipo**: Controller|Service|Repository|Adapter
- **Responsabilidades**: [O que faz]
- **DependÃªncias**: [Outros componentes]
- **Interfaces**: [Contratos expostos]

## Diagrama
[Mermaid diagram aqui]

## Fluxo de Dados
1. **[Entrada]** â†’ [Componente] â†’ [Processamento] â†’ **[SaÃ­da]**

## PadrÃµes Implementados
- **[PadrÃ£o]**: [Como Ã© usado]

## Testes
- **UnitÃ¡rios**: [Cobertura por componente]
- **IntegraÃ§Ã£o**: [Testes entre componentes]

## PrÃ³ximos Passos
- [ ] Implementar componentes
- [ ] Definir testes
- [ ] Code review
```

**Component - Exemplo (PadrÃ£o Melhorado)**
```mermaid
flowchart TB
    %% Sistemas Externos
    subgraph external ["ðŸŒ Sistemas Externos"]
        ElevenLabsAPI["ðŸŽ¤ ElevenLabs API\n(Text-to-Speech)"]
        WebAudioAPI["ðŸ”Š Web Audio API\n(Audio Processing)"]
        LocalStorageAPI["ðŸ’¾ Local Storage API\n(Configuration)"]
    end
    
    %% Camada de ApresentaÃ§Ã£o
    subgraph presentation ["ðŸ“± Camada de ApresentaÃ§Ã£o"]
        AppRoot["App Root\n(Main Component)"]
        HeaderComponent["Header Component\n(Navigation)"]
        HomeContainer["Home Container\n(Main Interface)"]
        SidebarComponent["Sidebar Component\n(Settings Panel)"]
    end
    
    %% Camada de LÃ³gica de NegÃ³cio
    subgraph business ["âš™ï¸ Camada de LÃ³gica de NegÃ³cio"]
        useConversationHook["useConversation Hook\n(State Management)"]
        AudioControls["Audio Controls\n(Playback Logic)"]
        VoiceVisualizer["Voice Visualizer\n(Audio Visualization)"]
    end
    
    %% Camada de ServiÃ§os
    subgraph services ["ðŸ”§ Camada de ServiÃ§os"]
        ConfigManager["Config Manager\n(Settings Service)"]
        ErrorBoundary["Error Boundary\n(Error Handling)"]
        LazyLoader["Lazy Loader\n(Performance)"]
    end
    
    %% Fluxos principais
    AppRoot --> HeaderComponent
    AppRoot --> HomeContainer
    HomeContainer --> SidebarComponent
    HomeContainer --> useConversationHook
    HomeContainer --> AudioControls
    HomeContainer --> VoiceVisualizer
    
    %% DependÃªncias de serviÃ§os
    useConversationHook --> ConfigManager
    AudioControls --> ConfigManager
    SidebarComponent --> ConfigManager
    AppRoot --> ErrorBoundary
    AppRoot --> LazyLoader
    
    %% IntegraÃ§Ãµes externas
    useConversationHook -.->|"API Calls\n(HTTPS)"| ElevenLabsAPI
    AudioControls -.->|"Audio Processing\n(Web APIs)"| WebAudioAPI
    ConfigManager -.->|"Persist Settings\n(Local Storage)"| LocalStorageAPI
    
    %% Estilos por camada
    classDef external fill:#FFB6C1,stroke:#DC143C,color:#1a1a1a
    classDef presentation fill:#87CEEB,stroke:#4682B4,color:#1a1a1a
    classDef business fill:#98FB98,stroke:#32CD32,color:#1a1a1a
    classDef service fill:#F0E68C,stroke:#DAA520,color:#1a1a1a
    
    class ElevenLabsAPI,WebAudioAPI,LocalStorageAPI external
    class AppRoot,HeaderComponent,HomeContainer,SidebarComponent presentation
    class useConversationHook,AudioControls,VoiceVisualizer business
    class ConfigManager,ErrorBoundary,LazyLoader service
```

**ObservaÃ§Ãµes importantes sobre o padrÃ£o Component:**
- **Uso de `flowchart TB`**: O Mermaid nÃ£o possui suporte nativo para `C4Component`, entÃ£o utilizamos `flowchart TB` (Top-Bottom) com subgraphs para organizar por camadas arquiteturais.
- **OrganizaÃ§Ã£o em camadas**: SeparaÃ§Ã£o clara entre ApresentaÃ§Ã£o, LÃ³gica de NegÃ³cio e ServiÃ§os para melhor legibilidade.
- **Cores diferenciadas**: Cada camada possui uma cor especÃ­fica para facilitar a identificaÃ§Ã£o visual.
- **Relacionamentos claros**: Linhas sÃ³lidas para dependÃªncias internas e pontilhadas para integraÃ§Ãµes externas.
- **Nomenclatura consistente**: Componentes seguem padrÃ£o PascalCase com descriÃ§Ã£o funcional.

**PadrÃµes visuais obrigatÃ³rios para diagramas C4 Component:**

*Paleta de cores por camada (obrigatÃ³ria)*
```css
/* Sistemas Externos */
--external-fill: #FFB6C1;      /* Rosa claro */
--external-stroke: #DC143C;    /* Vermelho */

/* Camada de ApresentaÃ§Ã£o */
--presentation-fill: #87CEEB;  /* Azul claro */
--presentation-stroke: #4682B4; /* Azul mÃ©dio */

/* Camada de LÃ³gica de NegÃ³cio */
--business-fill: #98FB98;      /* Verde menta */
--business-stroke: #32CD32;    /* Verde lima */

/* Camada de ServiÃ§os */
--service-fill: #F0E68C;       /* Amarelo claro */
--service-stroke: #DAA520;     /* Dourado */

/* Texto (sempre obrigatÃ³rio) */
--text-color: #1a1a1a;         /* Preto suave para legibilidade */
```

*Tipos de setas e relacionamentos*
- **Setas sÃ³lidas (`-->`)**: DependÃªncias diretas entre componentes internos
- **Setas pontilhadas (`-.->`)**: IntegraÃ§Ãµes com sistemas externos ou APIs
- **Labels nas setas**: Formato `"AÃ§Ã£o\nvia Protocolo"` (ex: `"API Calls\n(HTTPS)"`)

*Nomenclatura de componentes*
- **Formato**: `[NomeComponente]\n([DescriÃ§Ã£o Funcional])`
- **Exemplos**: `"App Root\n(Main Component)"`, `"Config Manager\n(Settings Service)"`
- **Subgraphs**: `[Emoji] [Nome da Camada]` (ex: `"ðŸ“± Camada de ApresentaÃ§Ã£o"`)

*AplicaÃ§Ã£o das classes CSS no Mermaid*
```mermaid
classDef external fill:#FFB6C1,stroke:#DC143C,color:#1a1a1a
classDef presentation fill:#87CEEB,stroke:#4682B4,color:#1a1a1a
classDef business fill:#98FB98,stroke:#32CD32,color:#1a1a1a
classDef service fill:#F0E68C,stroke:#DAA520,color:#1a1a1a

class ComponenteExterno1,ComponenteExterno2 external
class ComponenteApresentacao1,ComponenteApresentacao2 presentation
class ComponenteNegocio1,ComponenteNegocio2 business
class ComponenteServico1,ComponenteServico2 service
```

4.1.6 ConvenÃ§Ãµes de nomenclatura e padrÃµes visuais
**Nomenclatura obrigatÃ³ria**

*Elementos do diagrama*
- **Pessoas/Atores**: `[Emoji] [Papel/Persona]\n([DescriÃ§Ã£o breve])`
  - Exemplos: `ðŸ‘¤ Cliente\n(Pessoa fÃ­sica)`, `ðŸ‘¨â€ðŸ’¼ Administrador\n(FuncionÃ¡rio interno)`

- **Sistemas**: `[Emoji] [Nome do Sistema]\n([PropÃ³sito principal])`
  - Exemplos: `ðŸ“± E-commerce Platform\n(Sistema de vendas online)`, `ðŸ”— Payment Gateway\n(Sistema externo)`

- **Containers**: `[Emoji] [Nome + Tipo]\n([Tecnologia])`
  - Exemplos: `ðŸŒ Web Application\n(React SPA)`, `âš™ï¸ API Gateway\n(Node.js/Express)`

- **Componentes**: `[Nome][Tipo]` (sem emoji, mais limpo)
  - Exemplos: `UserController`, `PaymentService`, `ProductRepository`

*Relacionamentos*
- **Formato**: `"[AÃ§Ã£o/Verbo]\nvia [Protocolo/Meio]"`
- **Exemplos**: 
  - `"Navega e compra\nvia HTTPS"`
  - `"Processa pagamentos\nvia API REST"`
  - `"Envia notificaÃ§Ãµes\nvia SMTP"`

**Paleta de cores padronizada**

*Cores primÃ¡rias (obrigatÃ³rias)*
```css
/* Pessoas/Atores */
--person-fill: #87CEEB;     /* Azul claro */
--person-stroke: #4682B4;   /* Azul mÃ©dio */

/* Sistema principal */
--system-fill: #90EE90;     /* Verde claro */
--system-stroke: #228B22;   /* Verde escuro */

/* Sistemas externos */
--external-fill: #FFB6C1;   /* Rosa claro */
--external-stroke: #DC143C; /* Vermelho */

/* Web Applications */
--webapp-fill: #98FB98;     /* Verde menta */
--webapp-stroke: #32CD32;   /* Verde lima */

/* APIs/Services */
--service-fill: #F0E68C;    /* Amarelo claro */
--service-stroke: #DAA520;  /* Dourado */

/* Databases */
--database-fill: #DDA0DD;   /* Roxo claro */
--database-stroke: #9370DB; /* Roxo mÃ©dio */

/* Texto (sempre) */
--text-color: #1a1a1a;      /* Preto suave */
```

*Cores secundÃ¡rias (opcionais)*
```css
/* Message Brokers */
--broker-fill: #FFA07A;     /* SalmÃ£o */
--broker-stroke: #FF6347;   /* Tomate */

/* Cache/Storage */
--cache-fill: #20B2AA;      /* Verde Ã¡gua */
--cache-stroke: #008B8B;    /* Ciano escuro */

/* Security/Auth */
--security-fill: #FFD700;   /* Dourado */
--security-stroke: #FFA500; /* Laranja */

/* Monitoring */
--monitoring-fill: #D3D3D3; /* Cinza claro */
--monitoring-stroke: #A9A9A9; /* Cinza escuro */
```

**Ãcones padronizados por categoria**

*Pessoas e Atores*
- ðŸ‘¤ UsuÃ¡rio genÃ©rico
- ðŸ‘¨â€ðŸ’¼ Administrador/FuncionÃ¡rio
- ðŸ‘©â€ðŸ’» Desenvolvedor/TÃ©cnico
- ðŸ¢ Sistema corporativo
- ðŸŒ UsuÃ¡rio externo

*AplicaÃ§Ãµes e Interfaces*
- ðŸŒ Web Application
- ðŸ“± Mobile App
- ðŸ’» Desktop App
- ðŸ–¥ï¸ Admin Panel
- ðŸ“Š Dashboard

*ServiÃ§os e APIs*
- âš™ï¸ API Gateway
- ðŸ”§ Microservice
- ðŸ› ï¸ Background Service
- ðŸ”„ Message Broker
- ðŸ“¡ Event Bus

*Dados e Armazenamento*
- ðŸ’¾ Database
- ðŸ—„ï¸ Data Warehouse
- ðŸ“Š Analytics DB
- âš¡ Cache (Redis)
- ðŸ“ File Storage

*SeguranÃ§a e AutenticaÃ§Ã£o*
- ðŸ” Auth Service
- ðŸ›¡ï¸ Security Gateway
- ðŸ”‘ Key Management
- ðŸŽ« Token Service
- ðŸ”’ Encryption

*ComunicaÃ§Ã£o e IntegraÃ§Ã£o*
- ðŸ“§ Email Service
- ðŸ“ž SMS Service
- ðŸ’¬ Chat/Messaging
- ðŸ”— External API
- ðŸŒ‰ Integration Bridge

**Regras de aplicaÃ§Ã£o**
1. **ConsistÃªncia**: usar sempre os mesmos Ã­cones para os mesmos tipos de componentes
2. **Legibilidade**: texto sempre em `#1a1a1a` para contraste adequado
3. **Hierarquia**: cores mais vibrantes para elementos principais, mais suaves para secundÃ¡rios
4. **Acessibilidade**: verificar contraste mÃ­nimo de 4.5:1 entre texto e fundo
5. **DocumentaÃ§Ã£o**: manter guia de cores e Ã­cones atualizado no repositÃ³rio

**GovernanÃ§a e auditoria**
- **RevisÃ£o trimestral**: verificar diagramas Ã³rfÃ£os ou desatualizados
- **MÃ©tricas de qualidade**: % de diagramas atualizados, tempo mÃ©dio de atualizaÃ§Ã£o
- **AutomaÃ§Ã£o**: alertas quando cÃ³digo muda sem atualizar diagramas relacionados
- **Treinamento**: onboarding obrigatÃ³rio sobre C4 para novos desenvolvedores
- **Style guide**: manter documento com exemplos visuais das convenÃ§Ãµes
- **Code**: Desenvolvedor responsÃ¡vel pelo componente

**CritÃ©rios de atualizaÃ§Ã£o**
- MudanÃ§as arquiteturais significativas (novos serviÃ§os, integraÃ§Ãµes)
- AlteraÃ§Ãµes em fluxos de dados crÃ­ticos
- RefatoraÃ§Ãµes que impactem mÃºltiplos componentes
- Onboarding de novos membros da equipe
- Reviews trimestrais de arquitetura

**Templates obrigatÃ³rios**
- Cada nÃ­vel deve ter template padrÃ£o no repositÃ³rio
- ValidaÃ§Ã£o automÃ¡tica de sintaxe Mermaid no CI/CD
- Links para diagramas atualizados no README principal
- Versionamento junto com releases do sistema

## 5) EstratÃ©gias Comprovadas de ResoluÃ§Ã£o de Problemas
5.1 Protocolos de seguranÃ§a (mudanÃ§as massivas)
- Backup/checkpoint antes; validaÃ§Ã£o incremental (lint/build/test) a cada passo.
- Limite de regressÃ£o: â‰¤ 10 novos erros; acima disso, rollback automÃ¡tico.

5.2 AnÃ¡lise de frequÃªncia e concentraÃ§Ã£o
- Priorize top 3 tipos de erro por contagem; ataque arquivos com â‰¥ 3 ocorrÃªncias (efeito cascata).

5.3 PadrÃµes de alto ROI (genÃ©ricos)
- Ordem de argumentos incorreta em construtores/mÃ©todos (corrige vÃ¡rios errors de conversÃ£o).
- ComparaÃ§Ãµes com sentinelas incorretas (use `null`/`default` quando apropriado, nÃ£o â€œmÃ¡gicosâ€).
- ConversÃ£o de value objects â†’ primitivos esperados (e.g., `.Value`/`.ToString()`/`.ToNumber()`).
- Eliminar duplicaÃ§Ãµes de repositÃ³rios/contratos (interface + base concreta).

## 6) Testes Unificados (Unit + Integration + E2E + NFR)
<!-- tags: testing, unit-tests, integration-tests, e2e, nfr, quality-assurance -->
<!-- category: testing -->
<!-- priority: high -->
<!-- audience: developers, qa-engineers -->

### 6.1 PirÃ¢mide de Testes e EstratÃ©gia
- **Unit (70%)**: rÃ¡pidos, puros, isolados; mocks para dependÃªncias externas
- **Integration (20%)**: com DB/serviÃ§os reais; validaÃ§Ã£o de contratos
- **E2E (10%)**: fluxos crÃ­ticos de negÃ³cio; cenÃ¡rios happy path + edge cases principais
- **NFR**: performance, seguranÃ§a, caos engineering (executados periodicamente)

### 6.2 Testes UnitÃ¡rios
- **Cobertura mÃ­nima**: 80% para cÃ³digo novo, 60% para legacy
- **PadrÃµes**: AAA (Arrange/Act/Assert), nomes descritivos, um assert por teste
- **Mocks**: usar para I/O, APIs externas, tempo; evitar over-mocking
- **Ferramentas**: Jest/Vitest (JS/TS), xUnit (.NET), JUnit (Java)

### 6.3 Testes de IntegraÃ§Ã£o
- **Escopo**: APIs + DB, message queues, file system
- **Dados**: seeds controlados, transaÃ§Ãµes rollback, containers isolados
- **Contratos**: Pact/OpenAPI para fronteiras entre serviÃ§os
- **Performance**: timeouts adequados, cleanup automÃ¡tico

### 6.4 Testes E2E (End-to-End)
- **Ferramentas**: Playwright (recomendado), Cypress, Selenium
- **CenÃ¡rios mÃ­nimos**: login, fluxo principal, checkout/transaÃ§Ã£o
- **Determinismo**: aguardar elementos, fixar dados de teste, evitar flakiness
- **Artefatos**: screenshots, traces, vÃ­deos em falhas
- **Ambientes**: staging dedicado, dados sintÃ©ticos

### 6.5 Testes de NFR (NÃ£o Funcionais)
- **Performance**: k6, JMeter, Artillery para load/stress testing
- **SeguranÃ§a**: OWASP ZAP, Burp Suite, anÃ¡lise estÃ¡tica (SAST)
- **Chaos Engineering**: Chaos Mesh, Gremlin para resiliÃªncia
- **Acessibilidade**: axe-core, Lighthouse CI

### 6.6 Dados de Teste
- **EstratÃ©gia**: fixtures versionadas, factories, builders pattern
- **Isolamento**: cada teste com dados prÃ³prios, cleanup automÃ¡tico
- **Mascaramento**: PII/PHI mascarados em ambientes nÃ£o-produÃ§Ã£o
- **SÃ­ntese**: dados sintÃ©ticos para volume, ferramentas como Faker.js

### 6.7 CI/CD e Quality Gates
- **Pipeline**: lint â†’ unit â†’ integration â†’ build â†’ security â†’ e2e â†’ deploy
- **Gates obrigatÃ³rios**: cobertura â‰¥80% (unit), â‰¥60% (integration), zero vulnerabilidades crÃ­ticas
- **ParalelizaÃ§Ã£o**: testes independentes, matrix builds por navegador/OS
- **RelatÃ³rios**: HTML reports, mÃ©tricas de tendÃªncia, alertas de regressÃ£o

### 6.8 Checklist de ImplementaÃ§Ã£o
- [ ] PirÃ¢mide de testes implementada (70/20/10)
- [ ] Cobertura de cÃ³digo â‰¥80% para novo cÃ³digo
- [ ] Testes de contrato para APIs pÃºblicas (ver [SeÃ§Ã£o 18 - Design de APIs](#18-design-de-apis-restgraphql))
- [ ] E2E para fluxos crÃ­ticos de negÃ³cio
- [ ] Dados de teste isolados e determinÃ­sticos (ver [SeÃ§Ã£o 60 - Dados de Teste](#60-dados-de-teste-mascaramento-e-sÃ­ntese))
- [ ] Pipeline com quality gates automÃ¡ticos (ver [SeÃ§Ã£o 7 - CI/CD](#7-cicd-e-deploy))
- [ ] RelatÃ³rios de teste integrados ao CI/CD
- [ ] Testes de performance em staging (ver [SeÃ§Ã£o 19 - Performance](#19-performance-e-caching))
- [ ] Monitoramento de flakiness e tempo de execuÃ§Ã£o (ver [SeÃ§Ã£o 8 - Observabilidade](#8-observabilidade-logs-mÃ©tricas-traces))
- [ ] Testes de seguranÃ§a automatizados (ver [SeÃ§Ã£o 9 - SeguranÃ§a](#9-seguranÃ§a-owasp-top-10--prÃ¡ticas))

### 6.9 Testes Isolados ExecutÃ¡veis
**Objetivo**: Validar componentes de forma independente ANTES de integrar ao sistema principal.

**Estrutura obrigatÃ³ria**:
```
TestProject/
â”œâ”€â”€ TestProject.csproj (ou package.json)
â”œâ”€â”€ appsettings.json (configuraÃ§Ã£o prÃ³pria)
â”œâ”€â”€ Program.cs (ou index.ts)
â””â”€â”€ README.md (como executar)
```

**CaracterÃ­sticas essenciais**:
- âœ… **ExecutÃ¡vel**: `dotnet run` ou `npm start` funciona standalone
- âœ… **Independente**: NÃ£o depende de outros sistemas/serviÃ§os
- âœ… **ConfigurÃ¡vel**: appsettings/env prÃ³prio
- âœ… **Verboso**: Logs detalhados com emojis (ver [SeÃ§Ã£o 8.1.4](#814-padrÃ£o-de-logs-com-emojis))
- âœ… **Validador**: Verifica resultados automaticamente

**Template mÃ­nimo**:
```csharp
// C# Console Test
Console.WriteLine("ðŸ”„ Iniciando teste...");

// 1. Setup
var config = LoadConfig();
var component = CreateComponent(config);

// 2. ExecuÃ§Ã£o
var startTime = DateTime.UtcNow;
var result = await component.ExecuteAsync();
var duration = (DateTime.UtcNow - startTime).TotalSeconds;

// 3. ValidaÃ§Ã£o
if (!result.IsSuccess)
    throw new Exception($"âŒ Falha: {result.Error}");

// 4. MÃ©tricas
Console.WriteLine($"âœ… Sucesso!");
Console.WriteLine($"ðŸ“Š Itens processados: {result.Count}");
Console.WriteLine($"â±ï¸ DuraÃ§Ã£o: {duration:F2}s");
```

**Quando usar**:
- Validar refatoraÃ§Ãµes antes de integrar
- Testar componentes com dependÃªncias externas (DB, APIs)
- Debugging de problemas complexos
- DemonstraÃ§Ã£o de funcionalidades para stakeholders

## 7) CI/CD e Deploy
7.1 Pipeline padrÃ£o (ex.: GitHub Actions)
- Jobs: lint â†’ testes unit/integration â†’ build â†’ security scans (SCA/CodeQL) â†’ e2e (opcional) â†’ build artifacts â†’ deploy.

Exemplo (resumo):
```yaml
name: CI
on: [push, pull_request]
jobs:
  lint_test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: 20 }
      - run: npm ci
      - run: npm run lint && npm run test -- --coverage
  build:
    needs: lint_test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm ci && npm run build
```

6.2 Deploy
- Zeroâ€‘downtime (blueâ€‘green/rolling), health checks e rollback automÃ¡tico.
- Infra como cÃ³digo (Docker/Kubernetes/Terraform) quando aplicÃ¡vel.

6.3 Quality Gates (AutomÃ¡ticos e ObrigatÃ³rios)
- **PrincÃ­pio fundamental**: qualidade como gate, nÃ£o como atividade. Builds, testes e validaÃ§Ãµes bloqueiam merge/deploy automaticamente.
- **Gates obrigatÃ³rios que bloqueiam pipeline**:
  - Cobertura de testes â‰¥ 80% (unit) e â‰¥ 60% (integration)
  - Zero vulnerabilidades crÃ­ticas/altas (SAST/SCA)
  - Complexidade ciclomÃ¡tica â‰¤ 10 por mÃ©todo
  - Performance: build time â‰¤ 10min, testes â‰¤ 5min
  - Lint/formatting: zero warnings em cÃ³digo novo
  - Testes de contrato passando (APIs)
  - Smoke tests em ambiente de staging
- **PolÃ­ticas de exceÃ§Ã£o**: apenas com aprovaÃ§Ã£o formal (change control) e plano de mitigaÃ§Ã£o documentado.
- **MÃ©tricas de qualidade**: dashboards pÃºblicos com trends de cobertura, vulnerabilidades e tempo de build por equipe/repositÃ³rio.

## 8) Observabilidade Completa (Logs, MÃ©tricas, Traces, Dashboards)
<!-- tags: observability, logging, metrics, tracing, monitoring, dashboards -->
<!-- category: observability -->
<!-- priority: high -->
<!-- audience: developers, sre, devops -->

### 8.1 Logs estruturados

**8.1.1 Formato e metadados obrigatÃ³rios**
- **Formato**: JSON estruturado com campos padronizados.
- **Metadados essenciais**: `timestamp`, `level`, `service`, `version`, `environment`, `correlationId`, `userId` (quando aplicÃ¡vel).
- **SeguranÃ§a**: NUNCA logar dados sensÃ­veis (senhas, tokens, PII); usar mascaramento quando necessÃ¡rio.

**8.1.2 NÃ­veis de log**
- `ERROR`: falhas que impedem operaÃ§Ã£o; sempre incluir stack trace.
- `WARN`: situaÃ§Ãµes anÃ´malas que nÃ£o impedem operaÃ§Ã£o; degradaÃ§Ã£o de performance.
- `INFO`: eventos importantes de negÃ³cio; inÃ­cio/fim de operaÃ§Ãµes crÃ­ticas.
- `DEBUG`: informaÃ§Ãµes detalhadas para troubleshooting; apenas em desenvolvimento/staging.

**8.1.3 Exemplo de implementaÃ§Ã£o**
```ts
// Node.js/TypeScript com Winston
import winston from 'winston';

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: {
    service: process.env.SERVICE_NAME || 'unknown',
    version: process.env.SERVICE_VERSION || '1.0.0',
    environment: process.env.NODE_ENV || 'development'
  },
  transports: [new winston.transports.Console()]
});

// Uso com correlaÃ§Ã£o
function logWithCorrelation(correlationId: string, level: string, message: string, meta?: any) {
  logger.log(level, message, { correlationId, ...meta });
}
```

**8.1.4 PadrÃ£o de Logs com Emojis**
**Objetivo**: Facilitar identificaÃ§Ã£o visual rÃ¡pida de logs em ambientes de desenvolvimento e troubleshooting.

**PadrÃ£o obrigatÃ³rio**:
```csharp
// C# / .NET
_logger.LogInformation("ðŸ”„ [Componente] Iniciando processamento");
_logger.LogInformation("ðŸ“Š [Componente] {Count} itens processados", count);
_logger.LogDebug("â„¹ï¸ [Componente] Detalhe: {Detail}", detail);
_logger.LogInformation("âœ… [Componente] ConcluÃ­do! DuraÃ§Ã£o: {Duration:F2}s", duration);
_logger.LogWarning("âš ï¸ [Componente] AtenÃ§Ã£o: {Message}", msg);
_logger.LogError(ex, "âŒ [Componente] Erro ao processar: {Item}", item);
```

```typescript
// TypeScript / Node.js
logger.info("ðŸ”„ [Component] Starting process");
logger.info(`ðŸ“Š [Component] ${count} items processed`);
logger.debug(`â„¹ï¸ [Component] Detail: ${detail}`);
logger.info(`âœ… [Component] Completed! Duration: ${duration}s`);
logger.warn(`âš ï¸ [Component] Warning: ${msg}`);
logger.error(`âŒ [Component] Error processing: ${item}`, { error });
```

**Conjunto padronizado de emojis**:
| Emoji | Uso | NÃ­vel |
|-------|-----|-------|
| ðŸ”„ | InÃ­cio de operaÃ§Ã£o | INFO |
| âœ… | Sucesso/ConclusÃ£o | INFO |
| âŒ | Erro/Falha | ERROR |
| âš ï¸ | Aviso/AtenÃ§Ã£o | WARN |
| ðŸ“Š | MÃ©tricas/Contadores | INFO |
| â±ï¸ | DuraÃ§Ã£o/Performance | INFO |
| â„¹ï¸ | InformaÃ§Ã£o detalhada | DEBUG |
| ðŸ” | Busca/Query | DEBUG |
| ðŸ’¾ | OperaÃ§Ã£o de dados/DB | DEBUG |
| ðŸŒ | Chamada HTTP/API externa | DEBUG |

**Rationale**: Emojis melhoram scan visual em logs extensos, especialmente Ãºtil em desenvolvimento e debugging. Em produÃ§Ã£o, logs estruturados JSON permitem filtragem programÃ¡tica.

### 8.2 MÃ©tricas (RED/USE/SLI)

**8.2.1 Metodologias de mÃ©tricas**
- **RED (Request-based)**: Rate (req/s), Errors (%), Duration (latÃªncia p50/p95/p99).
- **USE (Resource-based)**: Utilization (%), Saturation (queue depth), Errors (count).
- **SLI/SLO**: Service Level Indicators e Objectives para medir confiabilidade.

**8.2.2 MÃ©tricas obrigatÃ³rias por camada**
- **API/HTTP**: request rate, response time, error rate, status codes.
- **Database**: query time, connection pool usage, slow queries, deadlocks.
- **Cache**: hit rate, miss rate, eviction rate, memory usage.
- **Business**: conversÃµes, transaÃ§Ãµes, usuÃ¡rios ativos, revenue impact.

**8.2.3 ImplementaÃ§Ã£o com Prometheus**
```ts
// Node.js com prom-client
import { register, Counter, Histogram, Gauge } from 'prom-client';

// MÃ©tricas RED para HTTP
const httpRequestsTotal = new Counter({
  name: 'http_requests_total',
  help: 'Total HTTP requests',
  labelNames: ['method', 'route', 'status_code']
});

const httpRequestDuration = new Histogram({
  name: 'http_request_duration_seconds',
  help: 'HTTP request duration',
  labelNames: ['method', 'route'],
  buckets: [0.1, 0.5, 1, 2, 5]
});

// MÃ©tricas de negÃ³cio
const activeUsers = new Gauge({
  name: 'active_users_total',
  help: 'Currently active users'
});

// Middleware para coleta automÃ¡tica
function metricsMiddleware(req: Request, res: Response, next: NextFunction) {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = (Date.now() - start) / 1000;
    httpRequestsTotal.inc({ 
      method: req.method, 
      route: req.route?.path || 'unknown', 
      status_code: res.statusCode 
    });
    httpRequestDuration.observe({ 
      method: req.method, 
      route: req.route?.path || 'unknown' 
    }, duration);
  });
  
  next();
}
```

### 8.3 Tracing distribuÃ­do

**8.3.1 OpenTelemetry setup**
- **PropagaÃ§Ã£o de contexto**: trace ID e span ID atravÃ©s de serviÃ§os.
- **Spans crÃ­ticos**: operaÃ§Ãµes de I/O, chamadas de API, queries de banco.
- **Sampling**: 100% em desenvolvimento, 1-10% em produÃ§Ã£o (ajustar conforme volume).

**8.3.2 ImplementaÃ§Ã£o**
```ts
import { trace, context, SpanStatusCode } from '@opentelemetry/api';
import { NodeSDK } from '@opentelemetry/sdk-node';
import { JaegerExporter } from '@opentelemetry/exporter-jaeger';

// ConfiguraÃ§Ã£o do SDK
const sdk = new NodeSDK({
  traceExporter: new JaegerExporter({
    endpoint: process.env.JAEGER_ENDPOINT || 'http://localhost:14268/api/traces'
  }),
  serviceName: process.env.SERVICE_NAME || 'unknown-service'
});

sdk.start();

// Uso em operaÃ§Ãµes crÃ­ticas
const tracer = trace.getTracer('yourproject');

async function processOrder(orderId: string) {
  const span = tracer.startSpan('process_order', {
    attributes: { 'order.id': orderId }
  });
  
  try {
    // OperaÃ§Ã£o crÃ­tica
    const order = await getOrder(orderId);
    span.setAttributes({ 'order.amount': order.amount });
    
    const result = await processPayment(order);
    span.setStatus({ code: SpanStatusCode.OK });
    return result;
  } catch (error) {
    span.recordException(error as Error);
    span.setStatus({ code: SpanStatusCode.ERROR, message: (error as Error).message });
    throw error;
  } finally {
    span.end();
  }
}
```

### 8.4 Dashboards e alertas

**8.4.1 Tipos de dashboards**
- **Executive**: KPIs de negÃ³cio, SLOs, revenue impact, user satisfaction.
- **Operational**: RED/USE metrics, error rates, performance trends.
- **Infrastructure**: CPU, memory, disk, network por serviÃ§o/pod.
- **Security**: tentativas de login, rate limiting, anomalias de acesso.

**8.4.2 Alertas inteligentes**
- **MultinÃ­vel**: INFO (FYI), WARN (investigar), CRITICAL (aÃ§Ã£o imediata).
- **Anti-fatigue**: agrupamento por janela de tempo, supressÃ£o de duplicatas.
- **Runbooks**: cada alerta deve ter procedimento de resoluÃ§Ã£o documentado.

**8.4.3 Exemplo de configuraÃ§Ã£o Grafana + Prometheus**
```yaml
# prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "alert_rules.yml"

scrape_configs:
  - job_name: 'yourproject-api'
    static_configs:
      - targets: ['localhost:3000']
    metrics_path: '/metrics'
    scrape_interval: 5s

alerting:
  alertmanagers:
    - static_configs:
        - targets: ['localhost:9093']
```

```yaml
# alert_rules.yml
groups:
  - name: yourproject.rules
    rules:
      - alert: HighErrorRate
        expr: rate(http_requests_total{status_code=~"5.."}[5m]) > 0.1
        for: 2m
        labels:
          severity: critical
        annotations:
          summary: "High error rate detected"
          description: "Error rate is {{ $value }} errors per second"
          runbook_url: "https://wiki.company.com/runbooks/high-error-rate"
      
      - alert: HighLatency
        expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > 2
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High latency detected"
          description: "95th percentile latency is {{ $value }}s"
```

### 8.5 CorrelaÃ§Ã£o e troubleshooting

**8.5.1 Correlation ID**
- **GeraÃ§Ã£o**: UUID v4 no ponto de entrada (API Gateway/Load Balancer).
- **PropagaÃ§Ã£o**: header `X-Correlation-ID` em todas as chamadas internas.
- **Logging**: incluir em todos os logs para rastreabilidade fim-a-fim.

**8.5.2 Distributed tracing correlation**
- **Trace ID**: identificador Ãºnico para toda a transaÃ§Ã£o.
- **Span ID**: identificador Ãºnico para cada operaÃ§Ã£o dentro da transaÃ§Ã£o.
- **Baggage**: metadados propagados atravÃ©s de spans (usar com moderaÃ§Ã£o).

### 8.6 Checklist de implementaÃ§Ã£o
- [ ] Logs estruturados em JSON com metadados obrigatÃ³rios (ver [SeÃ§Ã£o 1 - Production-First](#1-princÃ­pios-productionfirst-obrigatÃ³rios))
- [ ] MÃ©tricas RED/USE expostas para Prometheus
- [ ] Tracing distribuÃ­do com OpenTelemetry
- [ ] Dashboards por audiÃªncia (exec, ops, infra, security)
- [ ] Alertas com runbooks e anti-fatigue (ver [SeÃ§Ã£o 15 - GestÃ£o de Incidentes](#15-gestÃ£o-de-incidentes-e-postmortem))
- [ ] Correlation ID em todas as transaÃ§Ãµes (ver [SeÃ§Ã£o 61 - Taxonomia de Erros](#61-taxonomia-de-erros-e-correlaÃ§Ã£o))
- [ ] SLIs/SLOs definidos e monitorados (ver [SeÃ§Ã£o 14 - SLO/SLI/SLA](#14-sloslisl-e-orÃ§amento-de-erros))
- [ ] RetenÃ§Ã£o de dados configurada (logs 30d, mÃ©tricas 1y, traces 7d)
- [ ] Testes de observabilidade em CI/CD (ver [SeÃ§Ã£o 6 - Testes](#6-testes-unificados-unit--integration--e2e--nfr))
- [ ] IntegraÃ§Ã£o com ferramentas de performance (ver [SeÃ§Ã£o 19 - Performance](#19-performance-e-caching))

## 9) SeguranÃ§a (OWASP Top 10 + prÃ¡ticas)
<!-- tags: security, owasp, authentication, authorization, encryption -->
<!-- category: security -->
<!-- priority: critical -->
<!-- audience: all-developers, security-engineers -->
- **Controle de acesso**: autorizaÃ§Ã£o por funÃ§Ã£o/escopo; princÃ­pio do menor privilÃ©gio.
- **Criptografia**: TLS 1.2+; dados sensÃ­veis em repouso (KMS/Vault); rotaÃ§Ã£o de chaves.
- **InjeÃ§Ã£o**: ORMs/parametrizaÃ§Ã£o; nunca concatenar SQL; validaÃ§Ã£o de inputs.
- **ConfiguraÃ§Ã£o segura**: headers (CSP, HSTS, XFO, XSS), CORS restrito, cookies `HttpOnly/Secure` (ver [SeÃ§Ã£o 34 - CORS e Headers](#34-cors-e-headers-de-seguranÃ§a)).
- **Componentes vulnerÃ¡veis**: SCA em pipeline; CVEs crÃ­ticos bloqueiam deploy (ver [SeÃ§Ã£o 7 - CI/CD](#7-cicd-e-deploy)).
- **AutenticaÃ§Ã£o**: MFA/2FA quando aplicÃ¡vel; proteÃ§Ã£o contra brute force (rate limit/lockout).
- **SeguranÃ§a avanÃ§ada**: consulte [SeÃ§Ã£o 20 - SeguranÃ§a AvanÃ§ada](#20-seguranÃ§a-avanÃ§ada) para prÃ¡ticas especÃ­ficas.
- **Dados e privacidade**: ver [SeÃ§Ã£o 17 - LGPD/GDPR](#17-dados-privacidade-e-lgpdgdpr) para compliance.

Checklist seguranÃ§a rÃ¡pida
- [ ] Inputs saneados e validados
- [ ] Secrets fora do cÃ³digo (env/secret manager)
- [ ] TLS/headers/hardening aplicados
- [ ] Rate limit e detecÃ§Ã£o de abuso
- [ ] Scans automÃ¡ticos (SCA/DAST) e correÃ§Ãµes

## 10) Frontend â€“ PadrÃµes Gerais
**Nota**: Para padrÃµes especÃ­ficos de React/Angular, consulte [SeÃ§Ã£o 21 - Frontend EspecÃ­fico](#21-frontend--seÃ§Ãµes-especÃ­ficas).

10.1 Arquitetura
- Rotas lazy; ErrorBoundary/Suspense (ou equivalentes) para quedas e carregamentos.
- Split por features; colocation de componentes/hooks/estilos.

10.2 Estado
- Hooks/signals/observables; memos para valores derivados; evitar duplicaÃ§Ã£o de estado.

10.3 FormulÃ¡rios e validaÃ§Ã£o
- RHF/Formik/etc + Zod/Yup; mensagens consistentes; mÃ¡scaras quando necessÃ¡rio.

10.4 Acessibilidade (A11y)
- SemÃ¢ntica (landmarks/headings), `label/htmlFor`, foco visÃ­vel, navegaÃ§Ã£o por teclado, contrastes.

10.5 Performance
- MemoizaÃ§Ã£o criteriosa, virtualizaÃ§Ã£o (listas grandes), imagens otimizadas, code splitting (ver [SeÃ§Ã£o 19 - Performance](#19-performance-e-caching)).

10.6 Estilos
- Tokens (CSS vars), Sass modular, utilitÃ¡rios (`nx-stack-*`, `nx-row-*`), resets e temas via dataâ€‘attributes.
- **Abordagem hÃ­brida**: Para projetos modernos, consulte [SeÃ§Ã£o 74 - Tailwind CSS + SASS](#74-tailwind-css--sass--abordagem-hÃ­brida) sobre integraÃ§Ã£o Tailwind CSS + SASS.
- **PreservaÃ§Ã£o visual**: ver [SeÃ§Ã£o 36 - PIV](#36-preservaÃ§Ã£o-de-identidade-visual-piv--guia-definitivo) para manter consistÃªncia de marca.

## 11) ModernizaÃ§Ã£o de Legacy
- **InventÃ¡rio completo**: cÃ³digo, assets, integraÃ§Ãµes, jobs, configs, bancos.
- **PreservaÃ§Ã£o de identidade visual/UX**; modernizar implementaÃ§Ã£o tÃ©cnica (ver [SeÃ§Ã£o 36 - PIV](#36-preservaÃ§Ã£o-de-identidade-visual-piv--guia-definitivo)).
- **EstratÃ©gia incremental**: priorize alto valor/baixo risco; feature flags e paralelizaÃ§Ã£o (ver [SeÃ§Ã£o 16 - Feature Flags](#16-change-management-e-feature-flags)).
- **KPIs de modernizaÃ§Ã£o**: dÃ­vida tÃ©cnica, custo de manutenÃ§Ã£o, performance, seguranÃ§a.
- **EstratÃ©gia completa**: consulte [SeÃ§Ã£o 37 - ModernizaÃ§Ã£o de Legado](#37-modernizaÃ§Ã£o-de-legado--estratÃ©gia-completa) para abordagem detalhada.
- **DÃ©bito tÃ©cnico**: ver [SeÃ§Ã£o 27 - DÃ©bito TÃ©cnico](#27-dÃ©bito-tÃ©cnico-e-triagem) para gestÃ£o sistemÃ¡tica.

### 11.1 Processo de AnÃ¡lise Comparativa
- **AnÃ¡lise exaustiva obrigatÃ³ria**: mapear 100% dos componentes antes de iniciar implementaÃ§Ã£o.
- **Gaps crÃ­ticos identificados**: autenticaÃ§Ã£o completa, jobs complexos, cache distribuÃ­do, notificaÃ§Ãµes.
- **Plano de migraÃ§Ã£o em fases**: CrÃ­tico (imediato) â†’ Alto impacto (1-2 sprints) â†’ MÃ©dio impacto (2-3 sprints) â†’ Melhorias (3-4 sprints).
- **Riscos mapeados**: perda de funcionalidade, seguranÃ§a incompleta, performance degradada.
- **MÃ©tricas de sucesso**: 100% funcionalidades migradas, performance igual/superior, zero downtime.

### 11.2 Checklist ExecutÃ¡vel de InventÃ¡rio
- **Comandos automatizados**: use `find` e `grep` para inventÃ¡rio sistemÃ¡tico de controllers, services, jobs, componentes.
- **EstatÃ­sticas obrigatÃ³rias**: contar arquivos de cÃ³digo, configuraÃ§Ã£o, frontend por categoria.
- **AnÃ¡lise de padrÃµes crÃ­ticos**: autenticaÃ§Ã£o, jobs background, cache, integraÃ§Ãµes externas, notificaÃ§Ãµes.
- **DocumentaÃ§Ã£o de gaps**: cada componente nÃ£o migrado deve ter anÃ¡lise completa de impacto.
- **ValidaÃ§Ã£o cruzada**: confirmar achados por mÃºltiplas fontes antes de prosseguir.

#### **11.2.5 ValidaÃ§Ã£o de Completude (OBRIGATÃ“RIO)**
- [ ] AnÃ¡lise de completude executada conforme SeÃ§Ã£o 11.5
- [ ] RelatÃ³rio de gaps documentado e aprovado
- [ ] Teste de independÃªncia operacional realizado
- [ ] Roadmap de migraÃ§Ã£o definido para itens pendentes

### 11.3 Regras de Completude
- **PrincÃ­pio fundamental**: 0% de componentes esquecidos atravÃ©s de anÃ¡lise exaustiva.
- **InventÃ¡rio por camadas**: Backend (controllers, services, jobs), Frontend (components, guards, pipes), Infraestrutura (cache, logging, config), IntegraÃ§Ãµes (APIs, webhooks, notificaÃ§Ãµes).
- **Busca sistemÃ¡tica obrigatÃ³ria**: executar comandos especÃ­ficos para cada padrÃ£o (interfaces, DI, jobs, middlewares, validaÃ§Ãµes).
- **AnÃ¡lise de dependÃªncias**: mapear cross-references, componentes Ã³rfÃ£os, registros de DI/IoC.
- **Gate de completude**: todos os itens do checklist devem estar âœ… antes de considerar anÃ¡lise completa.

### 11.4 Processo Integrado e Gates de Qualidade
- **Fluxo em 3 fases**: PreparaÃ§Ã£o (1-2 dias) â†’ AnÃ¡lise Profunda (3-5 dias) â†’ ValidaÃ§Ã£o e AprovaÃ§Ã£o (1-2 dias).
- **Artefatos obrigatÃ³rios**: anÃ¡lise comparativa, evidÃªncias tÃ©cnicas, documentaÃ§Ã£o de gaps, aprovaÃ§Ãµes formais.
- **CritÃ©rios de qualidade**: Completude (100% obrigatÃ³rio), PrecisÃ£o (validaÃ§Ã£o cruzada), Rastreabilidade (gaps linkados ao cÃ³digo).
- **Gates obrigatÃ³rios**: Gate 1 (InventÃ¡rio Completo), Gate 2 (Gaps Documentados), Gate 3 (AprovaÃ§Ãµes Coletadas), Gate 4 (Completude Validation).
- **Sign-offs necessÃ¡rios**: aprovaÃ§Ã£o tÃ©cnica (arquiteto), validaÃ§Ã£o de negÃ³cio (PO), estratÃ©gia de testes (QA).

#### **Gate 4: Completude Validation**
**CritÃ©rio:** AnÃ¡lise de completude obrigatÃ³ria antes de declarar migraÃ§Ã£o funcional
**Artefatos:** RelatÃ³rio de completude, gap analysis, teste de independÃªncia
**AprovaÃ§Ã£o:** Arquiteto de SoluÃ§Ã£o + Tech Lead
**Bloqueio:** MigraÃ§Ã£o nÃ£o pode ser declarada funcional sem este gate

### 11.4.1 EstratÃ©gias de PreservaÃ§Ã£o Funcional
**PrincÃ­pio fundamental**: Paridade funcional 100% (AS-IS) antes de qualquer evoluÃ§Ã£o.

**Controles de paridade obrigatÃ³rios**:
- **InventÃ¡rio funcional completo**: mapear todas as funcionalidades, regras de negÃ³cio, validaÃ§Ãµes e integraÃ§Ãµes
- **MigraÃ§Ã£o incremental**: implementar por mÃ³dulos/features com validaÃ§Ã£o contÃ­nua
- **ValidaÃ§Ã£o rigorosa**: testes automatizados comparando comportamento legacy vs moderno
- **PreservaÃ§Ã£o de UX/UI**: manter experiÃªncia do usuÃ¡rio idÃªntica durante migraÃ§Ã£o
- **Rollback garantido**: capacidade de reverter para sistema legacy a qualquer momento

**Ferramentas de validaÃ§Ã£o**:
```bash
# ComparaÃ§Ã£o de endpoints
curl -s legacy.com/api/users | jq . > legacy_response.json
curl -s modern.com/api/users | jq . > modern_response.json
diff legacy_response.json modern_response.json

# ValidaÃ§Ã£o de performance
ab -n 1000 -c 10 legacy.com/api/endpoint
ab -n 1000 -c 10 modern.com/api/endpoint
```

**MÃ©tricas de preservaÃ§Ã£o**:
- **Funcionalidade**: 100% das features migradas sem perda
- **Performance**: tempo de resposta â‰¤ sistema legacy
- **Disponibilidade**: uptime â‰¥ 99.9% durante migraÃ§Ã£o
- **Dados**: 0% de perda ou corrupÃ§Ã£o de dados
- **IntegraÃ§Ã£o**: 100% das integraÃ§Ãµes funcionando

### 11.5 AnÃ¡lise de Completude ObrigatÃ³ria em MigraÃ§Ãµes
<!-- tags: migration, completeness-analysis, gap-analysis, legacy-modernization -->
<!-- category: migration-governance -->
<!-- priority: critical -->
<!-- audience: architects, tech-leads, developers -->

**PrincÃ­pios fundamentais:**
- **AnÃ¡lise ANTES da declaraÃ§Ã£o**: Nenhuma migraÃ§Ã£o pode ser declarada "funcional" ou "completa" sem anÃ¡lise de completude detalhada.
- **InventÃ¡rio obrigatÃ³rio**: Mapeamento completo de mÃ³dulos/funcionalidades legado vs moderno.
- **Teste de independÃªncia**: Sistema moderno deve ser testado sem dependÃªncia do legado.
- **DocumentaÃ§Ã£o de gaps**: Todos os mÃ³dulos nÃ£o migrados devem ser documentados com impacto de negÃ³cio.

#### **11.5.1 Checklist de Completude ObrigatÃ³rio**

**ANTES de declarar qualquer migraÃ§Ã£o como "funcional":**

**ðŸ“Š InventÃ¡rio Completo**
- [ ] Lista completa de mÃ³dulos/serviÃ§os do sistema legado
- [ ] Lista completa de mÃ³dulos/serviÃ§os do sistema moderno  
- [ ] Mapeamento 1:1 entre legado e moderno
- [ ] IdentificaÃ§Ã£o de mÃ³dulos nÃ£o migrados com justificativa

**ðŸ” Gap Analysis Detalhado**
- [ ] AnÃ¡lise funcional por mÃ³dulo (CRUD, regras de negÃ³cio, validaÃ§Ãµes)
- [ ] AnÃ¡lise de integraÃ§Ãµes externas (APIs, sistemas terceiros)
- [ ] AnÃ¡lise de jobs/processamento em background
- [ ] AnÃ¡lise de configuraÃ§Ãµes e parametrizaÃ§Ãµes

**ðŸ§ª Teste de IndependÃªncia Operacional**
- [ ] Sistema moderno funciona 100% sem o legado
- [ ] Todos os fluxos crÃ­ticos de negÃ³cio funcionam
- [ ] IntegraÃ§Ãµes externas funcionam via sistema moderno
- [ ] Jobs crÃ­ticos executam no sistema moderno

**ðŸ“‹ DocumentaÃ§Ã£o de Impacto**
- [ ] Lista de funcionalidades nÃ£o migradas com impacto de negÃ³cio
- [ ] Roadmap de migraÃ§Ã£o para mÃ³dulos restantes
- [ ] Plano de contingÃªncia/rollback
- [ ] MÃ©tricas de sucesso definidas

#### **11.5.2 Processo de ValidaÃ§Ã£o**

**Etapa 1: Descoberta AutomÃ¡tica**
```bash
# Exemplo de comandos para anÃ¡lise
find legacy/src -name "*.cs" -type f | grep -E "(Controller|Service|Job)" | wc -l
find modern/src -name "*.cs" -type f | grep -E "(Controller|Service|Job)" | wc -l

# AnÃ¡lise de endpoints
grep -r "Route\|HttpGet\|HttpPost" legacy/src --include="*.cs" | wc -l
grep -r "Route\|HttpGet\|HttpPost" modern/src --include="*.cs" | wc -l
```

**Etapa 2: AnÃ¡lise SemÃ¢ntica**
- Usar ferramentas de busca semÃ¢ntica para identificar funcionalidades
- Comparar estruturas de pastas e namespaces
- Analisar dependÃªncias e referÃªncias entre mÃ³dulos

**Etapa 3: ValidaÃ§Ã£o Funcional**
- Testes de integraÃ§Ã£o end-to-end
- ValidaÃ§Ã£o de regras de negÃ³cio crÃ­ticas
- Teste de performance comparativa

**Etapa 4: DocumentaÃ§Ã£o ObrigatÃ³ria**
- RelatÃ³rio de completude com percentuais
- Lista detalhada de gaps identificados
- Roadmap de migraÃ§Ã£o para itens restantes

#### **11.5.3 Templates ObrigatÃ³rios**

**Template: RelatÃ³rio de Completude**
```markdown
# RelatÃ³rio de Completude - [Sistema/MÃ³dulo]

## Resumo Executivo
- **Percentual Migrado:** X% (Y de Z mÃ³dulos)
- **Status Operacional:** [Independente/Dependente do Legado]
- **MÃ³dulos CrÃ­ticos Pendentes:** [Lista]

## InventÃ¡rio Detalhado
### MÃ³dulos Migrados (X)
- [Lista com status funcional]

### MÃ³dulos NÃƒO Migrados (Y)
- [Lista com impacto de negÃ³cio e prioridade]

## AnÃ¡lise de Impacto
### Funcionalidades CrÃ­ticas Pendentes
- [Lista com impacto operacional]

### IntegraÃ§Ãµes Pendentes
- [Lista com sistemas afetados]

## Roadmap de MigraÃ§Ã£o
### Fase 1 - CrÃ­tico (prazo)
### Fase 2 - Importante (prazo)
### Fase 3 - Complementar (prazo)

## Riscos e MitigaÃ§Ãµes
## MÃ©tricas de Sucesso
```

**Template: Gap Analysis**
```markdown
# Gap Analysis - [MÃ³dulo/Sistema]

## Escopo da AnÃ¡lise
## Metodologia Utilizada
## Funcionalidades Mapeadas
### Legado: [Lista detalhada]
### Moderno: [Lista detalhada]
### Gaps Identificados: [Lista com impacto]

## Regras de NegÃ³cio
### Migradas: [Lista]
### Pendentes: [Lista com complexidade]

## IntegraÃ§Ãµes
### Migradas: [Lista]
### Pendentes: [Lista com dependÃªncias]

## RecomendaÃ§Ãµes
### Prioridade Alta: [Lista]
### Prioridade MÃ©dia: [Lista]
### Prioridade Baixa: [Lista]
```

#### **11.5.4 CritÃ©rios de AprovaÃ§Ã£o**

**Para declarar migraÃ§Ã£o como "FUNCIONAL":**
- âœ… Completude â‰¥ 95% dos mÃ³dulos crÃ­ticos
- âœ… Sistema opera independentemente do legado
- âœ… Todos os fluxos de negÃ³cio principais funcionam
- âœ… Performance igual ou superior ao legado

**Para declarar migraÃ§Ã£o como "COMPLETA":**
- âœ… Completude = 100% de todos os mÃ³dulos
- âœ… Sistema legado pode ser descomissionado
- âœ… DocumentaÃ§Ã£o completa e atualizada
- âœ… Equipe treinada no novo sistema

#### **11.5.5 Responsabilidades**

**Arquiteto de SoluÃ§Ã£o:**
- Definir escopo da anÃ¡lise de completude
- Validar metodologia e critÃ©rios
- Aprovar relatÃ³rios de completude

**Tech Lead:**
- Executar anÃ¡lise detalhada de gaps
- Coordenar testes de independÃªncia
- Manter documentaÃ§Ã£o atualizada

**Desenvolvedor:**
- Implementar checklist de completude
- Documentar gaps identificados durante desenvolvimento
- Executar testes funcionais comparativos

#### **11.5.6 Ferramentas Recomendadas**

**AnÃ¡lise AutomÃ¡tica:**
- Scripts de comparaÃ§Ã£o de estruturas
- Ferramentas de anÃ¡lise estÃ¡tica de cÃ³digo
- Comparadores de APIs (Swagger diff)

**DocumentaÃ§Ã£o:**
- Templates padronizados (Markdown)
- Diagramas de arquitetura (Mermaid)
- Dashboards de progresso

**ValidaÃ§Ã£o:**
- Testes de integraÃ§Ã£o automatizados
- Ferramentas de performance testing
- Monitoramento comparativo

### 11.6 Migration Analysis Automation
**Objetivo**: Automatizar anÃ¡lise de progresso e geraÃ§Ã£o de relatÃ³rios de migraÃ§Ã£o.

**Scripts padrÃ£o obrigatÃ³rios**:
```bash
#!/bin/bash
# migration-inventory.sh - AnÃ¡lise automatizada de componentes

echo "=== INVENTÃRIO LEGACY ==="
echo "Controllers: $(find ./legacy -name '*.cs' -path '*/Controllers/*' | wc -l)"
echo "Services: $(find ./legacy -name '*.cs' -path '*/Services/*' | wc -l)"
echo "Entities: $(find ./legacy -name '*.cs' -path '*/Entities/*' | wc -l)"
echo "Views: $(find ./legacy -name '*.cshtml' | wc -l)"

echo "\n=== INVENTÃRIO MODERNO ==="
echo "Controllers: $(find ./modern -name '*.cs' -path '*/Controllers/*' | wc -l)"
echo "Components: $(find ./modern -name '*.component.ts' | wc -l)"
echo "Services: $(find ./modern -name '*.service.ts' | wc -l)"
echo "Guards: $(find ./modern -name '*.guard.ts' | wc -l)"

# Gap Analysis Automatizado
./scripts/migration-gap-analysis.sh
./scripts/generate-migration-report.sh
```

**Ferramentas avanÃ§adas de automaÃ§Ã£o**:
```bash
#!/bin/bash
# migration-progress-tracker.sh - Tracking automatizado de progresso

# AnÃ¡lise de cobertura de migraÃ§Ã£o
echo "=== ANÃLISE DE COBERTURA ==="
legacy_endpoints=$(grep -r "@RequestMapping\|@GetMapping\|@PostMapping" ./legacy | wc -l)
modern_endpoints=$(grep -r "@GetMapping\|@PostMapping\|@PutMapping" ./modern | wc -l)
coverage=$((modern_endpoints * 100 / legacy_endpoints))
echo "Cobertura de endpoints: $coverage% ($modern_endpoints/$legacy_endpoints)"

# AnÃ¡lise de complexidade
echo "\n=== ANÃLISE DE COMPLEXIDADE ==="
find ./legacy -name "*.cs" -exec wc -l {} + | sort -n | tail -10
echo "\nArquivos mais complexos identificados para priorizaÃ§Ã£o"

# DetecÃ§Ã£o de dependÃªncias crÃ­ticas
echo "\n=== DEPENDÃŠNCIAS CRÃTICAS ==="
grep -r "@Autowired\|@Inject" ./legacy | cut -d: -f1 | sort | uniq -c | sort -nr

# GeraÃ§Ã£o de relatÃ³rio JSON para dashboards
cat > migration-progress.json << EOF
{
  "timestamp": "$(date -Iseconds)",
  "legacy_components": $legacy_endpoints,
  "modern_components": $modern_endpoints,
  "coverage_percentage": $coverage,
  "risk_level": "$([ $coverage -lt 50 ] && echo 'HIGH' || echo 'MEDIUM')"
}
EOF
```

**Dashboard de progresso automatizado**:
```typescript
// migration-dashboard.ts - Dashboard em tempo real
interface MigrationMetrics {
  timestamp: string;
  legacyComponents: number;
  modernComponents: number;
  coveragePercentage: number;
  riskLevel: 'LOW' | 'MEDIUM' | 'HIGH';
  blockers: string[];
}

class MigrationTracker {
  async generateReport(): Promise<MigrationMetrics> {
    const legacyCount = await this.countLegacyComponents();
    const modernCount = await this.countModernComponents();
    const coverage = (modernCount / legacyCount) * 100;
    
    return {
      timestamp: new Date().toISOString(),
      legacyComponents: legacyCount,
      modernComponents: modernCount,
      coveragePercentage: Math.round(coverage),
      riskLevel: coverage < 50 ? 'HIGH' : coverage < 80 ? 'MEDIUM' : 'LOW',
      blockers: await this.identifyBlockers()
    };
  }
  
  async identifyBlockers(): Promise<string[]> {
    // AnÃ¡lise automatizada de bloqueadores
    const blockers = [];
    
    // Verificar dependÃªncias nÃ£o migradas
    const unmigrated = await this.findUnmigratedDependencies();
    if (unmigrated.length > 0) {
      blockers.push(`${unmigrated.length} dependÃªncias crÃ­ticas nÃ£o migradas`);
    }
    
    // Verificar testes faltantes
    const testCoverage = await this.calculateTestCoverage();
    if (testCoverage < 80) {
      blockers.push(`Cobertura de testes baixa: ${testCoverage}%`);
    }
    
    return blockers;
  }
}
```

**Estrutura de automaÃ§Ã£o obrigatÃ³ria**:
```
/migration-artifacts/
  /scripts/
    - inventory-legacy.sh
    - inventory-modern.sh
    - gap-analysis.sh
    - progress-report.sh
    - risk-assessment.sh
  /templates/
    - migration-status-report.md
    - module-analysis.md
    - risk-assessment.md
  /automation/
    - migration-tracker.ts
    - quality-gates.yml
    - progress-dashboard.html
```

### 11.7 Database-First Legacy Preservation
**Contexto**: EstratÃ©gia especÃ­fica para preservaÃ§Ã£o total de bases legadas durante modernizaÃ§Ã£o, sem migraÃ§Ã£o de dados.

**11.7.1 PrincÃ­pios fundamentais**
- **NUNCA migrar dados**: Base legada permanece como fonte de verdade
- **Zero alteraÃ§Ãµes no schema**: Nenhuma modificaÃ§Ã£o estrutural na base existente
- **Compatibilidade 100%**: Sistema moderno consome dados exatamente como estÃ£o
- **Database-First obrigatÃ³rio**: Gerar modelos a partir do schema existente

**11.7.2 EstratÃ©gia de acesso Database-First**
```csharp
// REGRA: Sempre usar Entity Framework Database-First
// Gerar modelos a partir do schema existente
Scaffold-DbContext "ConnectionString" Microsoft.EntityFrameworkCore.SqlServer -OutputDir Models/Legacy -Force

// REGRA: Modelos legados sÃ£o imutÃ¡veis
[Table("AirportsWeatherMinimums")] // Nome exato da tabela legada
public partial class LegacyAirportsWeatherMinimum
{
    // Propriedades geradas automaticamente - NÃƒO MODIFICAR
    public int Id { get; set; }
    public string AirportICAO { get; set; }
    public string AirportIATA { get; set; }
    public decimal? VisibilityMinimum { get; set; }
    public decimal? CeilingMinimum { get; set; }
    // ... outras propriedades geradas
}
```

**11.6.3 Nomenclatura obrigatÃ³ria**
- **Modelos legados**: Prefixo `Legacy` + nome original da entidade
- **Adapters**: Sufixo `Adapter` (ex: `AirportWeatherMinimumAdapter`)
- **Repositories hÃ­bridos**: Prefixo `Hybrid` + nome da entidade + `Repository`
- **Controllers hÃ­bridos**: Prefixo `Hybrid` + nome da entidade + `Controller`

**11.6.4 Anti-Corruption Layer (ACL) obrigatÃ³rio**
```csharp
public interface I{Entity}Adapter
{
    // ConversÃ£o legado â†’ moderno
    Modern{Entity} AdaptFromLegacy(Legacy{Entity} legacy);
    
    // ConversÃ£o moderno â†’ legado (para persistÃªncia)
    Legacy{Entity} AdaptToLegacy(Modern{Entity} modern);
    
    // ValidaÃ§Ã£o de integridade
    ValidationResult ValidateAdaptation(Legacy{Entity} legacy, Modern{Entity} modern);
    
    // Backup para auditoria
    string SerializeForBackup(Legacy{Entity} legacy);
}

// ImplementaÃ§Ã£o com preservaÃ§Ã£o de dados originais
public class AirportWeatherMinimumAdapter : I{Entity}Adapter
{
    public ModernAirportWeatherMinimum AdaptFromLegacy(LegacyAirportsWeatherMinimum legacy)
    {
        return new ModernAirportWeatherMinimum
        {
            // Preservar dados originais
            LegacyId = legacy.Id,
            LegacyData = JsonSerializer.Serialize(legacy),
            
            // Campos adaptados
            AirportCode = legacy.AirportICAO ?? legacy.AirportIATA,
            WeatherMinimums = AdaptWeatherData(legacy),
            
            // Metadados de adaptaÃ§Ã£o
            AdaptedAt = DateTime.UtcNow,
            AdaptationVersion = "1.0"
        };
    }
}
```

**11.6.5 Regras de mapeamento**
- **Campos obrigatÃ³rios**: Todos os campos legados devem ser mapeados, mesmo que nulos
- **PreservaÃ§Ã£o de tipos**: Manter tipos originais quando possÃ­vel
- **Campos calculados**: Criar propriedades calculadas no modelo moderno, nÃ£o alterar legado
- **Relacionamentos**: Preservar FKs legadas, criar navegaÃ§Ã£o no modelo moderno
- **Auditoria**: Sempre preservar dados originais + metadados de adaptaÃ§Ã£o

**11.6.6 PadrÃµes avanÃ§ados de ACL**
```csharp
// PADRÃƒO: Interface base reutilizÃ¡vel para todos os adapters
public abstract class BaseEntityAdapter<TLegacy, TModern> : IEntityAdapter<TLegacy, TModern>
    where TLegacy : class
    where TModern : class
{
    protected readonly ILogger<BaseEntityAdapter<TLegacy, TModern>> _logger;
    protected readonly IMetricsCollector _metrics;
    
    public virtual TModern AdaptFromLegacy(TLegacy legacy)
    {
        using var activity = _metrics.StartActivity("adaptation.from_legacy");
        
        try
        {
            // ValidaÃ§Ã£o de entrada
            if (!CanAdapt(legacy))
            {
                throw new AdaptationException($"Cannot adapt legacy entity: {typeof(TLegacy).Name}");
            }
            
            // AdaptaÃ§Ã£o especÃ­fica (implementada pela classe filha)
            var modern = DoAdaptFromLegacy(legacy);
            
            // ValidaÃ§Ã£o de saÃ­da
            var validation = ValidateAdaptation(legacy, modern);
            if (!validation.IsValid)
            {
                _logger.LogWarning("Adaptation validation failed: {Errors}", 
                    string.Join(", ", validation.Errors));
            }
            
            // MÃ©tricas
            _metrics.IncrementCounter("adaptation.success");
            
            return modern;
        }
        catch (Exception ex)
        {
            _metrics.IncrementCounter("adaptation.error");
            _logger.LogError(ex, "Failed to adapt legacy entity");
            throw;
        }
    }
    
    // MÃ©todo abstrato para implementaÃ§Ã£o especÃ­fica
    protected abstract TModern DoAdaptFromLegacy(TLegacy legacy);
    protected abstract TLegacy DoAdaptToLegacy(TModern modern);
}

// PADRÃƒO: Mapeamento com transformaÃ§Ã£o e validaÃ§Ã£o
public class WeatherMinimumAdapter : BaseEntityAdapter<LegacyWeatherMinimum, ModernWeatherMinimum>
{
    protected override ModernWeatherMinimum DoAdaptFromLegacy(LegacyWeatherMinimum legacy)
    {
        return new ModernWeatherMinimum
        {
            // TransformaÃ§Ã£o de unidades
            VisibilityMeters = ConvertVisibilityToMeters(legacy.VisibilityMiles),
            
            // NormalizaÃ§Ã£o de dados
            AirportCode = NormalizeAirportCode(legacy.AirportICAO, legacy.AirportIATA),
            
            // Enriquecimento com dados calculados
            WeatherCategory = CalculateWeatherCategory(legacy),
            
            // PreservaÃ§Ã£o do estado original
            OriginalValues = new Dictionary<string, object>
            {
                ["VisibilityMiles"] = legacy.VisibilityMiles,
                ["AirportICAO"] = legacy.AirportICAO,
                ["AirportIATA"] = legacy.AirportIATA
            },
            
            // Metadados obrigatÃ³rios
            LegacyId = legacy.Id,
            LegacyData = JsonSerializer.Serialize(legacy),
            AdaptedAt = DateTime.UtcNow,
            AdaptationVersion = "1.0"
        };
    }
}

// PADRÃƒO: ValidaÃ§Ã£o de integridade obrigatÃ³ria
public class DataIntegrityValidation
{
    public ValidationResult ValidateAdaptation(LegacyEntity legacy, ModernEntity modern)
    {
        var result = new ValidationResult();
        
        // ValidaÃ§Ã£o de campos obrigatÃ³rios
        if (legacy.Id != modern.LegacyId)
        {
            result.AddError("Legacy ID must be preserved");
        }
        
        if (string.IsNullOrEmpty(modern.LegacyData))
        {
            result.AddError("Legacy data backup is required");
        }
        
        // ValidaÃ§Ã£o de round-trip (ida e volta)
        var roundTripLegacy = AdaptToLegacy(modern);
        var roundTripResult = CompareEntities(legacy, roundTripLegacy);
        
        if (!roundTripResult.IsIdentical)
        {
            result.AddError("Round-trip validation failed");
        }
        
        return result;
    }
}
```

### 11.7 Migration Tracking Standards
**Objetivo**: Padronizar formato de relatÃ³rios e mÃ©tricas de progresso.

**Template obrigatÃ³rio - Migration Status Report**:
```markdown
# Migration Status Report - [Projeto] - [Data]

## ðŸ“Š MÃ©tricas Quantitativas
- **Backend Legacy:** X controllers, Y services, Z entities
- **Backend Moderno:** X controllers, Y services, Z entities
- **Frontend Legacy:** X views, Y scripts
- **Frontend Moderno:** X components, Y services, Z guards
- **Progresso Geral:** X% concluÃ­do (baseado em contagem de componentes)

## ðŸŽ¯ Status por MÃ³dulo
- âœ… **[MÃ³dulo A]:** Funcional (backend + frontend completos)
- ðŸŸ¡ **[MÃ³dulo B]:** Backend pronto, frontend em desenvolvimento
- ðŸ”´ **[MÃ³dulo C]:** NÃ£o iniciado - aguardando dependÃªncias

## ðŸš€ PrÃ³ximas Prioridades
1. **[MÃ³dulo]** - [Justificativa de prioridade] - [Prazo estimado]
2. **[MÃ³dulo]** - [Justificativa de prioridade] - [Prazo estimado]
3. **[MÃ³dulo]** - [Justificativa de prioridade] - [Prazo estimado]

## âš ï¸ Riscos e Bloqueadores
- **[Risco]** - Impacto: [Alto/MÃ©dio/Baixo] - MitigaÃ§Ã£o: [AÃ§Ã£o]
- **[Bloqueador]** - Owner: [ResponsÃ¡vel] - Prazo: [Data]

## ðŸ“ˆ MÃ©tricas de Qualidade
- **Cobertura de Testes:** X% (meta: >= 80%)
- **Performance:** X ms (meta: <= Y ms)
- **Bugs CrÃ­ticos:** X (meta: 0)
- **Debt TÃ©cnico:** X pontos (tendÃªncia: â†“)
```

**CadÃªncia de relatÃ³rios**:
- **Daily**: Status de bloqueadores (Slack/Teams)
- **Weekly**: RelatÃ³rio completo de progresso
- **Bi-weekly**: RevisÃ£o de riscos e replanejamento
- **Monthly**: ApresentaÃ§Ã£o executiva para stakeholders

### 11.7 Migration Quality Gates
**Objetivo**: Estabelecer gates automÃ¡ticos obrigatÃ³rios para cada fase da migraÃ§Ã£o.

**Gates obrigatÃ³rios por fase**:
```yaml
# quality-gates.yml - ConfiguraÃ§Ã£o de Gates AutomÃ¡ticos

Phase_1_Discovery:
  required_artifacts:
    - legacy_inventory_complete: true
    - modern_inventory_complete: true
    - gap_analysis_documented: true
    - migration_plan_approved: true
    - risk_assessment_complete: true
  metrics:
    - inventory_accuracy: ">= 95%"
    - stakeholder_approval: true

Phase_2_Implementation:
  required_tests:
    - unit_tests_coverage: ">= 80%"
    - integration_tests_passing: true
    - functional_parity_validated: true
    - performance_benchmarks_met: true
  quality_checks:
    - code_review_approved: true
    - security_scan_passed: true
    - accessibility_validated: true

Phase_3_Validation:
  acceptance_criteria:
    - user_acceptance_complete: true
    - rollback_plan_tested: true
    - monitoring_configured: true
    - documentation_updated: true
    - training_completed: true
  go_live_requirements:
    - stakeholder_signoff: true
    - support_team_ready: true
    - incident_response_plan: true
```

**AutomaÃ§Ã£o de gates**:
```bash
#!/bin/bash
# validate-migration-gate.sh

PHASE=$1
GATE_CONFIG="quality-gates.yml"

case $PHASE in
  "discovery")
    echo "Validating Discovery Gate..."
    # Verificar artefatos obrigatÃ³rios
    ;;
  "implementation")
    echo "Validating Implementation Gate..."
    # Executar testes e validaÃ§Ãµes
    ;;
  "validation")
    echo "Validating Go-Live Gate..."
    # Verificar critÃ©rios de aceitaÃ§Ã£o
    ;;
esac
```

### 11.9 Automated Compatibility Validation
**Objetivo**: Garantir compatibilidade funcional entre sistemas legados e modernos atravÃ©s de validaÃ§Ã£o automatizada.

**11.9.1 PrincÃ­pios fundamentais**
- **ValidaÃ§Ã£o contÃ­nua**: Testes de compatibilidade executados a cada build/deploy
- **Cobertura completa**: Validar APIs, dados, comportamentos e integraÃ§Ãµes
- **Feedback rÃ¡pido**: Falhas de compatibilidade detectadas em < 5 minutos
- **Rastreabilidade**: Logs detalhados de todas as validaÃ§Ãµes para auditoria

**11.9.2 Schema Validation Pipeline**
```typescript
// compatibility-validator.ts - Pipeline de validaÃ§Ã£o automatizada

interface ValidationConfig {
  legacyEndpoint: string;
  modernEndpoint: string;
  testCases: TestCase[];
  tolerances: ValidationTolerances;
  notifications: NotificationConfig;
}

interface ValidationTolerances {
  responseTimeDifferenceMs: number;
  numericPrecisionDigits: number;
  allowedMissingFields: string[];
  dateFormatVariations: string[];
}

class CompatibilityValidator {
  async validateEndpointCompatibility(config: ValidationConfig): Promise<ValidationResult> {
    const results: ValidationResult[] = [];
    
    for (const testCase of config.testCases) {
      // Executar requisiÃ§Ã£o no sistema legado
      const legacyResponse = await this.callLegacyEndpoint(
        config.legacyEndpoint, 
        testCase.request
      );
      
      // Executar requisiÃ§Ã£o no sistema moderno
      const modernResponse = await this.callModernEndpoint(
        config.modernEndpoint, 
        testCase.request
      );
      
      // Validar compatibilidade
      const validation = await this.compareResponses(
        legacyResponse, 
        modernResponse, 
        config.tolerances
      );
      
      results.push({
        testCase: testCase.name,
        status: validation.isCompatible ? 'PASS' : 'FAIL',
        differences: validation.differences,
        metrics: {
          legacyResponseTime: legacyResponse.responseTime,
          modernResponseTime: modernResponse.responseTime,
          dataDifferences: validation.differences.length
        }
      });
    }
    
    return this.aggregateResults(results);
  }
  
  private async compareResponses(
    legacy: ApiResponse, 
    modern: ApiResponse, 
    tolerances: ValidationTolerances
  ): Promise<ComparisonResult> {
    const differences: Difference[] = [];
    
    // ValidaÃ§Ã£o de schema
    const schemaDiff = this.validateSchema(legacy.data, modern.data);
    if (schemaDiff.length > 0) {
      differences.push(...schemaDiff);
    }
    
    // ValidaÃ§Ã£o de dados
    const dataDiff = this.validateDataEquivalence(
      legacy.data, 
      modern.data, 
      tolerances
    );
    if (dataDiff.length > 0) {
      differences.push(...dataDiff);
    }
    
    // ValidaÃ§Ã£o de performance
    const perfDiff = Math.abs(legacy.responseTime - modern.responseTime);
    if (perfDiff > tolerances.responseTimeDifferenceMs) {
      differences.push({
        type: 'performance',
        field: 'responseTime',
        legacy: legacy.responseTime,
        modern: modern.responseTime,
        difference: perfDiff
      });
    }
    
    return {
      isCompatible: differences.length === 0,
      differences
    };
  }
}

// ConfiguraÃ§Ã£o de pipeline CI/CD
// .github/workflows/compatibility-validation.yml
name: Compatibility Validation
on: [push, pull_request]

jobs:
  validate-compatibility:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Legacy Environment
        run: |
          docker-compose -f docker-compose.legacy.yml up -d
          
      - name: Setup Modern Environment  
        run: |
          docker-compose -f docker-compose.modern.yml up -d
          
      - name: Run Compatibility Tests
        run: |
          npm run test:compatibility
          
      - name: Generate Compatibility Report
        run: |
          npm run report:compatibility
          
      - name: Upload Results
        uses: actions/upload-artifact@v3
        with:
          name: compatibility-report
          path: reports/compatibility/
```

**11.9.3 Data Validation Patterns**
```csharp
// DataCompatibilityValidator.cs - ValidaÃ§Ã£o de dados

public class DataCompatibilityValidator
{
    private readonly ILogger<DataCompatibilityValidator> _logger;
    private readonly ValidationConfig _config;
    
    public async Task<ValidationResult> ValidateDataMigration(
        string legacyConnectionString, 
        string modernConnectionString,
        MigrationSpec spec)
    {
        var results = new List<TableValidationResult>();
        
        foreach (var table in spec.Tables)
        {
            // Contar registros
            var legacyCount = await CountRecords(legacyConnectionString, table.LegacyName);
            var modernCount = await CountRecords(modernConnectionString, table.ModernName);
            
            // Validar integridade referencial
            var integrityResult = await ValidateReferentialIntegrity(table);
            
            // Validar amostra de dados
            var sampleResult = await ValidateDataSample(table, spec.SampleSize);
            
            results.Add(new TableValidationResult
            {
                TableName = table.ModernName,
                RecordCountMatch = legacyCount == modernCount,
                LegacyCount = legacyCount,
                ModernCount = modernCount,
                IntegrityValid = integrityResult.IsValid,
                SampleValidation = sampleResult
            });
        }
        
        return new ValidationResult
        {
            IsValid = results.All(r => r.IsValid),
            TableResults = results,
            Summary = GenerateSummary(results)
        };
    }
    
    private async Task<SampleValidationResult> ValidateDataSample(
        TableSpec table, 
        int sampleSize)
    {
        // Selecionar amostra aleatÃ³ria
        var legacyRecords = await GetRandomSample(table.LegacyName, sampleSize);
        var modernRecords = await GetRandomSample(table.ModernName, sampleSize);
        
        var mismatches = new List<DataMismatch>();
        
        foreach (var legacyRecord in legacyRecords)
        {
            var modernRecord = modernRecords.FirstOrDefault(m => 
                m.GetValue(table.KeyField).Equals(legacyRecord.GetValue(table.KeyField)));
                
            if (modernRecord == null)
            {
                mismatches.Add(new DataMismatch
                {
                    Type = MismatchType.MissingRecord,
                    LegacyValue = legacyRecord,
                    ModernValue = null
                });
                continue;
            }
            
            // Comparar campos mapeados
            foreach (var mapping in table.FieldMappings)
            {
                var legacyValue = legacyRecord.GetValue(mapping.LegacyField);
                var modernValue = modernRecord.GetValue(mapping.ModernField);
                
                if (!AreValuesEquivalent(legacyValue, modernValue, mapping.Tolerance))
                {
                    mismatches.Add(new DataMismatch
                    {
                        Type = MismatchType.FieldValue,
                        Field = mapping.ModernField,
                        LegacyValue = legacyValue,
                        ModernValue = modernValue
                    });
                }
            }
        }
        
        return new SampleValidationResult
        {
            SampleSize = sampleSize,
            MismatchCount = mismatches.Count,
            Mismatches = mismatches,
            AccuracyPercentage = ((double)(sampleSize - mismatches.Count) / sampleSize) * 100
        };
    }
}
```

### 11.9 Migration Automation Tools
**Objetivo**: Fornecer ferramentas padronizadas para tracking e automaÃ§Ã£o de migraÃ§Ãµes.

**Migration Progress Tracker - ImplementaÃ§Ã£o TypeScript**:
```typescript
// migration-tracker.ts - Ferramenta padrÃ£o de tracking

interface MigrationModule {
  name: string;
  legacyComponents: ComponentInventory;
  modernComponents: ComponentInventory;
  status: 'not_started' | 'in_progress' | 'completed' | 'blocked';
  completionPercentage: number;
  blockers: Blocker[];
  owner: string;
  estimatedCompletion: Date;
  actualCompletion?: Date;
  qualityMetrics: QualityMetrics;
}

interface ComponentInventory {
  controllers: number;
  services: number;
  entities: number;
  components: number;
  tests: number;
}

interface QualityMetrics {
  testCoverage: number;
  performanceScore: number;
  securityScore: number;
  codeQualityScore: number;
}

class MigrationTracker {
  private modules: MigrationModule[] = [];

  generateProgressReport(): MigrationReport {
    const totalModules = this.modules.length;
    const completedModules = this.modules.filter(m => m.status === 'completed').length;
    const overallProgress = (completedModules / totalModules) * 100;

    return {
      overallProgress,
      moduleStatus: this.modules.map(m => ({
        name: m.name,
        status: m.status,
        completion: m.completionPercentage,
        blockers: m.blockers.length
      })),
      qualityMetrics: this.calculateAverageQuality(),
      risks: this.identifyRisks()
    };
  }

  validateCompleteness(module: MigrationModule): ValidationResult {
    const checks = [
      { name: 'Functional Parity', passed: module.completionPercentage >= 95 },
      { name: 'Test Coverage', passed: module.qualityMetrics.testCoverage >= 80 },
      { name: 'Performance', passed: module.qualityMetrics.performanceScore >= 85 },
      { name: 'Security', passed: module.qualityMetrics.securityScore >= 90 }
    ];

    return {
      isValid: checks.every(c => c.passed),
      checks,
      recommendations: this.generateRecommendations(checks)
    };
  }

  identifyRisks(): Risk[] {
    const risks: Risk[] = [];
    
    // Identificar mÃ³dulos atrasados
    const delayedModules = this.modules.filter(m => 
      m.estimatedCompletion < new Date() && m.status !== 'completed'
    );
    
    if (delayedModules.length > 0) {
      risks.push({
        type: 'schedule_delay',
        severity: 'high',
        description: `${delayedModules.length} mÃ³dulos atrasados`,
        mitigation: 'Revisar estimativas e realocar recursos'
      });
    }

    // Identificar problemas de qualidade
    const lowQualityModules = this.modules.filter(m => 
      m.qualityMetrics.testCoverage < 80
    );
    
    if (lowQualityModules.length > 0) {
      risks.push({
        type: 'quality_risk',
        severity: 'medium',
        description: `${lowQualityModules.length} mÃ³dulos com baixa cobertura de testes`,
        mitigation: 'Priorizar criaÃ§Ã£o de testes antes do go-live'
      });
    }

    return risks;
  }
}
```

### 11.9 Migration Reporting Cadence
**Objetivo**: Estabelecer cadÃªncia obrigatÃ³ria de comunicaÃ§Ã£o e revisÃµes.

**ReuniÃµes obrigatÃ³rias**:

**Daily Standup (15 min)**:
- **Participantes**: Migration team core
- **Agenda**: Bloqueadores, progresso do dia anterior, plano do dia
- **Artefato**: Status update no Slack/Teams

**Weekly Progress Review (1h)**:
- **Participantes**: Migration team + stakeholders tÃ©cnicos
- **Agenda**: MÃ©tricas de progresso, qualidade, riscos emergentes
- **Artefato**: Migration Status Report atualizado

**Bi-weekly Risk & Planning Review (2h)**:
- **Participantes**: Migration leads + product owners
- **Agenda**: RevisÃ£o de riscos, ajuste de prioridades, replanejamento
- **Artefato**: Risk assessment atualizado, roadmap ajustado

**Monthly Executive Review (1h)**:
- **Participantes**: C-level + migration leads
- **Agenda**: Status executivo, ROI, decisÃµes estratÃ©gicas
- **Artefato**: Executive summary, budget review

**Templates de comunicaÃ§Ã£o**:
```markdown
# Daily Standup Template
**Data**: [Data]
**MÃ³dulo**: [Nome do mÃ³dulo]

## âœ… ConcluÃ­do ontem:
- [Item 1]
- [Item 2]

## ðŸŽ¯ Planejado para hoje:
- [Item 1]
- [Item 2]

## ðŸš« Bloqueadores:
- [Bloqueador] - Owner: [Nome] - Prazo: [Data]

## ðŸ“Š Progresso:
- **MÃ³dulo**: X% concluÃ­do
- **Geral**: Y% concluÃ­do
```

### 11.10 Migration Risk Management
**Objetivo**: Estabelecer processo sistemÃ¡tico de identificaÃ§Ã£o e mitigaÃ§Ã£o de riscos.

**Categorias de risco obrigatÃ³rias**:

**1. Riscos TÃ©cnicos**:
- **Incompatibilidade de dados**: Schemas divergentes entre legacy e moderno
- **Performance degradation**: Sistema moderno mais lento que legacy
- **IntegraÃ§Ã£o quebrada**: APIs ou serviÃ§os externos incompatÃ­veis
- **Perda de funcionalidade**: Features nÃ£o migradas ou com comportamento diferente

**2. Riscos de Cronograma**:
- **Estimativas incorretas**: Complexidade subestimada
- **DependÃªncias externas**: Atrasos em integraÃ§Ãµes ou aprovaÃ§Ãµes
- **Recursos insuficientes**: Falta de desenvolvedores ou especialistas
- **Scope creep**: AdiÃ§Ã£o de funcionalidades nÃ£o planejadas

**3. Riscos de NegÃ³cio**:
- **ResistÃªncia de usuÃ¡rios**: RejeiÃ§Ã£o ao novo sistema
- **Downtime excessivo**: Impacto operacional durante migraÃ§Ã£o
- **Perda de dados**: Falhas na migraÃ§Ã£o de dados crÃ­ticos
- **Compliance**: NÃ£o conformidade com regulamentaÃ§Ãµes

**Matriz de risco**:
```yaml
# risk-matrix.yml
risks:
  - id: "TECH-001"
    category: "technical"
    description: "Performance degradation in critical modules"
    probability: "medium"  # low/medium/high
    impact: "high"         # low/medium/high
    severity: "high"       # low/medium/high/critical
    mitigation:
      - "Performance benchmarking before migration"
      - "Load testing with production data"
      - "Rollback plan ready"
    owner: "Tech Lead"
    status: "active"       # active/mitigated/closed
    
  - id: "SCHED-001"
    category: "schedule"
    description: "Delay in external API integration"
    probability: "high"
    impact: "medium"
    severity: "medium"
    mitigation:
      - "Parallel development of mock services"
      - "Early engagement with external team"
      - "Buffer time in schedule"
    owner: "Project Manager"
    status: "active"
```

**Processo de gestÃ£o de riscos**:
```bash
#!/bin/bash
# risk-assessment.sh - AvaliaÃ§Ã£o automÃ¡tica de riscos

echo "=== MIGRATION RISK ASSESSMENT ==="
echo "Data: $(date)"

# Verificar riscos tÃ©cnicos
echo "\nðŸ”§ Riscos TÃ©cnicos:"
if [ $(git log --since="1 week ago" --grep="performance" | wc -l) -gt 5 ]; then
    echo "âš ï¸  ALTO: MÃºltiplos commits relacionados a performance"
fi

# Verificar riscos de cronograma
echo "\nðŸ“… Riscos de Cronograma:"
DELAYED_MODULES=$(grep -c "ðŸ”´" migration-status.md)
if [ $DELAYED_MODULES -gt 2 ]; then
    echo "âš ï¸  ALTO: $DELAYED_MODULES mÃ³dulos atrasados"
fi

# Verificar riscos de qualidade
echo "\nðŸŽ¯ Riscos de Qualidade:"
TEST_COVERAGE=$(npm run test:coverage | grep "All files" | awk '{print $4}' | sed 's/%//')
if [ $TEST_COVERAGE -lt 80 ]; then
    echo "âš ï¸  MÃ‰DIO: Cobertura de testes abaixo de 80% ($TEST_COVERAGE%)"
fi

echo "\nðŸ“Š Resumo gerado em: risk-assessment-$(date +%Y%m%d).md"
```

**Responsabilidades de risk management**:
- **Migration Lead**: CoordenaÃ§Ã£o geral de riscos
- **Tech Lead**: Riscos tÃ©cnicos e arquiteturais
- **Project Manager**: Riscos de cronograma e recursos
- **Product Owner**: Riscos de negÃ³cio e compliance
- **QA Lead**: Riscos de qualidade e testing

### 11.10 Hybrid Architecture Integration
**Objetivo**: Complementar estratÃ©gias de migraÃ§Ã£o com padrÃµes de coexistÃªncia Legacy/Moderno.

**11.10.1 EstratÃ©gia de Roteamento HÃ­brido**
- **ImplementaÃ§Ã£o gradual**: Migrar funcionalidades uma por vez mantendo coexistÃªncia
- **ValidaÃ§Ã£o paralela**: Executar ambas as implementaÃ§Ãµes e comparar resultados
- **Rollback instantÃ¢neo**: Capacidade de reverter para legado sem downtime

**11.10.2 PadrÃµes de IntegraÃ§Ã£o**
```csharp
// MigrationOrchestrator.cs - OrquestraÃ§Ã£o de migraÃ§Ã£o hÃ­brida

public class MigrationOrchestrator
{
    private readonly IFeatureFlagService _featureFlags;
    private readonly ICompatibilityValidator _validator;
    
    public async Task<TResult> ExecuteHybridOperation<TResult>(
        string operationName,
        Func<Task<TResult>> legacyOperation,
        Func<Task<TResult>> modernOperation,
        HybridExecutionContext context)
    {
        var strategy = await DetermineExecutionStrategy(operationName, context);
        
        return strategy switch
        {
            HybridStrategy.LegacyOnly => await legacyOperation(),
            HybridStrategy.ModernOnly => await ExecuteWithFallback(modernOperation, legacyOperation),
            HybridStrategy.ShadowMode => await ExecuteShadowMode(legacyOperation, modernOperation),
            HybridStrategy.CompareMode => await ExecuteCompareMode(legacyOperation, modernOperation),
            _ => throw new InvalidOperationException($"Unknown strategy: {strategy}")
        };
    }
    
    private async Task<TResult> ExecuteShadowMode<TResult>(
        Func<Task<TResult>> primaryOperation,
        Func<Task<TResult>> shadowOperation)
    {
        var primaryResult = await primaryOperation();
        
        // Executar shadow operation em background (nÃ£o bloquear)
        _ = Task.Run(async () =>
        {
            try
            {
                var shadowResult = await shadowOperation();
                await _validator.CompareResults(primaryResult, shadowResult);
            }
            catch (Exception ex)
            {
                // Log mas nÃ£o falhar operaÃ§Ã£o principal
                _logger.LogWarning(ex, "Shadow operation failed");
            }
        });
        
        return primaryResult;
    }
}
```

**11.10.3 MÃ©tricas de CoexistÃªncia**
- **Adoption Rate**: % de trÃ¡fego roteado para versÃ£o moderna
- **Compatibility Score**: % de compatibilidade entre implementaÃ§Ãµes
- **Fallback Rate**: FrequÃªncia de fallbacks para versÃ£o legada
- **Performance Delta**: DiferenÃ§a de performance entre versÃµes

### 11.11 ValidaÃ§Ã£o de Schema Database-First (CRÃTICO)
**Problema**: Criar entidades baseadas em suposiÃ§Ãµes causa 2-4h de debugging.

**Processo obrigatÃ³rio**:

**1. Consultar schema real**:
```sql
SELECT 
    COLUMN_NAME,
    DATA_TYPE,
    CHARACTER_MAXIMUM_LENGTH,
    IS_NULLABLE,
    COLUMN_DEFAULT
FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_NAME = 'NomeDaTabela'
ORDER BY ORDINAL_POSITION;
```

**2. Documentar em SCHEMA_REAL_[Tabela].md**:
```markdown
| Campo | Tipo | Tamanho | Nullable | ObservaÃ§Ãµes |
|-------|------|---------|----------|-------------|
| Id | int | - | NO | PK, IDENTITY |
| Name | varchar | 255 | NO | - |
```

**3. Implementar com precisÃ£o**:
```csharp
[Table("NomeDaTabela")]
public class HybridEntity
{
    [Column("Id")]
    [Required]
    public int Id { get; set; }
    
    [Column("Name")]
    [Required]
    [MaxLength(255)]
    public string Name { get; set; }
}
```

**Checklist obrigatÃ³rio**:
- [ ] Schema consultado via SQL
- [ ] Tipos de dados validados (int vs string, nullable vs required)
- [ ] Nomes de colunas exatos confirmados
- [ ] Tamanhos de campos validados
- [ ] OnModelCreating verificado (sobrescreve atributos!)

### 11.12 GestÃ£o de CÃ³digo Legado (Desabilitar vs Deletar)
**Regra**: Desabilitar, NÃƒO deletar cÃ³digo legado imediatamente.

**Processo**:

**1. Renomear (nÃ£o deletar)**:
```bash
# Arquivos
OriginalFile.cs â†’ OriginalFile.OLD.cs

# Classes
public class MyService â†’ public class MyService_DEPRECATED
```

**2. Documentar impacto** (template ANALISE_IMPACTO_[Componente].md):
```markdown
## Arquivo Desabilitado
- Path: caminho/completo
- Motivo: razÃ£o tÃ©cnica
- Problema: o que estava errado

## Componentes Afetados
| Componente | Impacto | Criticidade |
|------------|---------|-------------|
| Controller | Alto | ðŸ”´ CrÃ­tico |

## Funcionalidades Perdidas
- Funcionalidade X: alternativa Y

## Plano de AÃ§Ã£o
- [ ] Implementar alternativa
- [ ] Atualizar dependentes
- [ ] Validar
- [ ] Deletar apÃ³s 30 dias
```

**3. Buscar dependÃªncias**:
```bash
grep -r "NomeDoArquivo" --include="*.cs" .
grep -r "NomeDaClasse" --include="*.json" .
```

**4. Matriz de decisÃ£o**:
| Impacto | Usado? | CrÃ­tico? | AÃ§Ã£o |
|---------|--------|----------|------|
| Alto | Sim | Sim | âŒ NÃƒO deletar - Refatorar |
| Alto | NÃ£o | - | âš ï¸ Desabilitar - Monitorar 30 dias |
| Baixo | NÃ£o | - | âœ… Pode deletar (com backup) |

### 11.13 AnÃ¡lise de Impacto ObrigatÃ³ria
**Regra**: Analisar ANTES de desabilitar/deletar qualquer componente.

**Template ANALISE_IMPACTO_[MudanÃ§a].md**:
```markdown
## Componentes Afetados
| Componente | Tipo | Impacto | Criticidade |
|------------|------|---------|-------------|
| Arquivo1 | Service | Alto | ðŸ”´ CrÃ­tico |

## Funcionalidades Perdidas
- Funcionalidade X
  - O que fazia
  - Usado por
  - Alternativa
  - AÃ§Ã£o

## DependÃªncias
- Diretas: lista
- Indiretas: lista
- Externas: APIs, frontend

## Plano de AÃ§Ã£o
- [ ] Validar necessidade
- [ ] Implementar alternativa
- [ ] Atualizar dependentes
- [ ] Testar
- [ ] Desabilitar/deletar
```

**Ferramentas de anÃ¡lise**:
```bash
# Buscar referÃªncias diretas
grep -r "NomeDaClasse" --include="*.cs" .

# Buscar em configuraÃ§Ãµes
grep -r "NomeDaClasse" --include="*.json" .

# Buscar em frontend
grep -r "endpoint" --include="*.ts" frontend/

# AnÃ¡lise de dependÃªncias (usando ferramentas especÃ­ficas)
dotnet list package --include-transitive
npm ls --all
```

### 11.14 ValidaÃ§Ã£o de MigraÃ§Ã£o Frontend (CRÃTICO)
**Problema**: MigraÃ§Ãµes frontend frequentemente perdem funcionalidades, campos ou experiÃªncia do usuÃ¡rio por anÃ¡lise superficial.

**Regras obrigatÃ³rias**:

**1. AnÃ¡lise Profunda de CÃ³digo-Fonte**

**1.1 Ler Templates Completos (nÃ£o apenas lÃ³gica)**
```bash
# âœ… CORRETO: Ler template + lÃ³gica + estilos
# âŒ ERRADO: Ler apenas arquivo de lÃ³gica (TS/JS)
```

**Motivo**: Templates contÃªm:
- Estrutura real da UI (tabelas, formulÃ¡rios, cards)
- Campos visÃ­veis ao usuÃ¡rio
- Eventos de interaÃ§Ã£o (cliques, submits, hovers)
- Diretivas visuais (cores, estilos condicionais)
- Componentes aninhados e slots

**1.2 Comparar Campo por Campo**

Para cada tela/componente legado:
1. Listar TODOS os elementos da UI legada
2. Listar TODOS os elementos da UI moderna
3. Comparar um a um:
   - âœ… Elementos presentes
   - âŒ Elementos faltando
   - âš ï¸ Elementos com comportamento diferente

**1.3 Identificar Componentes Interativos**

SEMPRE verificar:
- Modais/dialogs que abrem em eventos
- FormulÃ¡rios de ediÃ§Ã£o (inline ou modal)
- Tooltips/popovers com informaÃ§Ãµes adicionais
- Eventos de clique/hover
- Funcionalidades de ordenaÃ§Ã£o/paginaÃ§Ã£o
- Filtros avanÃ§ados e busca
- Drag & drop
- AÃ§Ãµes em massa (bulk actions)
- ExportaÃ§Ã£o de dados (CSV, PDF)

**2. Checklist de ValidaÃ§Ã£o de MigraÃ§Ã£o**

**Estrutura de Dados**:
- [ ] Todos os campos do modelo legado no moderno
- [ ] Campos calculados/derivados migrados
- [ ] Relacionamentos preservados
- [ ] Enums, constantes e tipos migrados
- [ ] FormataÃ§Ã£o de dados (datas, moedas) correta

**Elementos Visuais**:
- [ ] Todas as colunas de tabelas migradas
- [ ] Todos os campos de formulÃ¡rio migrados
- [ ] Labels, placeholders e hints corretos
- [ ] ValidaÃ§Ãµes de campo migradas
- [ ] MÃ¡scaras de input implementadas
- [ ] Estados de loading/erro/sucesso implementados

**Funcionalidades Interativas**:
- [ ] Modais/dialogs implementados
- [ ] Eventos de clique/hover migrados
- [ ] OrdenaÃ§Ã£o de colunas funciona
- [ ] Filtros avanÃ§ados implementados
- [ ] AÃ§Ãµes em massa migradas
- [ ] NavegaÃ§Ã£o entre telas funciona
- [ ] Breadcrumbs/navegaÃ§Ã£o contextual implementada

**Aspectos Visuais CrÃ­ticos**:
- [ ] Cores condicionais (status, alertas) implementadas
- [ ] Ãcones de alerta/atenÃ§Ã£o migrados
- [ ] Indicadores visuais (badges, tags) implementados
- [ ] Tooltips informativos migrados
- [ ] Estilos condicionais (linhas destacadas) implementados

**3. Template de Gap Analysis**

```markdown
## Gap Identificado: [Nome]

### Contexto
- **Componente Legado**: [caminho:linha]
- **Componente Moderno**: [caminho:linha]

### DescriÃ§Ã£o do Gap
[DescriÃ§Ã£o detalhada]

### CÃ³digo Legado vs Moderno
[ComparaÃ§Ã£o]

### Impacto
- **UsuÃ¡rios Afetados**: [nÃºmero/percentual]
- **FrequÃªncia de Uso**: [diÃ¡ria/semanal/mensal/rara]
- **Criticidade**: [P0-Bloqueador / P1-Importante / P2-DesejÃ¡vel / P3-Nice-to-have]
- **Impacto no NegÃ³cio**: [Alto/MÃ©dio/Baixo]

### AÃ§Ã£o NecessÃ¡ria
1. [Passo 1]
2. [Passo 2]

### Estimativa
- **Desenvolvimento**: [horas]
- **Testes**: [horas]
```

**4. Matriz de PriorizaÃ§Ã£o**

**P0 - BLOQUEADORES** (Impedem Go-Live):
- Funcionalidades core ausentes
- Campos crÃ­ticos de dados faltando
- IntegraÃ§Ãµes essenciais quebradas
- Perda de dados do usuÃ¡rio
- ViolaÃ§Ã£o de compliance/regulamentaÃ§Ã£o

**P1 - IMPORTANTES** (Impactam UX):
- Campos de dados faltando (nÃ£o crÃ­ticos)
- Funcionalidades secundÃ¡rias ausentes
- Indicadores visuais faltando
- Filtros/ordenaÃ§Ã£o incompletos

**P2 - DESEJÃVEIS** (Melhorias de UX):
- Tooltips informativos
- Atalhos de teclado
- OtimizaÃ§Ãµes visuais

**P3 - NICE-TO-HAVE** (Futuro):
- Funcionalidades raramente usadas
- Melhorias estÃ©ticas

**5. Anti-PadrÃµes (O Que NÃƒO Fazer)**

âŒ **AnÃ¡lise Superficial**:
```
ERRADO: "Analisei e estÃ¡ tudo OK"
CORRETO: "22 campos no legado, 15 no moderno, 7 faltando (documentados)"
```

âŒ **Assumir EquivalÃªncia**:
```
ERRADO: "O componente data-table tem suporte para colunas customizadas"
CORRETO: "Tem suporte MAS nÃ£o tem formataÃ§Ã£o condicional (crÃ­tico)"
```

âŒ **Ignorar Detalhes Visuais**:
```
ERRADO: "A coluna de status existe"
CORRETO: "Existe MAS sem cores (verde/amarelo/vermelho) - usuÃ¡rios nÃ£o identificam itens crÃ­ticos"
```

âŒ **NÃ£o Testar InteraÃ§Ãµes**:
```
ERRADO: "A coluna de aÃ§Ãµes estÃ¡ implementada"
CORRETO: "Implementada MAS sem menu contextual - usuÃ¡rios perderam 4 aÃ§Ãµes importantes (P0)"
```

**6. CritÃ©rios de Sucesso**

MigraÃ§Ã£o frontend Ã© **COMPLETA** quando:
- âœ… 100% dos elementos crÃ­ticos do legado no moderno
- âœ… 100% dos componentes interativos implementados
- âœ… 100% das funcionalidades core funcionam
- âœ… 100% dos indicadores visuais crÃ­ticos migrados
- âœ… UsuÃ¡rios-chave validaram e aprovaram
- âœ… 0 bugs crÃ­ticos (P0)
- âœ… Performance â‰¥ legado
- âœ… DocumentaÃ§Ã£o completa

**7. Documentos ObrigatÃ³rios**

- `MIGRATION_GAPS_ANALYSIS.md` - AnÃ¡lise detalhada de gaps
- `MIGRATION_SUMMARY.md` - Resumo executivo com recomendaÃ§Ã£o
- `LEGACY_VS_MODERN_TECHNICAL_ANALYSIS.md` - AnÃ¡lise tÃ©cnica completa
- `GAPS_RESOLUTION_REPORT.md` - Status de resoluÃ§Ã£o

**8. ValidaÃ§Ã£o com UsuÃ¡rios**

Antes de go-live:
1. **Testes com UsuÃ¡rios-Chave**: 3-5 usuÃ¡rios reais por perfil
2. **CenÃ¡rios de uso diÃ¡rio**: ComparaÃ§Ã£o lado a lado
3. **CritÃ©rios de AceitaÃ§Ã£o**:
   - 100% funcionalidades crÃ­ticas (P0) implementadas
   - 90%+ funcionalidades importantes (P1) implementadas
   - 0 bugs crÃ­ticos
   - NPS > 70 dos usuÃ¡rios-chave
   - Tempo de execuÃ§Ã£o â‰¤ legado

**Rationale**: AnÃ¡lise superficial causa retrabalho de semanas/meses. ValidaÃ§Ã£o rigorosa previne perda de funcionalidades e insatisfaÃ§Ã£o de usuÃ¡rios.

## 12) PadrÃµes para ResoluÃ§Ã£o em Massa (alto ROI)
- **Date/Time**: use `== default` para â€œnÃ£o definidoâ€ em tipos nÃ£o anulÃ¡veis; evite `.Value` indevido.
- **ConversÃµes**: value objects â†’ primitivos (ex.: `.ToString()`/`.Value`); decimalâ†”double com casts explÃ­citos.
- **Construtores**: corrigir ordem de argumentos; alinhar com assinatura real.
- **Repos/contratos**: unificaÃ§Ã£o sob interface/base comum para reduzir duplicaÃ§Ãµes.
- **Protocolos de seguranÃ§a**: backup/rollback, limite de regressÃ£o, validaÃ§Ã£o incremental.

## 13) PadrÃµes .NET Enterprise (Backend Moderno)

### 13.1 Arquitetura Clean + DDD + CQRS

**13.1.1 Estrutura de camadas obrigatÃ³ria**
- **Domain**: entidades, value objects, domain services, repository interfaces, domain events.
- **Application**: use cases, CQRS handlers (MediatR), DTOs, validators (FluentValidation).
- **Infrastructure**: EF Core, repository implementations, external services, configuraÃ§Ãµes.
- **API**: controllers, middleware, dependency injection setup.

**13.1.2 Stack tecnolÃ³gica recomendada**
- **MediatR 12.2+**: implementaÃ§Ã£o CQRS com pipeline de behaviors.
- **FluentValidation 11.9+**: validaÃ§Ã£o centralizada de comandos e queries.
- **EF Core 8+**: ORM com mapeamentos explÃ­citos e performance otimizada.
- **Result<T>**: tratamento funcional de erros sem exceptions.
- **AutoMapper**: mapeamento entre entidades e DTOs.

```csharp
// Domain.Common - Tipos fundamentais
namespace YourProject.Domain.Common;

public class Result<T>
{
    public bool IsSuccess { get; }
    public T Value { get; }
    public string Error { get; }
    
    private Result(T value) => (IsSuccess, Value) = (true, value);
    private Result(string error) => (IsSuccess, Error) = (false, error);
    
    public static Result<T> Success(T value) => new(value);
    public static Result<T> Failure(string error) => new(error);
}

public class PagedResult<T>
{
    public IReadOnlyList<T> Items { get; }
    public int TotalCount { get; }
    public int PageNumber { get; }
    public int PageSize { get; }
    public int TotalPages => (int)Math.Ceiling(TotalCount / (double)PageSize);
    
    public PagedResult(IReadOnlyList<T> items, int totalCount, int pageNumber, int pageSize)
    {
        Items = items;
        TotalCount = totalCount;
        PageNumber = pageNumber;
        PageSize = pageSize;
    }
}

public class Unit
{
    public static readonly Unit Value = new();
    private Unit() { }
}
```

### 13.2 CQRS com MediatR

**13.2.1 SeparaÃ§Ã£o comando/query**
- **Commands**: operaÃ§Ãµes que modificam estado; retornam `Result<T>` ou `Unit`.
- **Queries**: operaÃ§Ãµes de leitura; retornam DTOs ou `PagedResult<T>`.
- **Handlers**: uma responsabilidade por handler; injeÃ§Ã£o de dependÃªncias via construtor.

**13.2.2 Pipeline behaviors**
```csharp
// Validation behavior
public class ValidationBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
    where TRequest : IRequest<TResponse>
{
    private readonly IEnumerable<IValidator<TRequest>> _validators;
    
    public ValidationBehavior(IEnumerable<IValidator<TRequest>> validators)
    {
        _validators = validators;
    }
    
    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)
    {
        if (!_validators.Any()) return await next();
        
        var context = new ValidationContext<TRequest>(request);
        var failures = _validators
            .Select(v => v.Validate(context))
            .SelectMany(result => result.Errors)
            .Where(error => error != null)
            .ToList();
            
        if (failures.Any())
            throw new ValidationException(failures);
            
        return await next();
    }
}

// Logging behavior
public class LoggingBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
    where TRequest : IRequest<TResponse>
{
    private readonly ILogger<LoggingBehavior<TRequest, TResponse>> _logger;
    
    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)
    {
        var requestName = typeof(TRequest).Name;
        _logger.LogInformation("Handling {RequestName}", requestName);
        
        var stopwatch = Stopwatch.StartNew();
        var response = await next();
        stopwatch.Stop();
        
        _logger.LogInformation("Handled {RequestName} in {ElapsedMs}ms", requestName, stopwatch.ElapsedMilliseconds);
        return response;
    }
}
```

### 13.3 EF Core â€“ ConfiguraÃ§Ãµes Enterprise

**13.3.1 Mapeamentos explÃ­citos**
```csharp
public class UserConfiguration : IEntityTypeConfiguration<User>
{
    public void Configure(EntityTypeBuilder<User> builder)
    {
        builder.HasKey(u => u.Id);
        
        builder.Property(u => u.Email)
            .IsRequired()
            .HasMaxLength(255)
            .HasAnnotation("EmailIndex", true);
        
        // Value Object conversion
        builder.Property(u => u.Address)
            .HasConversion(
                v => JsonSerializer.Serialize(v, (JsonSerializerOptions)null),
                v => JsonSerializer.Deserialize<Address>(v, (JsonSerializerOptions)null));
        
        // Explicit relationships
        builder.HasOne(u => u.Profile)
            .WithOne(p => p.User)
            .HasForeignKey<UserProfile>(p => p.UserId)
            .OnDelete(DeleteBehavior.Cascade);
        
        // Indexes for performance
        builder.HasIndex(u => u.Email).IsUnique();
        builder.HasIndex(u => new { u.TenantId, u.CreatedAt });
    }
}
```

**13.3.2 Repository pattern moderno**
```csharp
public interface IRepository<T> where T : class
{
    Task<T?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default);
    Task<PagedResult<T>> GetPagedAsync(int page, int size, CancellationToken cancellationToken = default);
    Task<T> AddAsync(T entity, CancellationToken cancellationToken = default);
    Task UpdateAsync(T entity, CancellationToken cancellationToken = default);
    Task DeleteAsync(T entity, CancellationToken cancellationToken = default);
}

public class Repository<T> : IRepository<T> where T : class
{
    protected readonly DbContext _context;
    protected readonly DbSet<T> _dbSet;
    
    public Repository(DbContext context)
    {
        _context = context;
        _dbSet = context.Set<T>();
    }
    
    public virtual async Task<PagedResult<T>> GetPagedAsync(int page, int size, CancellationToken cancellationToken = default)
    {
        var totalCount = await _dbSet.CountAsync(cancellationToken);
        var items = await _dbSet
            .Skip((page - 1) * size)
            .Take(size)
            .ToListAsync(cancellationToken);
            
        return new PagedResult<T>(items, totalCount, page, size);
    }
}
```

### 13.4 Dependency Injection e Lifetimes

**13.4.1 ConfiguraÃ§Ã£o de serviÃ§os**
```csharp
// Program.cs - .NET 8
var builder = WebApplication.CreateBuilder(args);

// MediatR com behaviors
builder.Services.AddMediatR(cfg => {
    cfg.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly());
    cfg.AddBehavior<ValidationBehavior<,>>();
    cfg.AddBehavior<LoggingBehavior<,>>();
});

// FluentValidation
builder.Services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly());

// EF Core
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("Default"),
        b => b.MigrationsAssembly("YourProject.Infrastructure")));

// HttpClient com resiliÃªncia
builder.Services.AddHttpClient<IExternalApiClient, ExternalApiClient>()
    .AddPolicyHandler(GetRetryPolicy())
    .AddPolicyHandler(GetCircuitBreakerPolicy());

// Repositories
builder.Services.AddScoped(typeof(IRepository<>), typeof(Repository<>));

// Health checks
builder.Services.AddHealthChecks()
    .AddDbContext<AppDbContext>()
    .AddHttpClient<IExternalApiClient>();
```

**13.4.2 PolÃ­ticas de resiliÃªncia**
```csharp
static IAsyncPolicy<HttpResponseMessage> GetRetryPolicy()
{
    return Policy
        .HandleResult<HttpResponseMessage>(r => !r.IsSuccessStatusCode)
        .WaitAndRetryAsync(
            retryCount: 3,
            sleepDurationProvider: retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),
            onRetry: (outcome, timespan, retryCount, context) =>
            {
                Console.WriteLine($"Retry {retryCount} after {timespan}s");
            });
}

static IAsyncPolicy<HttpResponseMessage> GetCircuitBreakerPolicy()
{
    return Policy
        .HandleResult<HttpResponseMessage>(r => !r.IsSuccessStatusCode)
        .CircuitBreakerAsync(
            handledEventsAllowedBeforeBreaking: 3,
            durationOfBreak: TimeSpan.FromSeconds(30));
}
```

### 13.5 APIs e Contratos

**13.5.1 Controllers com versionamento**
```csharp
[ApiController]
[ApiVersion("1.0")]
[Route("api/v{version:apiVersion}/[controller]")]
public class UsersController : ControllerBase
{
    private readonly IMediator _mediator;
    
    public UsersController(IMediator mediator)
    {
        _mediator = mediator;
    }
    
    [HttpGet("{id:guid}")]
    public async Task<ActionResult<UserDto>> GetUser(Guid id)
    {
        var query = new GetUserQuery(id);
        var result = await _mediator.Send(query);
        
        return result.IsSuccess 
            ? Ok(result.Value) 
            : NotFound(result.Error);
    }
    
    [HttpPost]
    public async Task<ActionResult<UserDto>> CreateUser([FromBody] CreateUserCommand command)
    {
        var result = await _mediator.Send(command);
        
        return result.IsSuccess
            ? CreatedAtAction(nameof(GetUser), new { id = result.Value.Id }, result.Value)
            : BadRequest(result.Error);
    }
    
    [HttpGet]
    public async Task<ActionResult<PagedResult<UserDto>>> GetUsers(
        [FromQuery] int page = 1, 
        [FromQuery] int size = 10)
    {
        var query = new GetUsersQuery(page, size);
        var result = await _mediator.Send(query);
        
        return Ok(result);
    }
}
```

### 13.6 Checklist de implementaÃ§Ã£o
- [ ] Arquitetura Clean com separaÃ§Ã£o de camadas clara
- [ ] MediatR configurado com validation e logging behaviors
- [ ] FluentValidation para todos os commands/queries
- [ ] EF Core com mapeamentos explÃ­citos e indexes
- [ ] Result<T> para tratamento funcional de erros
- [ ] PagedResult<T> padronizado para paginaÃ§Ã£o
- [ ] HttpClient com polÃ­ticas de resiliÃªncia
- [ ] Health checks para dependÃªncias crÃ­ticas
- [ ] APIs versionadas com contratos estÃ¡veis
- [ ] Migrations automÃ¡ticas e rollback strategy



## 14) SLO/SLI/SLA e OrÃ§amento de Erros
14.1 DefiniÃ§Ãµes
- **SLI** (Service Level Indicator): mÃ©trica observÃ¡vel (p.ex.: disponibilidade p99, latÃªncia p95).
- **SLO** (Service Level Objective): alvo para SLI (p.ex.: 99.9%/30d).
- **SLA** (Service Level Agreement): contrato externo com penalidades.
- **Error Budget**: 1 âˆ’ SLO (p.ex.: SLO 99.9% â†’ orÃ§amento 0.1% indisponibilidade/30d).

15.2 Exemplo de configuraÃ§Ã£o (YAML de referÃªncia)
```yaml
slos:
  - name: availability
    target: 0.999   # 99.9%
    window: 30d
    indicator: rate(http_requests_total{status=~"5.."}[5m])
  - name: latency_p95
    target: 0.95    # 95% das requests < 300ms
    window: 1h
    indicator: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))
alert_policies:
  - name: error_budget_burn
    condition: burn_rate > 2.0 over 1h
    action: page_on_call
```

15.3 PolÃ­ticas de reaÃ§Ã£o
- Burn rÃ¡pido (1h): mitigar imediatamente (rollback/feature flag/k8s scale out).
- Burn lento (24h): planejar correÃ§Ã£o, criar task e priorizar.

## 15) GestÃ£o de Incidentes e Postmortem
15.1 Fluxo de incidente
- Detectar â†’ Triage (P1/P2/P3) â†’ Mitigar (rollback/feature flag) â†’ Restaurar serviÃ§o â†’ Postmortem.

16.2 Postmortem sem culpa (blameless)
- Causas raÃ­zes (tÃ©cnicas/processos); aÃ§Ãµes corretivas e preventivas; dueâ€‘date e owners.

Template curto:
```markdown
# Postmortem â€“ Incidente {ID}
- Data/Hora: {UTC}
- Severidade: P1/P2/P3
- Impacto: {usuarios afetados, duraÃ§Ã£o, regiÃµes}
- Linha do tempo: {detecÃ§Ã£oâ†’resoluÃ§Ã£o}
- Causa raiz: {tÃ©cnica/processo}
- LiÃ§Ãµes: {3â€“5 bullets}
- AÃ§Ãµes: {lista com owner, prioridade e due-date}
```

## 16) Change Management e Feature Flags
16.1 Diretrizes
- LanÃ§ar em pequenos incrementos; darkâ€‘launch; canary/gradual rollout.
- Flags por escopo (usuÃ¡rios/grupos/tenant/regiÃ£o), com expiraÃ§Ã£o planejada.

16.2 Hybrid Architecture Coexistence
**Objetivo**: Permitir coexistÃªncia controlada entre sistemas legados e modernos durante migraÃ§Ãµes.

**16.2.1 Dual-Interface ObrigatÃ³ria**
- **PrincÃ­pio**: Todo endpoint/funcionalidade deve suportar tanto interface legada quanto moderna
- **ImplementaÃ§Ã£o**: Roteamento inteligente baseado em feature flags e contexto do usuÃ¡rio
- **Rollback**: Capacidade de reverter instantaneamente para versÃ£o legada

```csharp
// HybridController.cs - PadrÃ£o de coexistÃªncia obrigatÃ³rio

[ApiController]
[Route("api/[controller]")]
public class HybridController : ControllerBase
{
    private readonly IFeatureFlagService _featureFlags;
    private readonly ILegacyService _legacyService;
    private readonly IModernService _modernService;
    private readonly ILogger<HybridController> _logger;
    
    public HybridController(
        IFeatureFlagService featureFlags,
        ILegacyService legacyService,
        IModernService modernService,
        ILogger<HybridController> logger)
    {
        _featureFlags = featureFlags;
        _legacyService = legacyService;
        _modernService = modernService;
        _logger = logger;
    }
    
    [HttpGet("{id}")]
    public async Task<IActionResult> GetEntity(int id)
    {
        var context = new FeatureFlagContext
        {
            UserId = GetCurrentUserId(),
            TenantId = GetCurrentTenantId(),
            Region = GetCurrentRegion(),
            RequestId = HttpContext.TraceIdentifier
        };
        
        // DecisÃ£o de roteamento baseada em feature flags
        var useModernImplementation = await _featureFlags.IsEnabledAsync(
            "modern-entity-service", 
            context
        );
        
        try
        {
            if (useModernImplementation)
            {
                _logger.LogInformation("Routing to modern service for entity {EntityId}", id);
                var modernResult = await _modernService.GetEntityAsync(id);
                
                // ValidaÃ§Ã£o de compatibilidade opcional
                if (await _featureFlags.IsEnabledAsync("validate-compatibility", context))
                {
                    await ValidateCompatibilityAsync(id, modernResult);
                }
                
                return Ok(modernResult);
            }
            else
            {
                _logger.LogInformation("Routing to legacy service for entity {EntityId}", id);
                var legacyResult = await _legacyService.GetEntityAsync(id);
                return Ok(legacyResult);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in hybrid routing for entity {EntityId}", id);
            
            // Fallback automÃ¡tico para legado em caso de erro
            if (useModernImplementation)
            {
                _logger.LogWarning("Falling back to legacy service for entity {EntityId}", id);
                var fallbackResult = await _legacyService.GetEntityAsync(id);
                return Ok(fallbackResult);
            }
            
            throw;
        }
    }
    
    private async Task ValidateCompatibilityAsync(int id, object modernResult)
    {
        try
        {
            var legacyResult = await _legacyService.GetEntityAsync(id);
            var isCompatible = CompareResults(legacyResult, modernResult);
            
            if (!isCompatible)
            {
                _logger.LogWarning("Compatibility validation failed for entity {EntityId}", id);
                // Enviar mÃ©tricas para monitoramento
                // NÃ£o falhar a requisiÃ§Ã£o, apenas alertar
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Compatibility validation error for entity {EntityId}", id);
        }
    }
}
```

**16.2.2 Feature Flags para Rollback**
```csharp
// FeatureFlagService.cs - ServiÃ§o de feature flags com rollback

public interface IFeatureFlagService
{
    Task<bool> IsEnabledAsync(string flagName, FeatureFlagContext context);
    Task<T> GetVariantAsync<T>(string flagName, FeatureFlagContext context, T defaultValue);
    Task EnableFlagAsync(string flagName, FeatureFlagScope scope);
    Task DisableFlagAsync(string flagName, FeatureFlagScope scope);
}

public class FeatureFlagService : IFeatureFlagService
{
    private readonly IConfiguration _configuration;
    private readonly IDistributedCache _cache;
    private readonly ILogger<FeatureFlagService> _logger;
    
    public async Task<bool> IsEnabledAsync(string flagName, FeatureFlagContext context)
    {
        // Verificar cache primeiro
        var cacheKey = $"flag:{flagName}:{context.GetHashCode()}";
        var cachedValue = await _cache.GetStringAsync(cacheKey);
        
        if (cachedValue != null)
        {
            return bool.Parse(cachedValue);
        }
        
        // LÃ³gica de avaliaÃ§Ã£o de feature flag
        var flagConfig = await GetFlagConfigurationAsync(flagName);
        var isEnabled = EvaluateFlag(flagConfig, context);
        
        // Cache por tempo limitado
        await _cache.SetStringAsync(cacheKey, isEnabled.ToString(), 
            new DistributedCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(5)
            });
        
        _logger.LogDebug("Feature flag {FlagName} evaluated to {IsEnabled} for context {Context}", 
            flagName, isEnabled, context);
        
        return isEnabled;
    }
    
    private bool EvaluateFlag(FeatureFlagConfiguration config, FeatureFlagContext context)
    {
        // Verificar kill switch global
        if (config.IsKillSwitchActive)
        {
            return false;
        }
        
        // Verificar rollout percentage
        if (config.RolloutPercentage < 100)
        {
            var hash = ComputeHash(context.UserId, config.FlagName);
            var userPercentile = hash % 100;
            
            if (userPercentile >= config.RolloutPercentage)
            {
                return false;
            }
        }
        
        // Verificar targeting rules
        foreach (var rule in config.TargetingRules)
        {
            if (rule.Matches(context))
            {
                return rule.IsEnabled;
            }
        }
        
        return config.DefaultValue;
    }
}

// ConfiguraÃ§Ã£o de Feature Flags
public class FeatureFlagConfiguration
{
    public string FlagName { get; set; }
    public bool DefaultValue { get; set; }
    public int RolloutPercentage { get; set; } = 0;
    public bool IsKillSwitchActive { get; set; } = false;
    public List<TargetingRule> TargetingRules { get; set; } = new();
    public DateTime? ExpirationDate { get; set; }
}

public class TargetingRule
{
    public string Property { get; set; } // "UserId", "TenantId", "Region"
    public string Operator { get; set; } // "equals", "in", "startsWith"
    public List<string> Values { get; set; }
    public bool IsEnabled { get; set; }
    
    public bool Matches(FeatureFlagContext context)
    {
        var propertyValue = GetPropertyValue(context, Property);
        
        return Operator switch
        {
            "equals" => Values.Contains(propertyValue),
            "in" => Values.Any(v => propertyValue?.Contains(v) == true),
            "startsWith" => Values.Any(v => propertyValue?.StartsWith(v) == true),
            _ => false
        };
    }
}
```

16.3 Exemplo (pseudoâ€‘cÃ³digo)
```ts
if (flags.isEnabled('new-checkout', { tenantId, region: 'SA' })) {
  return renderNewCheckout();
}
return renderLegacyCheckout();
```

## 17) Dados, Privacidade e LGPD/GDPR
17.1 PrincÃ­pios
- MinimizaÃ§Ã£o, finalidade, consentimento, portabilidade e eliminaÃ§Ã£o.
- PII/PHI: mascarar, criptografar em repouso/transporte; acesso auditÃ¡vel.

16.2 Diretrizes prÃ¡ticas
- Data retention policies por tipo de dado.
- PseudonimizaÃ§Ã£o para ambientes de teste.
- Data Subject Requests (DSR): automaÃ§Ã£o para export/delete.

## 18) Design de APIs (REST/GraphQL)
18.1 REST
- Recursos no plural; versionamento via path/headers; HATEOAS opcional.
- Erros: Problem Details (RFC 7807). PaginaÃ§Ã£o, filtros, ordenaÃ§Ã£o canÃ´nicos.

Exemplo de erro (Problem Details):
```json
{
  "type": "https://yourproject.dev/errors/validation",
  "title": "Invalid Request",
  "status": 400,
  "detail": "email is invalid",
  "instance": "/users"
}
```

17.2 GraphQL
- Schemas bem definidos; persisted queries; limites de profundidade/complexidade.

## 19) Performance e Caching
19.1 Backâ€‘end
- Cache por chave (ex.: Redis); invalidaÃ§Ã£o explÃ­cita; TTL sensato.
- IdempotÃªncia em endpoints com retries.

19.2 Frontâ€‘end
- Performance budgets (p.ex. LCP < 2.5s, JS < 200KB gz). Codeâ€‘split, prefetch, lazy.
- Imagens otimizadas (formatos modernos, tamanhos corretos, `loading="lazy"`).

19.3 CDN e Edge
- Headers de cache (`Cache-Control`, `ETag`); compressÃ£o (brotli/gzip); HTTP/2/3.

## 20) SeguranÃ§a AvanÃ§ada
20.1 Secrets Management
- Vault/KMS; rotaÃ§Ã£o periÃ³dica; zero exposiÃ§Ã£o em logs.

20.2 Threat Modeling
- STRIDE/LINDDUN conforme contexto; priorizar mitigaÃ§Ã£o de alto risco.

20.3 AutenticaÃ§Ã£o/AutorizaÃ§Ã£o
- JWT/OIDC; refresh tokens seguros; RBAC/ABAC; MFA para Ã¡reas crÃ­ticas.

20.4 ProteÃ§Ãµes operacionais
- WAF, bot management, seguranÃ§a de APIs (schema validation, rate limiting, mTLS quando aplicÃ¡vel).

## 21) Frontend â€“ SeÃ§Ãµes EspecÃ­ficas
**Nota**: Para conceitos gerais de frontend, consulte [SeÃ§Ã£o 10 - Frontend PadrÃµes Gerais](#10-frontend--padrÃµes-gerais).

21.1 React
- **Hooks**: `useMemo/useCallback` parcimoniosos; `React.Suspense` com boundaries claras; `useTransition` para navegaÃ§Ã£o.
- **Data fetching**: TanStack Query (staleTime, retry, invalidaÃ§Ãµes explÃ­citas); Error Boundary por pÃ¡gina/rota.
- **Estado**: Context + useReducer para global; Zustand para complexo; evitar prop drilling.
- **Performance**: `React.memo` seletivo; lazy loading de rotas; code splitting por feature.
- **FormulÃ¡rios**: React Hook Form + Zod; validaÃ§Ã£o client/server; UX de loading/erro consistente.
- **Testes**: Testing Library + Vitest; testes de integraÃ§Ã£o > unitÃ¡rios; mock de APIs.
- **Observabilidade**: Core Web Vitals; React DevTools Profiler; error tracking (Sentry).
- **SeguranÃ§a**: CSP estrita; evitar `dangerouslySetInnerHTML`; sanitizaÃ§Ã£o de HTML; validaÃ§Ã£o de dados antes de renderizar; validaÃ§Ã£o de inputs; HTTPS obrigatÃ³rio.
- **PadrÃµes detalhados**: Consulte `domains-rules/frontend_react_patterns.md` para arquitetura completa.

21.2 Angular
- **Estrutura obrigatÃ³ria**: `models/` e `services/` folders; componentes standalone; strong typing obrigatÃ³rio.
- **SeparaÃ§Ã£o de arquivos**: `templateUrl` e `styleUrls` obrigatÃ³rios para componentes >50 linhas; evitar templates/estilos inline em componentes complexos.
- **PadrÃµes**: Signals para estado local/derivado; `@defer`/`@if`/`@for` (Angular 17+); reactive forms + Zod/Yup; DI via `inject()`.
- **ProibiÃ§Ãµes**: modules/ folders; duplicaÃ§Ã£o de arquivos; two-way binding `[(ngModel)]`; mixed patterns.

20.3 UI/DS
- Tokens de design (cores, spacing, tipografia); utilitÃ¡rios de layout; responsividade e A11y obrigatÃ³rios.



## 22) Kubernetes (produÃ§Ã£o)
22.1 Manifests
- **HPA**: autoâ€‘scaling por CPU/mem/latÃªncia; **PDB**: disponibilidade durante manutenÃ§Ãµes.
- **NetworkPolicy**: trÃ¡fego mÃ­nimo necessÃ¡rio; **Resource limits**: OOM/CPU throttling sob controle.

23.2 Exemplo PDB
```yaml
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: yourproject-pdb
spec:
  minAvailable: 2
  selector:
    matchLabels:
      app: yourproject-api
```

23.3 NetworkPolicy (exemplo simples)
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-all-except-gateway
spec:
  podSelector:
    matchLabels:
      app: yourproject-api
  policyTypes: [Ingress, Egress]
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              name: ingress-nginx
  egress:
    - to:
        - namespaceSelector:
            matchLabels:
              name: database
```

## 23) CI/CD AvanÃ§ado
23.1 EstratÃ©gias
- Blueâ€‘green, canary, progressive delivery (Argo Rollouts/Flagger), gates de aprovaÃ§Ã£o.

24.2 SeguranÃ§a em pipelines
- Scans (SCA/SAST/DAST), assinaturas de artefatos, SBOM, supplyâ€‘chain (Sigstore/Cosign) quando aplicÃ¡vel.

## 24) GovernanÃ§a de RepositÃ³rio
24.1 Codeowners e PR Template
- `CODEOWNERS` para Ã¡reas crÃ­ticas; PR template com checklist e campos obrigatÃ³rios.

25.2 PolÃ­ticas
- Branch protection; reviews obrigatÃ³rias; checks verificados; commits assinados.

Exemplo simples `CODEOWNERS`:
```text
docs/**     @team-docs
api/**      @backend-team
web/**      @frontend-team
```

## 25) ROI, Riscos e Roadmap TÃ©cnico
25.1 ROI e mÃ©tricas
- Tempo economizado, reduÃ§Ã£o de falhas, melhoria de performance, queda de custos cloud/licenÃ§as.

25.2 Riscos
- TÃ©cnicos (dÃ­vida, regressÃµes, seguranÃ§a), pessoas (bus factor), processo (release/rollback).

25.3 Roadmap
- Curto (0â€“1m): correÃ§Ãµes alto ROI; MÃ©dio (1â€“3m): otimizaÃ§Ãµes; Longo (3â€“6m): iniciativas estratÃ©gicas.

## 26) Onboarding e Conhecimento
26.1 Onboarding
- Quickstart (setup, scripts, ambientes), visÃ£o geral de arquitetura, fluxos principais, como depurar.

26.2 DocumentaÃ§Ã£o viva
- ADRs curtos; docs por feature; geraÃ§Ãµes automÃ¡ticas (OpenAPI/Storybook/Swaggers).

## 27) DÃ©bito TÃ©cnico e Triagem
- CatÃ¡logo de dÃ©bitos com impacto/complexidade; sprints com quota (ex.: 15%) dedicada a dÃ©bitos.
- Rotina de tech review para reclassificar/fechar itens obsoletos.

## 28) Multiâ€‘Ambientes e ConfiguraÃ§Ã£o
- `dev`/`staging`/`prod` isolados; toggles por ambiente; migraÃ§Ãµes de banco versionadas.

## 29) Requisitos NÃ£o Funcionais (NFR) e Testes
29.1 Multi-Tenancy (quando aplicÃ¡vel)
- Isolamento lÃ³gico/fÃ­sico; chaves de partiÃ§Ã£o; limites por tenant; segregaÃ§Ã£o de dados/recursos.
- EstratÃ©gias: tenant por schema, tenant por database, tenant por linha (row-level security).
- ConfiguraÃ§Ã£o por tenant: feature flags, limites de uso, customizaÃ§Ãµes de UI/branding.

## 30) Banco de Dados e MigraÃ§Ãµes
<!-- tags: database, migrations, legacy-compatibility, schema-validation, orm-configuration -->
<!-- category: database-management -->
<!-- priority: high -->
<!-- audience: backend-developers, database-administrators, architects -->

**PrincÃ­pios fundamentais:**
- MigraÃ§Ãµes idempotentes, rollback scripts, janelas de manutenÃ§Ã£o, Ã­ndices planejados.
- EstratÃ©gias de evoluÃ§Ã£o de schema (expandâ†’migrateâ†’contract) para zeroâ€‘downtime.
- **Compatibilidade obrigatÃ³ria**: sistemas modernos devem ser 100% compatÃ­veis com schemas legados existentes.
- **ValidaÃ§Ã£o automatizada**: pipeline CI/CD deve validar compatibilidade entidade-banco antes de cada deploy.

### 30.1 Legacy Database Compatibility (ObrigatÃ³rio)
**Contexto**: Garantir compatibilidade total entre entidades modernas e schemas de banco de dados legados sem alteraÃ§Ãµes estruturais.

**30.1.1 Checklist de Compatibilidade Entidade-Banco**
```yaml
# database-compatibility-checklist.yml
compatibility_validation:
  entity_mapping:
    - check: "Todos os campos da entidade mapeiam para colunas existentes"
      severity: "blocker"
    - check: "Tipos de dados sÃ£o compatÃ­veis (C# â†” SQL)"
      severity: "blocker"
    - check: "Campos obrigatÃ³rios tÃªm valores padrÃ£o ou sÃ£o nullable"
      severity: "blocker"
    
  relationships:
    - check: "Foreign Keys existem no banco de dados"
      severity: "blocker"
    - check: "Relacionamentos navegacionais estÃ£o corretos"
      severity: "warning"
    
  performance:
    - check: "Ãndices necessÃ¡rios existem para queries principais"
      severity: "warning"
    - check: "Queries nÃ£o fazem full table scan desnecessÃ¡rio"
      severity: "warning"
```

**30.1.2 PadrÃµes de MigraÃ§Ã£o sem AlteraÃ§Ã£o de Schema**

**Strangler Fig Pattern para Banco de Dados**
```csharp
// REGRA: Nunca alterar schema legado, usar adaptaÃ§Ã£o
public class ProductService
{
    private readonly ILegacyProductRepository _legacyRepo;
    private readonly IModernProductRepository _modernRepo;
    private readonly IFeatureFlagService _featureFlags;
    
    public async Task<ProductDto> GetProductAsync(int id)
    {
        // Determinar fonte baseado em feature flag
        if (await _featureFlags.IsEnabledAsync("UseModernProductRepo"))
        {
            // Buscar no sistema moderno
            var modernProduct = await _modernRepo.GetByIdAsync(id);
            return modernProduct?.ToDto();
        }
        
        // Fallback para sistema legado
        var legacyProduct = await _legacyRepo.GetByIdAsync(id);
        return legacyProduct?.ToDto();
    }
}
```

**Legacy Adapter Pattern**
```csharp
// Template base para adapters de entidade legada
public abstract class BaseLegacyAdapter<TLegacy, TModern> 
    where TLegacy : class 
    where TModern : class
{
    protected readonly ILogger _logger;
    protected readonly IMetricsCollector _metrics;
    
    protected BaseLegacyAdapter(ILogger logger, IMetricsCollector metrics)
    {
        _logger = logger;
        _metrics = metrics;
    }
    
    public virtual TModern AdaptFromLegacy(TLegacy legacy)
    {
        using var activity = _metrics.StartActivity($"adapt_{typeof(TLegacy).Name}_to_{typeof(TModern).Name}");
        
        try
        {
            ValidateInput(legacy);
            var modern = DoAdaptation(legacy);
            ValidateOutput(modern);
            
            _logger.LogDebug("Successfully adapted {LegacyType} to {ModernType}", 
                typeof(TLegacy).Name, typeof(TModern).Name);
            
            return modern;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to adapt {LegacyType} to {ModernType}", 
                typeof(TLegacy).Name, typeof(TModern).Name);
            throw;
        }
    }
    
    protected abstract TModern DoAdaptation(TLegacy legacy);
    protected abstract void ValidateInput(TLegacy legacy);
    protected abstract void ValidateOutput(TModern modern);
}

// ImplementaÃ§Ã£o especÃ­fica
public class ProductLegacyAdapter : BaseLegacyAdapter<LegacyProduct, ModernProduct>
{
    protected override ModernProduct DoAdaptation(LegacyProduct legacy)
    {
        return new ModernProduct
        {
            Id = legacy.ProductId,
            Name = legacy.ProductName?.Trim(),
            Description = legacy.ProductDescription,
            Price = legacy.UnitPrice ?? 0m,
            CategoryId = legacy.CategoryId,
            
            // Campos calculados/derivados
            IsActive = legacy.Discontinued != true,
            CreatedAt = legacy.CreatedDate ?? DateTime.MinValue,
            
            // Preservar dados originais para auditoria
            LegacyData = JsonSerializer.Serialize(legacy),
            AdaptedAt = DateTime.UtcNow
        };
    }
    
    protected override void ValidateInput(LegacyProduct legacy)
    {
        if (legacy == null)
            throw new ArgumentNullException(nameof(legacy));
        if (legacy.ProductId <= 0)
            throw new ArgumentException("ProductId must be positive", nameof(legacy));
    }
    
    protected override void ValidateOutput(ModernProduct modern)
    {
        if (string.IsNullOrWhiteSpace(modern.Name))
            throw new InvalidOperationException("Adapted product name cannot be empty");
    }
}
```

**30.1.3 ConfiguraÃ§Ã£o ORM para Entidades Legadas**
```csharp
// Entity Framework - ConfiguraÃ§Ã£o para tabelas legadas
public class LegacyProductConfiguration : IEntityTypeConfiguration<LegacyProduct>
{
    public void Configure(EntityTypeBuilder<LegacyProduct> builder)
    {
        // REGRA: Usar nome exato da tabela legada
        builder.ToTable("Products"); // Nome original da tabela
        
        // REGRA: Mapear campos exatamente como estÃ£o no banco
        builder.HasKey(e => e.ProductId);
        builder.Property(e => e.ProductId).HasColumnName("ProductID");
        builder.Property(e => e.ProductName).HasColumnName("ProductName").HasMaxLength(40);
        builder.Property(e => e.UnitPrice).HasColumnName("UnitPrice").HasColumnType("money");
        builder.Property(e => e.Discontinued).HasColumnName("Discontinued");
        
        // REGRA: Relacionamentos baseados em FKs existentes
        builder.HasOne(d => d.Category)
               .WithMany(p => p.Products)
               .HasForeignKey(d => d.CategoryId)
               .HasConstraintName("FK_Products_Categories");
    }
}
```

### 30.2 Pipeline de ValidaÃ§Ã£o de Compatibilidade CI/CD
```yaml
# .github/workflows/database-compatibility.yml
name: Database Compatibility Validation

on:
  pull_request:
    paths:
      - 'src/Models/**'
      - 'src/Data/**'
      - 'migrations/**'

jobs:
  validate-compatibility:
    runs-on: ubuntu-latest
    
    services:
      sqlserver:
        image: mcr.microsoft.com/mssql/server:2019-latest
        env:
          SA_PASSWORD: ${{ secrets.SA_PASSWORD }}
          ACCEPT_EULA: Y
        ports:
          - 1433:1433
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '8.0.x'
      
      - name: Restore Legacy Database Schema
        run: |
          sqlcmd -S localhost -U sa -P ${{ secrets.SA_PASSWORD }} \
                 -i scripts/restore-legacy-schema.sql
      
      - name: Validate Entity-Database Compatibility
        run: |
          dotnet test tests/DatabaseCompatibility.Tests \
                 --configuration Release \
                 --logger "trx;LogFileName=compatibility-results.trx"
      
      - name: Check Multiple Entity Implementations
        run: |
          # Verificar se hÃ¡ mÃºltiplas implementaÃ§Ãµes da mesma entidade
          find src/ -name "*.cs" -exec grep -l "class.*Product" {} \; | \
          grep -v "Test" | wc -l | \
          awk '{if($1>1) {print "ERROR: Multiple Product entities found"; exit 1}}'
      
      - name: Validate EF Mappings
        run: |
          dotnet run --project tools/MappingValidator -- \
                 --connection-string "${{ secrets.LEGACY_CONNECTION_STRING }}" \
                 --assembly "src/MyApp.Data.dll"
      
      - name: Performance Impact Check
        run: |
          dotnet run --project tools/PerformanceValidator -- \
                 --legacy-connection "${{ secrets.LEGACY_CONNECTION_STRING }}" \
                 --modern-connection "${{ secrets.MODERN_CONNECTION_STRING }}" \
                 --max-degradation-percent 20
```

### 30.3 Quality Gates para Compatibilidade de Banco de Dados
```yaml
# quality-gates.yml
database_compatibility_gates:
  
  # Gates que BLOQUEIAM o merge/deploy
  blockers:
    - name: "Schema Compatibility"
      description: "Todas as entidades devem ser compatÃ­veis com schema legado"
      validation: "run_schema_compatibility_tests()"
      
    - name: "No Schema Changes"
      description: "Nenhuma alteraÃ§Ã£o no schema de banco legado"
      validation: "check_no_schema_changes()"
      
    - name: "Entity Uniqueness"
      description: "Apenas uma implementaÃ§Ã£o por entidade de domÃ­nio"
      validation: "check_single_entity_implementation()"
  
  # Gates que geram WARNING mas nÃ£o bloqueiam
  warnings:
    - name: "Performance Impact"
      description: "Performance nÃ£o deve degradar mais que 20%"
      validation: "check_performance_impact(max_degradation=0.20)"
      
    - name: "Missing Indexes"
      description: "Verificar se Ã­ndices necessÃ¡rios existem"
      validation: "check_required_indexes()"
  
  # Gates que requerem aprovaÃ§Ã£o manual
  approval_required:
    - name: "New Entity Relationships"
      description: "Novos relacionamentos requerem aprovaÃ§Ã£o de DBA"
      validation: "check_new_relationships()"
      
    - name: "Complex Queries"
      description: "Queries com mais de 3 JOINs requerem revisÃ£o"
      validation: "check_query_complexity(max_joins=3)"
```

### 30.4 Monitoramento e MÃ©tricas de Compatibilidade
```csharp
// MÃ©tricas de compatibilidade de banco de dados
public class DatabaseCompatibilityMetrics
{
    private readonly IMetricsCollector _metrics;
    
    public void RecordAdaptationSuccess(string entityType, TimeSpan duration)
    {
        _metrics.Counter("database.adaptation.success")
               .WithTag("entity_type", entityType)
               .Increment();
               
        _metrics.Histogram("database.adaptation.duration")
               .WithTag("entity_type", entityType)
               .Record(duration.TotalMilliseconds);
    }
    
    public void RecordCompatibilityIssue(string entityType, string issueType)
    {
        _metrics.Counter("database.compatibility.issues")
               .WithTag("entity_type", entityType)
               .WithTag("issue_type", issueType)
               .Increment();
    }
    
    public void RecordSchemaValidation(bool isValid, string tableName)
    {
        _metrics.Counter("database.schema.validation")
               .WithTag("table_name", tableName)
               .WithTag("is_valid", isValid.ToString())
               .Increment();
    }
}
```

## 31) InternacionalizaÃ§Ã£o (i18n) e LocalizaÃ§Ã£o (l10n)

33.1 Estrutura de Mensagens
- CatÃ¡logo centralizado (JSON/YAML) com namespaces: `auth.login.title`, `errors.validation.required`.
- Plural rules por idioma: `{count, plural, =0 {no items} =1 {one item} other {# items}}`.
- InterpolaÃ§Ã£o segura: `Hello {name}!` com sanitizaÃ§Ã£o automÃ¡tica.

33.2 FormataÃ§Ã£o Cultural
- Datas: `Intl.DateTimeFormat('pt-BR', {dateStyle: 'short'})` â†’ "01/12/2025".
- NÃºmeros: `Intl.NumberFormat('en-US', {style: 'currency', currency: 'USD'})` â†’ "$1,234.56".
- OrdenaÃ§Ã£o: `Intl.Collator('pt-BR', {sensitivity: 'base'})` para acentos.

33.3 ImplementaÃ§Ã£o Frontend
```typescript
// react-i18next exemplo
const { t, i18n } = useTranslation('common');
const changeLanguage = (lng: string) => i18n.changeLanguage(lng);

// Componente com fallback
<Trans i18nKey="welcome.message" values={{name: user.name}} />
```

33.4 Acessibilidade
- `lang` attribute dinÃ¢mico: `<html lang={currentLocale}>`.
- Screen readers: textos alternativos traduzidos, ARIA labels localizados.
- RTL support: `dir="rtl"` para Ã¡rabe/hebraico, CSS logical properties.



## 32) CORS e Headers de SeguranÃ§a
Exemplo Node/Express:
```ts
import helmet from 'helmet';
import cors from 'cors';
app.use(helmet({
  contentSecurityPolicy: {
    useDefaults: true,
    directives: { 'script-src': ["'self'", 'https://cdn.example.com'] }
  }
}));
app.use(cors({ origin: [/^https:\/\/app\.example\.com$/], credentials: true }));
```

## 33) ADR â€“ Template
```markdown
# ADR {id}: {tÃ­tulo curto}
- Data: {YYYYâ€‘MMâ€‘DD}
- Status: Proposta | Aprovada | Depreciada
- Contexto: {contexto do problema}
- DecisÃ£o: {o que foi decidido}
- ConsequÃªncias: {prÃ³s/cons, tradeâ€‘offs}
- Alternativas consideradas: {opcional}
```

---

---

## 34) PreservaÃ§Ã£o de Identidade Visual (PIV) â€“ Guia Definitivo
Objetivo: migrar/modernizar sem alterar a percepÃ§Ã£o de marca e experiÃªncia visual dos usuÃ¡rios. A modernizaÃ§Ã£o tÃ©cnica nÃ£o pode â€œinventarâ€ visual novo sem aprovaÃ§Ã£o do branding.

38.1 PrincÃ­pios
- Preserve: logotipos, paleta de cores, tipografia, Ã­cones, espaÃ§amentos, composiÃ§Ã£o geral.
- NÃ£o recrie: assets originais (logos, ilustraÃ§Ãµes, imagens de marca). Use os arquivos oficiais.
- Fidelidade: componentes e pÃ¡ginas devem manter hierarquia visual e affordances originais.
- Acessibilidade: elevar contraste e legibilidade sem descaracterizar a marca (apenas correÃ§Ãµes necessÃ¡rias para WCAG AA/AAA).

38.2 InventÃ¡rio e Auditoria Visual (obrigatÃ³rio)
- Assets: logos (todas variaÃ§Ãµes), Ã­cones, ilustraÃ§Ãµes, favicons, splash screens.
- Tipografia: famÃ­lias, pesos, tamanhos, line-height e letter-spacing.
- Cores: paletas, usos semÃ¢nticos, estados (hover/focus/active/disabled), variaÃ§Ãµes de tema (light/dark).
- Layout: grid, gutters, breakpoints, espaÃ§amentos (margens/paddings), densidade.
- Componentes: botÃµes, inputs, cards, tabelas, modais, navegaÃ§Ã£o, breadcrumbs.

Template de inventÃ¡rio (CSV/Markdown):
```markdown
| Tipo     | Nome/ID                 | Caminho/Ref               | ObservaÃ§Ãµes |
|---------|--------------------------|---------------------------|-------------|
| Logo    | logotipo principal       | public/logo-primary.svg   | SVG, nÃ£o rasterizar |
| Fonte   | Inter Regular 400        | assets/fonts/inter.woff2  | preload em head |
| Cor     | Brand Primary            | #1E90FF                   | token: --brand-primary |
| Ãcone   | Ã­cone de busca           | icons/search.svg          | 16/20/24 px |
| Layout  | Grid base                | 12 col, 24px gutter       | breakpoints xs/sm/md/lg/xl |
```

38.3 Tokens e Nomenclatura CanÃ´nica
- Cores: `--brand-primary`, `--brand-secondary`, `--text-primary`, `--surface-elevated`, `--border-strong`.
- EspaÃ§amentos: `--space-4/8/12/16/24/32/48` (px) ou escala 4â€‘base.
- Tipografia: `--font-family-base`, `--font-size-14/16/18`, `--line-height-140`.
- Raio/Sombra: `--radius-4/8/12`, `--shadow-sm/md/lg`.

Exemplo (tokens.scss):
```scss
:root {
  --brand-primary: #1E90FF;
  --brand-secondary: #FF7A59;
  --text-primary: #222;
  --text-secondary: #555;
  --surface-base: #fff;
  --surface-muted: #f7f7f7;
  --border-strong: #dcdcdc;

  --space-4: 4px;  --space-8: 8px;  --space-12: 12px;  --space-16: 16px;
  --space-24: 24px; --space-32: 32px; --space-48: 48px;

  --font-family-base: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  --font-size-14: 14px; --font-size-16: 16px; --font-size-18: 18px;
  --line-height-140: 1.4; --line-height-150: 1.5;

  --radius-4: 4px; --radius-8: 8px; --radius-12: 12px;
  --shadow-sm: 0 1px 2px rgba(0,0,0,.06);
  --shadow-md: 0 2px 8px rgba(0,0,0,.08);
  --shadow-lg: 0 6px 24px rgba(0,0,0,.12);
}
```

38.4 Tipografia e Performance
- Formatos: WOFF2 preferencial; preloads no `<head>` para fontes crÃ­ticas.
- FOIT/FOUT: `font-display: swap;` ou `optional` conforme diretriz de UX.
- Escala tipogrÃ¡fica: defina uma escala base e aplique consistentemente (H1..H6, body, caption).

Exemplo (typography.scss):
```scss
@font-face {
  font-family: 'Inter';
  src: url('/assets/fonts/inter.woff2') format('woff2');
  font-weight: 400 700;
  font-style: normal;
  font-display: swap;
}

.nx-text-body { font: 400 var(--font-size-16)/var(--line-height-150) var(--font-family-base); }
.nx-text-caption { font: 400 var(--font-size-14)/var(--line-height-140) var(--font-family-base); }
.nx-heading-1 { font: 700 28px/1.3 var(--font-family-base); letter-spacing: -.01em; }
```

38.5 Layout e Grid
- Grid fluido com gutters originais; breakpoints equivalentes aos do legado.
- Tabelas e denso de dados: preservar densidade (altura de linha, padding de cÃ©lulas) e contraste.

Exemplo (grid):
```scss
.nx-grid {
  display: grid;
  grid-template-columns: repeat(12, 1fr);
  gap: 24px; /* preservar gutter original */
}
.nx-col-6 { grid-column: span 6; }
@media (max-width: 1024px) { .nx-col-6 { grid-column: span 12; } }
```

38.6 CSS Migration â€“ Anticorruption Layer (ACL CSS)
- Mapeie classes antigas para utilitÃ¡rios modernos sem reescrever telas de imediato.
```scss
/* legacy â†’ moderno */
.btn-primary { @extend .app-btn; background: var(--brand-primary); }
.panel { background: var(--surface-base); box-shadow: var(--shadow-sm); border-radius: var(--radius-8); }
```

38.7 DiferenÃ§a Visual e QA
- Ferramentas: Playwright/Cypress visual, `pixelmatch`, `reg-suit`.
- Processo: screenshots baseline/atual; tolerÃ¢ncia de diffs; aprovaÃ§Ã£o de branding antes do merge.

Check de paridade visual:
- [ ] Layout (grid, gutters, hierarquia) igual ao legado
- [ ] Tipografia (famÃ­lia/peso/tamanho/altura de linha)
- [ ] Cores e estados (hover/focus/disabled/active)
- [ ] EspaÃ§amentos e densidade
- [ ] Ãcones e alinhamentos

38.8 Theming e Dark Mode
- `data-theme="light|dark"` no `<html>`; tokens especÃ­ficos por tema.
```scss
[data-theme='dark'] {
  --surface-base: #121212; --text-primary: #ececec; --border-strong: #2a2a2a;
}
```

38.9 Ãcones e SVGs
- Use SVGs otimizados (SVGO); `currentColor` para herdar a cor do texto, quando apropriado.
- Sprites SVG para Ã­cones maiores em listas/tabelas.

38.10 Responsividade e Breakpoints
- Documentar breakpoints originais; validar de mobile a desktop mantendo o layout do legado.

38.11 A11y + Identidade
- Ajustar contraste quando necessÃ¡rio (sem descaracterizar); foco visÃ­vel e consistente.

38.12 Processo de AprovaÃ§Ã£o de Marca
- Checklist e fluxo de aprovaÃ§Ã£o por â€œBrand Guardiansâ€.
- Gate no CI para PRs que alterem tokens/estilos base exigirem aprovaÃ§Ã£o do time de design.

---

## 35) ModernizaÃ§Ã£o de Legado â€“ EstratÃ©gia Completa
MissÃ£o: migrar do legado para arquitetura moderna preservando identidade visual, reduzindo risco e melhorando ROI.

39.1 Fases (Strangler Fig)
1. Discovery & Inventory: mapear mÃ³dulos, integraÃ§Ãµes, jobs, dados, assets, regras de negÃ³cio.
2. Anticorruption Layer (ACL): encapsular o legado; isolar nomenclatura/formatos antigos.
3. Roteamento/Proxy: desviar rotas especÃ­ficas para o novo serviÃ§o/pÃ¡gina conforme migraÃ§Ã£o.
4. Feature Flags e Shadow Traffic: liberar para pilotos; rodar em paralelo (ler do novo, escrever no antigo, ou dualâ€‘write controlado).
5. Faseamento: migrar por fatias (vertical slice) e domÃ­nio (ex.: autenticaÃ§Ã£o â†’ perfil â†’ catÃ¡logo â†’ pedidos).
6. Decomissionamento controlado: desligar componentes legados com mÃ©tricas de adoÃ§Ã£o e erro zero.

39.2 CritÃ©rios de PriorizaÃ§Ã£o
- Impacto no usuÃ¡rio, risco, complexidade, dependÃªncias, valor de negÃ³cio.
- ROI: custos evitados do legado (licenÃ§as, operaÃ§Ãµes), performance/UX melhorada, produtividade.

39.3 Anticorruption Layer (exemplos)
- API Gateway traduzindo contratos: legado â†’ moderno (renomear campos, normalizar enums, conversÃµes de data/ID).
- Mappers entre DTOs legados e modelos modernos (ex.: `LegacyUserDto â†’ User`).
- Camada de compatibilidade CSS (ACL CSS) para preservar visual enquanto moderniza internals.

39.4 Dados e MigraÃ§Ãµes
- Expandâ€“Migrateâ€“Contract: adicionar colunas/tabelas (expand), popular/validar (migrate), remover antigas (contract).
- EstratÃ©gias: dualâ€‘write, shadow write, CDC (Change Data Capture), janelas de corte, migraÃ§Ã£o incremental.
- Plano de rollback e consistÃªncia (checksums, contagens, auditoria).

39.5 IntegraÃ§Ãµes Externas
- Catalogar endpoints, chaves, SLAs; criar mocks contratuais para testes; timeouts/retries;
- Gradual cutâ€‘over com canary de requisiÃ§Ãµes.

39.6 SeguranÃ§a e Compliance no Legado
- Mapear dados sensÃ­veis; criptografar em repouso; mascarar PII em logs; revisar permissÃµes.

39.7 MÃ©tricas de Sucesso
- Disponibilidade, latÃªncia, taxa de erro, adoÃ§Ã£o (usuÃ¡rios migrados), tickets de suporte, satisfaÃ§Ã£o.
- Financeiro: reduÃ§Ã£o de custos (infra/licenÃ§as), tempo de entrega (lead time), MTTR.

39.8 Design/Frontend na ModernizaÃ§Ã£o (com PIV)
- Preservar tokens originais; converter CSS legado em tokens Sass sem alterar visual.
- Refatorar componentes gradualmente: extrair â€œshellâ€ visual idÃªntico; modernizar lÃ³gica por dentro.

39.9 EstratÃ©gia para Componentes MonolÃ­ticos
- Extrair modelos (`models/`), serviÃ§os (`services/`), e orquestraÃ§Ã£o (`component.tsx/.ts`)
- Migrar bindings legacy (ex.: twoâ€‘way) para estado moderno (hooks/signals), mantendo markup/classes originais.

39.10 Playbook de MigraÃ§Ã£o (resumo)
1) Selecionar mÃ³dulo de alto ROI/baixo risco.
2) Criar ACL e proxies necessÃ¡rios.
3) Replicar layout/visual 1:1 (tokens, grid, tipografia).
4) Migrar lÃ³gica crÃ­tica; testar com shadow users.
5) Ativar canary por %/tenant/timebox.
6) Medir; corrigir; aumentar cobertura; desligar legado.

39.11 Templates
Template Gap Analysis (MD):
```markdown
## Gap Analysis â€“ {MÃ³dulo}
### Escopo
### Fluxos de negÃ³cio
### Regras e validaÃ§Ãµes
### IntegraÃ§Ãµes
### UI/Visual (capturas/links)
### Riscos e mitigaÃ§Ã£o
### Plano de migraÃ§Ã£o por fatias
### MÃ©tricas de sucesso
```

Template Migration Plan (MD):
```markdown
## Migration Plan â€“ {MÃ³dulo}
### Fase 1 (Discovery/ACL)
### Fase 2 (Shadow/Canary)
### Fase 3 (Cutover)
### Fase 4 (Decomission)
### Rollback Plan
### Owners e prazos
```

39.12 Riscos TÃ­picos e MitigaÃ§Ãµes
- RegressÃ£o visual: usar testes visuais; gates de branding; aprovaÃ§Ãµes explÃ­citas.
- InconsistÃªncia de dados: dualâ€‘write com reconciliaÃ§Ã£o e monitoramento; fallback para leitura do legado.
- DÃ©bitos persistentes: limite de tempo para ACL; registrar tarefas de remoÃ§Ã£o.

39.13 ComunicaÃ§Ã£o e GestÃ£o de Stakeholders
- Roadmap e status pÃºblicos; vitrine de migraÃ§Ã£o (dash de mÃ³dulos migrados); ISO de decisÃµes (ADRs).

39.14 Ferramentas Sugeridas
- Gateway/Proxy (NGINX/YARP), Mappers (MapStruct/AutoMapper), CDC (Debezium), Visuais (Storybook/Chromatic), Playwright/Cypress Visual, AnÃ¡lise de UX (Hotjar/FullStory) quando permitido.

39.15 GovernanÃ§a da MigraÃ§Ã£o
- **InventÃ¡rio de jornadas legadas**: mantenha um catÃ¡logo de rotas/telas/funcionalidades e seu mapeamento no moderno (matriz FEâ†”BEâ†”IntegraÃ§Ãµes).
- **DefiniÃ§Ã£o de Pronto (DoD) para migraÃ§Ã£o**:
  - Tela moderna equivalente funcionando (FE).
  - Endpoints modernos cobrindo o escopo e casos de erro (BE).
  - IntegraÃ§Ãµes externas ligadas e resilientes (retries/circuit breaker/timeouts).
  - AutorizaÃ§Ã£o, auditoria e telemetria ativas.
  - Testes (unit/integration/e2e/smoke) passando.
  - DocumentaÃ§Ã£o atualizada (contratos, runbooks e mapeamento legadoâ†’moderno).
- **PolÃ­tica "paridade antes de features" (100%)**: novas features sÃ³ apÃ³s 100% de paridade por domÃ­nio. Qualquer exceÃ§Ã£o exige aprovaÃ§Ã£o formal (change control), plano de mitigaÃ§Ã£o e comunicaÃ§Ã£o aos usuÃ¡rios.
  - **Regra de ouro (AS-IS 100%)**: evoluir layout/tecnologia Ã© permitido, mas o comportamento e a cobertura funcional devem permanecer idÃªnticos ao estado atual atÃ© que a paridade seja comprovada por testes e validaÃ§Ãµes.
- **Sem "stubs" permanentes**: qualquer stub deve ter owner, prazo e tarefa vinculada; builds falham se prazos expiram.

39.16 Checklists Operacionais
- **PrÃ©-migraÃ§Ã£o**: inventÃ¡rio da jornada, contratos validados, dependÃªncias mapeadas, riscos e plano de reversÃ£o.
- **Por jornada**: paridade funcional verificada, testes cobrindo fluxos principais, documentaÃ§Ã£o e telemetria ok.
- **IntegraÃ§Ã£o nova**: contrato versionado, credenciais seguras, testes de resiliÃªncia e limites de uso.
- **EF Core**: chaves definidas, VO conversions explÃ­citas, navegaÃ§Ãµes e FKs revisadas, migraÃ§Ãµes geradas.
- **API change**: versionamento, compatibilidade retroativa, documentaÃ§Ã£o e consumidores notificados.
- **UI change**: acessibilidade e responsividade validadas, rota coberta, fallback/empty states.

39.17 MÃ©tricas MÃ­nimas de Sucesso
- 100% de jornadas crÃ­ticas com paridade funcional e observabilidade.
- 0 colisÃµes de rotas/Swagger e 0 stubs sem prazo.
- Taxa de sucesso de integraÃ§Ãµes dentro do SLA e MTTR reduzido por playbooks.

---

## 36) IntegraÃ§Ãµes Externas â€“ PadrÃµes de ResiliÃªncia

40.1 CatÃ¡logo de IntegraÃ§Ãµes
- **InventÃ¡rio obrigatÃ³rio**: para cada sistema externo, registre propÃ³sitos, contratos (OpenAPI/protobuf), SLAs, autenticaÃ§Ã£o, limites de uso e contatos tÃ©cnicos.
- **Matriz de dependÃªncias**: mapeie criticidade (crÃ­tica/importante/opcional) e impacto de indisponibilidade por jornada de usuÃ¡rio.
- **Ambientes segregados**: endpoints e credenciais distintos por ambiente; dados de teste nunca vÃ£o para produÃ§Ã£o.

40.2 Contrato-First e Versionamento
- **Contratos versionados**: OpenAPI/protobuf/JSON Schema como fonte da verdade; mudanÃ§as breaking exigem nova versÃ£o.
- **Compatibilidade retroativa**: mantenha versÃµes antigas funcionais por perÃ­odo acordado (ex.: 6 meses).
- **DocumentaÃ§Ã£o viva**: contratos atualizados automaticamente; exemplos de request/response; cÃ³digos de erro documentados.

40.3 ResiliÃªncia ObrigatÃ³ria
- **Timeouts configurÃ¡veis**: por operaÃ§Ã£o (ex.: 5s para consultas, 30s para processamento); nunca infinitos.
- **Retries com backoff**: exponential backoff com jitter; mÃ¡ximo de 3 tentativas; idempotÃªncia garantida.
- **Circuit breaker**: abrir apÃ³s N falhas consecutivas; half-open para testar recuperaÃ§Ã£o; mÃ©tricas de estado.
- **Fallbacks**: comportamento degradado quando integraÃ§Ã£o falha (cache, dados padrÃ£o, fila para retry posterior).

40.4 SeguranÃ§a e Credenciais
- **Secrets em cofre**: Azure Key Vault/AWS Secrets Manager/HashiCorp Vault; rotaÃ§Ã£o automÃ¡tica quando possÃ­vel.
- **PrincÃ­pio do menor privilÃ©gio**: credenciais com escopo mÃ­nimo necessÃ¡rio; revisÃ£o periÃ³dica de permissÃµes.
- **Auditoria**: log de tentativas de acesso (sucesso/falha) com correlationId; alertas para padrÃµes suspeitos.

40.5 Observabilidade de IntegraÃ§Ãµes
- **MÃ©tricas RED**: Rate (req/s), Errors (%), Duration (latÃªncia p50/p95/p99) por endpoint externo.
- **Health checks**: verificaÃ§Ã£o periÃ³dica de conectividade; status dashboard; alertas proativos.
- **Distributed tracing**: propagaÃ§Ã£o de contexto; spans para cada chamada externa; correlaÃ§Ã£o de erros.

40.6 Testes de ResiliÃªncia
- **Testes de contrato**: validaÃ§Ã£o automÃ¡tica de schemas; detecÃ§Ã£o de breaking changes.
- **Chaos testing**: simulaÃ§Ã£o de falhas (timeout, 5xx, network partition); validaÃ§Ã£o de fallbacks.
- **Load testing**: verificaÃ§Ã£o de limites de rate; comportamento sob stress.

40.7 PadrÃµes de ImplementaÃ§Ã£o (.NET)
```csharp
// HttpClient com polÃ­ticas de resiliÃªncia
services.AddHttpClient<ExternalApiClient>(client =>
{
    client.BaseAddress = new Uri(config.ExternalApiUrl);
    client.Timeout = TimeSpan.FromSeconds(30);
})
.AddPolicyHandler(GetRetryPolicy())
.AddPolicyHandler(GetCircuitBreakerPolicy());

static IAsyncPolicy<HttpResponseMessage> GetRetryPolicy()
{
    return Policy
        .HandleResult<HttpResponseMessage>(r => !r.IsSuccessStatusCode)
        .WaitAndRetryAsync(
            retryCount: 3,
            sleepDurationProvider: retryAttempt => 
                TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + 
                TimeSpan.FromMilliseconds(Random.Shared.Next(0, 1000)));
}
```

40.8 Checklist de IntegraÃ§Ã£o Nova
- [ ] Contrato versionado e documentado
- [ ] Credenciais seguras e com escopo mÃ­nimo
- [ ] Timeouts, retries e circuit breaker configurados
- [ ] Fallbacks e comportamento degradado definidos
- [ ] Testes de contrato e resiliÃªncia implementados
- [ ] MÃ©tricas e alertas configurados
- [ ] DocumentaÃ§Ã£o de troubleshooting e runbooks

---

## 37) Storybook e CatÃ¡logo de Componentes (opcional, recomendado)
- CatÃ¡logo vivo; docs MDX with examples; snapshots de props e variaÃ§Ãµes.
- IntegraÃ§Ã£o com tokens (via CSS variables, theme providers).
- Testes visuais automatizados no PR.

## 38) Fluxo de Handoff com Design (Figma)
- Fonte da verdade do design; tokens exportÃ¡veis; checklist de variaÃ§Ãµes.
- Proceder com â€œDesign QAâ€ antes de merge em pÃ¡ginas crÃ­ticas.

## 39) Visual Regression Pipeline
- Jobs noturnos comparando telas crÃ­ticas; alertas se delta > tolerÃ¢ncia.
- Storage de baselines por branch/release.

## 40) Performance Visual e UX
- OrÃ§amento para CLS/LCP/INP; lazy/priority hints; skeletons consistentes com o legado.

## 41) Responsividade Fiel ao Legado
- NÃ£o â€œquebrarâ€ grids originais; apenas corrigir bugs de overflow/conteÃºdo dinÃ¢mico.

## 42) CatÃ¡logo de Ãcones e IlustraÃ§Ãµes
- Sprite/pack; naming consistente; guia de tamanhos; fallback para fontes de Ã­cones legadas (se inevitÃ¡vel).

## 43) GestÃ£o de Assets
- Estrutura: `public/` (imagens estÃ¡ticas), `assets/` (build), `icons/` (SVG limpos), `fonts/`.
- EstratÃ©gias de cache e versionamento (hash nos nomes).

## 44) Template de AprovaÃ§Ã£o de MudanÃ§as Visuais no PR
```markdown
### Visual Changes
- [ ] Capturas antes/depois anexadas
- [ ] Impacto em componentes reutilizados listado
- [ ] AprovaÃ§Ã£o do design/branding anexada
- [ ] Testes visuais passam (link para report)
```

## 45) MÃ©tricas de PreservaÃ§Ã£o Visual
- % de telas com paridade 1:1; nÂº de regressÃµes; tempo mÃ©dio de correÃ§Ã£o; satisfaÃ§Ã£o de stakeholders.

## 46) Guia de Nomenclatura de Classes (BEM/UtilitÃ¡rios)
- `.nx-` prefix para utilitÃ¡rios; BEM para componentes (`.card`, `.card__title`, `.card--elevated`).

## 47) RevisÃµes PeriÃ³dicas de Marca
- Auditoria trimestral: consistÃªncia de tokens, fontes, cores; alinhamento com manual de marca.

---

## 48) Estrutura de Pastas â€“ Boas PrÃ¡ticas
48.1 Projetos Web SPA (pequenos/mÃ©dios)
```text
src/
  assets/         # imagens, Ã­cones, fontes
  styles/         # Sass/CSS modularizado (tokens, base, components)
  ui/             # componentes UI reutilizÃ¡veis (headless + wrappers)
  pages/          # pÃ¡ginas/rotas da aplicaÃ§Ã£o
  components/     # componentes especÃ­ficos (colocation quando fizer sentido)
  hooks/          # hooks customizados
  services/       # clientes de API, integraÃ§Ãµes externas
  context/        # providers de estado global leve
  utils/          # utilitÃ¡rios puros
  data/           # constantes, mocks determinÃ­sticos
```

51.2 Backends (Clean Architecture)
```text
src/
  Domain/           # Entidades, Value Objects, Eventos, Regras (DDD puro)
  Application/      # Casos de uso (CQRS: Commands/Queries + Handlers), DTOs, Validadores
  Infrastructure/   # EF Core, RepositÃ³rios, Integrations, ConfiguraÃ§Ã£o
  Api/              # Controllers/Endpoints, Middleware, DI Composition Root
```

51.3 Guidelines
- Colocation: cÃ³digo que muda junto, fica junto.
- Nomes descritivos, evitar â€œmisc/utilsâ€ genÃ©ricos; pastas devem comunicar propÃ³sito.
- ExposiÃ§Ã£o estÃ¡vel por `index.ts`/`index.cs` para evitar imports frÃ¡geis.

51.4 React (Vite/TypeScript)
```text
src/
  assets/           # imagens, Ã­cones, fontes
  styles/           # tokens.scss, base.scss, components.scss, index.scss
  ui/               # componentes UI reutilizÃ¡veis (headless + wrappers)
  components/       # componentes especÃ­ficos de pÃ¡ginas ou compartilhados pequenos
  pages/            # rotas/pÃ¡ginas
  hooks/            # hooks customizados
  context/          # providers de estado global leve
  services/         # API clients (fetch/axios), caches locais
  utils/            # funÃ§Ãµes puras utilitÃ¡rias
  data/             # constantes, mocks determinÃ­sticos
  routes/           # (opcional) configuraÃ§Ã£o de rotas centralizadas
  main.tsx          # providers (Router, QueryClient, Theme)
  App.tsx
```

Aliases (tsconfig + Vite):
```json
// tsconfig.app.json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@ui/*": ["src/ui/*"],
      "@pages/*": ["src/pages/*"],
      "@styles/*": ["src/styles/*"],
      "@assets/*": ["src/assets/*"],
      "@shared/*": ["src/components/*"],
      "@context/*": ["src/context/*"],
      "@services/*": ["src/services/*"],
      "@utils/*": ["src/utils/*"],
      "@data/*": ["src/data/*"]
    }
  }
}
```

```ts
// vite.config.ts
import path from 'node:path';
export default {
  resolve: {
    alias: {
      '@ui': path.resolve(process.cwd(), 'src/ui'),
      '@pages': path.resolve(process.cwd(), 'src/pages'),
      '@styles': path.resolve(process.cwd(), 'src/styles'),
      '@assets': path.resolve(process.cwd(), 'src/assets'),
      '@services': path.resolve(process.cwd(), 'src/services'),
      '@utils': path.resolve(process.cwd(), 'src/utils')
    }
  }
};
```

51.5 Angular (Standalone + Signals)
```text
src/
  app/
    core/            # serviÃ§os cross-cutting (interceptors, guards, config)
    shared/          # componentes/ui/pipes/diretivas reutilizÃ¡veis
      components/
      ui/
      pipes/
      directives/
    features/
      feature-a/
        pages/       # pÃ¡ginas standalone da feature
        components/  # componentes internos da feature
        services/    # serviÃ§os da feature (HTTP, estado)
        store/       # signals/estado local da feature
        routes.ts    # rotas lazy da feature
        index.ts
    app.config.ts    # bootstrap + providers
  assets/
  styles/            # tokens.scss, base.scss, components.scss, index.scss
  environments/      # variÃ¡veis de ambiente (buildâ€‘time)
```

Diretrizes Angular:
- Standalone components; rotas lazy por feature; `inject()` em vez de constructors pesados.
- Estado local com signals/computed; evitar serviÃ§os globais sem necessidade.
- FormulÃ¡rios reativos + validaÃ§Ã£o (Zod/Yup opcional); interceptors para auth/errors.

Aliases (tsconfig):
```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@app/*": ["src/app/*"],
      "@assets/*": ["src/assets/*"],
      "@styles/*": ["src/styles/*"],
      "@shared/*": ["src/app/shared/*"],
      "@core/*": ["src/app/core/*"],
      "@features/*": ["src/app/features/*"]
    }
  }
}
```

## 49) SOLID â€“ AplicaÃ§Ã£o PrÃ¡tica
- S (Single Responsibility): classes e mÃ³dulos com uma Ãºnica razÃ£o para mudar.
- O (Open/Closed): abertos para extensÃ£o, fechados para modificaÃ§Ã£o (ex.: estratÃ©gias/handlers).
- L (Liskov Substitution): contratos respeitados; evitar exceÃ§Ãµes inesperadas em implementaÃ§Ãµes.
- I (Interface Segregation): interfaces pequenas e especÃ­ficas; evitar â€œgod interfacesâ€.
- D (Dependency Inversion): depender de abstraÃ§Ãµes, nÃ£o concretos; inversion of control via DI.

Exemplo (DIP no backend):
```csharp
public interface IEmailSender { Task SendAsync(Message m, CancellationToken ct); }
public class SmtpEmailSender : IEmailSender { /* ... */ }
public class NotifyUserHandler {
  private readonly IEmailSender _sender;
  public NotifyUserHandler(IEmailSender sender) { _sender = sender; }
}
```

## 50) DDD â€“ Diretrizes Objetivas

### 52.1 Domain-Driven Design (DDD) â€“ Diretrizes Objetivas

**52.1.1 Ubiquitous Language**
- GlossÃ¡rio do domÃ­nio compartilhado; nomes refletindo a linguagem do negÃ³cio.
- Evitar traduÃ§Ãµes tÃ©cnicas; usar termos do negÃ³cio no cÃ³digo.

**52.1.2 Entidades e Value Objects**
- Entidades com identidade e ciclo de vida; VOs imutÃ¡veis com igualdade estrutural.
- Regra: se tem ID e muda ao longo do tempo = Entidade; se Ã© imutÃ¡vel e definido por seus valores = VO.

**52.1.3 Agregados e Invariantes**
- Definir raÃ­zes de agregado; manter invariantes dentro dos limites do agregado.
- Um agregado = uma transaÃ§Ã£o; comunicaÃ§Ã£o entre agregados via eventos de domÃ­nio.

**52.1.4 Eventos de DomÃ­nio**
- Comunicar mudanÃ§as significativas do domÃ­nio; handlers para side effects.
- PadrÃ£o: `[Entidade][AÃ§Ã£o]Event` (ex: `PedidoCriadoEvent`, `PagamentoProcessadoEvent`).

**52.1.5 Bounded Contexts**
- Mapear contextos; ACL (Anti-Corruption Layer) entre contextos; contratos e integraÃ§Ãµes explÃ­citos.
- Cada contexto tem seu prÃ³prio modelo de domÃ­nio; evitar "God Models" compartilhados.

## 51) CQRS â€“ PadrÃ£o PragmÃ¡tico

### 53.1 CQRS â€“ PadrÃ£o PragmÃ¡tico

**53.1.1 Quando usar**
- Leitura e escrita com requisitos distintos, queries ricas/performance, side effects de negÃ³cio.
- Evitar CQRS desnecessÃ¡rio em CRUDs simples.

**53.1.2 Estrutura padronizada**
```text
Application/
  Commands/           # Mutations de estado (CreateOrder, UpdatePayment)
    Handlers/         # ImplementaÃ§Ãµes dos comandos
    Validators/       # Regras de entrada (FluentValidation)
  Queries/            # Leituras/relatÃ³rios (GetOrderById, SearchProducts)
    Handlers/         # ImplementaÃ§Ãµes das queries
  DTOs/               # Modelos de I/O (requests/responses)
  Events/             # Eventos de aplicaÃ§Ã£o
    Handlers/         # Side effects e integraÃ§Ãµes
```

**53.1.3 Boas prÃ¡ticas**
- **Comandos**: idempotÃªncia em comandos sensÃ­veis; retries seguros; compensaÃ§Ãµes quando necessÃ¡rio.
- **Queries**: otimizadas (projeÃ§Ãµes), sem regras de negÃ³cio complexas; podem acessar read models.
- **SeparaÃ§Ã£o**: comandos retornam `Result<T>` ou `Unit`; queries retornam DTOs ou `PagedResult<T>`.

### 53.2 Event Sourcing - ImplementaÃ§Ã£o Detalhada

**53.2.1 Quando usar Event Sourcing**
- Auditoria completa obrigatÃ³ria; necessidade de replay/reconstruÃ§Ã£o de estado.
- DomÃ­nios com eventos de negÃ³cio ricos; anÃ¡lise temporal de dados.
- Sistemas com alta concorrÃªncia e necessidade de eventual consistency.

**53.2.2 Estrutura de Event Store**
```csharp
// Event base
public abstract record DomainEvent
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public DateTime OccurredAt { get; init; } = DateTime.UtcNow;
    public string EventType { get; init; } = string.Empty;
    public int Version { get; init; }
}

// Aggregate base
public abstract class EventSourcedAggregate
{
    private readonly List<DomainEvent> _uncommittedEvents = new();
    public Guid Id { get; protected set; }
    public int Version { get; private set; }
    
    public IReadOnlyList<DomainEvent> GetUncommittedEvents() => _uncommittedEvents;
    public void MarkEventsAsCommitted() => _uncommittedEvents.Clear();
    
    protected void RaiseEvent(DomainEvent @event)
    {
        _uncommittedEvents.Add(@event);
        Apply(@event);
        Version++;
    }
    
    public void LoadFromHistory(IEnumerable<DomainEvent> events)
    {
        foreach (var @event in events)
        {
            Apply(@event);
            Version++;
        }
    }
    
    protected abstract void Apply(DomainEvent @event);
}
```

**53.2.3 Event Store Repository**
```csharp
public interface IEventStore
{
    Task SaveEventsAsync(Guid aggregateId, IEnumerable<DomainEvent> events, int expectedVersion);
    Task<IEnumerable<DomainEvent>> GetEventsAsync(Guid aggregateId);
    Task<IEnumerable<DomainEvent>> GetEventsAsync(Guid aggregateId, int fromVersion);
}

public class EventStoreRepository<T> where T : EventSourcedAggregate, new()
{
    private readonly IEventStore _eventStore;
    
    public async Task<T?> GetByIdAsync(Guid id)
    {
        var events = await _eventStore.GetEventsAsync(id);
        if (!events.Any()) return null;
        
        var aggregate = new T();
        aggregate.LoadFromHistory(events);
        return aggregate;
    }
    
    public async Task SaveAsync(T aggregate)
    {
        var events = aggregate.GetUncommittedEvents();
        if (!events.Any()) return;
        
        await _eventStore.SaveEventsAsync(aggregate.Id, events, aggregate.Version - events.Count);
        aggregate.MarkEventsAsCommitted();
    }
}
```

**53.2.4 Snapshots para Performance**
```csharp
public interface ISnapshotStore
{
    Task SaveSnapshotAsync<T>(Guid aggregateId, T snapshot, int version);
    Task<(T? snapshot, int version)> GetSnapshotAsync<T>(Guid aggregateId);
}

// ImplementaÃ§Ã£o com snapshots a cada N eventos
public class SnapshotEventStoreRepository<T> where T : EventSourcedAggregate, new()
{
    private const int SnapshotFrequency = 100;
    
    public async Task<T?> GetByIdAsync(Guid id)
    {
        var (snapshot, snapshotVersion) = await _snapshotStore.GetSnapshotAsync<T>(id);
        var events = await _eventStore.GetEventsAsync(id, snapshotVersion + 1);
        
        var aggregate = snapshot ?? new T();
        aggregate.LoadFromHistory(events);
        return aggregate;
    }
    
    public async Task SaveAsync(T aggregate)
    {
        // Salvar eventos
        await base.SaveAsync(aggregate);
        
        // Criar snapshot se necessÃ¡rio
        if (aggregate.Version % SnapshotFrequency == 0)
        {
            await _snapshotStore.SaveSnapshotAsync(aggregate.Id, aggregate, aggregate.Version);
        }
    }
}
```

**53.2.5 ProjeÃ§Ãµes e Read Models**
```csharp
// Handler para atualizar read models
public class OrderProjectionHandler : 
    INotificationHandler<OrderCreatedEvent>,
    INotificationHandler<OrderItemAddedEvent>
{
    private readonly IOrderReadModelRepository _readModelRepo;
    
    public async Task Handle(OrderCreatedEvent @event, CancellationToken ct)
    {
        var readModel = new OrderReadModel
        {
            Id = @event.OrderId,
            CustomerId = @event.CustomerId,
            CreatedAt = @event.OccurredAt,
            Status = "Created",
            TotalAmount = 0
        };
        
        await _readModelRepo.SaveAsync(readModel);
    }
    
    public async Task Handle(OrderItemAddedEvent @event, CancellationToken ct)
    {
        var readModel = await _readModelRepo.GetByIdAsync(@event.OrderId);
        if (readModel != null)
        {
            readModel.TotalAmount += @event.Price * @event.Quantity;
            await _readModelRepo.UpdateAsync(readModel);
        }
    }
}
```

**53.2.6 Checklist Event Sourcing**
- [ ] Event Store implementado com versionamento
- [ ] Agregados derivam de EventSourcedAggregate
- [ ] Eventos imutÃ¡veis e serializÃ¡veis
- [ ] Snapshots para agregados com muitos eventos
- [ ] ProjeÃ§Ãµes para read models otimizados
- [ ] Tratamento de concorrÃªncia (optimistic locking)
- [ ] Replay de eventos para reconstruÃ§Ã£o
- [ ] Monitoramento de performance do Event Store

**53.2.7 PadrÃµes avanÃ§ados**
- **Saga Pattern**: coordenaÃ§Ã£o de transaÃ§Ãµes distribuÃ­das via eventos.
- **Process Manager**: orquestraÃ§Ã£o de workflows complexos.
- **Event Upcasting**: evoluÃ§Ã£o de eventos mantendo compatibilidade.
- **Temporal Queries**: consultas em pontos especÃ­ficos do tempo.

## 52) Clean Architecture â€“ Contratos e Fluxo

### 54.1 Clean Architecture â€“ Contratos e Fluxo

**54.1.1 Regras de dependÃªncia**
- **Domain**: sem dependÃªncias externas; apenas regras de negÃ³cio puras.
- **Application**: depende apenas de Domain; orquestra casos de uso.
- **Infrastructure**: implementa interfaces do Domain/Application.
- **API/Presentation**: depende de Application; nÃ£o conhece Infrastructure diretamente.

**54.1.2 Fluxo tÃ­pico**
```text
Request â†’ API (Controller) â†’ Application (Command/Query Handler) â†’ Domain (Business Rules) â†’ Infrastructure (Persistence) â†’ Response
```

**54.1.3 BenefÃ­cios consolidados**
- **Testabilidade**: Domain e Application testÃ¡veis sem dependÃªncias externas.
- **Flexibilidade**: trocar Infrastructure sem afetar regras de negÃ³cio.
- **EvoluÃ§Ã£o**: guiada por domÃ­nio, nÃ£o por limitaÃ§Ãµes tÃ©cnicas.
- **Manutenibilidade**: separaÃ§Ã£o clara de responsabilidades.

### 54.2 IntegraÃ§Ã£o dos padrÃµes

**54.2.1 DDD + CQRS**
- Agregados processam comandos; eventos de domÃ­nio disparam side effects.
- Queries podem usar read models otimizados, separados do modelo de escrita.

**54.2.2 CQRS + Clean Architecture**
- Commands/Queries na camada Application; Domain contÃ©m regras puras.
- Infrastructure implementa repositÃ³rios e handlers de eventos.

**54.2.3 Stack tecnolÃ³gica recomendada (.NET)**
- **MediatR**: para implementar CQRS (commands/queries como requests).
- **FluentValidation**: validaÃ§Ã£o de comandos e queries.
- **AutoMapper**: mapeamento entre Domain e DTOs.
- **Result<T>**: para tratamento de erros sem exceptions.

### 54.3 Checklist de implementaÃ§Ã£o
- [ ] Bounded contexts mapeados e documentados
- [ ] Ubiquitous language definido e usado no cÃ³digo
- [ ] Agregados identificados com invariantes claras
- [ ] SeparaÃ§Ã£o clara Commands vs Queries
- [ ] Domain sem dependÃªncias externas
- [ ] Eventos de domÃ­nio para comunicaÃ§Ã£o entre agregados
- [ ] Testes unitÃ¡rios cobrindo regras de domÃ­nio
- [ ] Read models otimizados para queries complexas

## 53) PadrÃµes de Projeto Relevantes

### 55.1 PadrÃµes de domÃ­nio
- **Strategy**: para algoritmos intercambiÃ¡veis (ex: cÃ¡lculo de frete, processamento de pagamento).
- **Factory**: criaÃ§Ã£o de agregados complexos; evitar construtores com muitos parÃ¢metros.
- **Specification**: regras de negÃ³cio reutilizÃ¡veis e combinÃ¡veis.
- **Repository**: abstraÃ§Ã£o para persistÃªncia; interfaces no Domain, implementaÃ§Ã£o na Infrastructure.
- **Unit of Work**: controle transacional; garantir consistÃªncia em operaÃ§Ãµes multi-agregado.

### 55.2 PadrÃµes de aplicaÃ§Ã£o
- **Mediator (MediatR)**: desacoplamento entre Controllers e Handlers; pipeline de behaviors.
- **Command/Query**: separaÃ§Ã£o clara entre operaÃ§Ãµes de escrita e leitura.
- **Result<T>**: tratamento de erros funcionais sem exceptions; railway-oriented programming.

### 55.3 PadrÃµes de integraÃ§Ã£o
- **Adapter/Facade**: simplificar integraÃ§Ãµes com APIs externas; isolar complexidade.
- **Anti-Corruption Layer (ACL)**: proteger modelo interno de mudanÃ§as externas.
- **Mapper**: conversÃ£o entre Domain e DTOs; usar AutoMapper ou mappers manuais.

### 55.4 PadrÃµes de resiliÃªncia
- **Circuit Breaker**: proteÃ§Ã£o contra falhas em cascata; usar Polly (.NET).
- **Retry/Timeout**: tentativas com backoff exponencial; timeouts sensatos.
- **Bulkhead**: isolamento de recursos; evitar que uma falha afete todo o sistema.

## 54) PolÃ­tica de RepositÃ³rios (Sem DuplicaÃ§Ãµes)

### 56.1 Estrutura base
- **Interfaces no domÃ­nio**: `IRepository<TEntity, TKey>` para operaÃ§Ãµes genÃ©ricas;
- **ImplementaÃ§Ãµes na Infrastructure**: herdar de `BaseRepository<TEntity, TKey>`;
- **EspecializaÃ§Ã£o**: apenas mÃ©todos especÃ­ficos nos repositÃ³rios concretos; CRUD padrÃ£o no base.

### 56.2 Exemplo de implementaÃ§Ã£o
```csharp
// Domain
public interface IOrderRepository : IRepository<Order, Guid>
{
    Task<IEnumerable<Order>> GetByCustomerIdAsync(Guid customerId);
    Task<Order?> GetWithItemsAsync(Guid orderId);
}

// Infrastructure
public class OrderRepository : BaseRepository<Order, Guid>, IOrderRepository
{
    public OrderRepository(DbContext context) : base(context) { }
    
    public async Task<IEnumerable<Order>> GetByCustomerIdAsync(Guid customerId)
    {
        return await DbSet.Where(o => o.CustomerId == customerId).ToListAsync();
    }
    
    public async Task<Order?> GetWithItemsAsync(Guid orderId)
    {
        return await DbSet.Include(o => o.Items)
                         .FirstOrDefaultAsync(o => o.Id == orderId);
    }
}
```

### 56.3 BenefÃ­cios
- **ReutilizaÃ§Ã£o**: operaÃ§Ãµes CRUD padronizadas no BaseRepository.
- **EspecializaÃ§Ã£o**: mÃ©todos especÃ­ficos apenas quando necessÃ¡rio.
- **Testabilidade**: interfaces facilitam mocking em testes unitÃ¡rios.
- **ConsistÃªncia**: padrÃµes uniformes em toda a aplicaÃ§Ã£o.

---

## 55) LiÃ§Ãµes Aprendidas â€“ CatÃ¡logo Resumido (com crossâ€‘refs)
Objetivo: preservar, em nÃ­vel executivo, as liÃ§Ãµes com maior ROI e onde aplicÃ¡â€‘las no documento.

- Protocolos de SeguranÃ§a para MudanÃ§as Massivas (v6.2)
  - EssÃªncia: backup/checkpoints, validaÃ§Ã£o incremental a cada passo, limite de regressÃ£o â‰¤ 10.
  - Onde aplicar: SeÃ§Ãµes 4.1 (Protocolos), 24 (CI/CD), 22 (Alertas). 

- AnÃ¡lise Quantitativa e PrincÃ­pio de ConcentraÃ§Ã£o
  - EssÃªncia: priorizar top 3 tipos de erro; atacar arquivos com â‰¥ 3 ocorrÃªncias (efeito cascata).
  - Onde aplicar: SeÃ§Ã£o 4.2 (FrequÃªncia/ConcentraÃ§Ã£o), 26 (ROI/Riscos).

- Date/Time â€“ Sentinelas vs Null/Default
  - EssÃªncia: evitar `DateTime.MinValue` como sentinela; preferir `null` (nullable) ou `== default`.
  - Onde aplicar: SeÃ§Ãµes 11 (ResoluÃ§Ã£o em Massa), SeÃ§Ãµes de Apoio A (.NET/EF Core), 28 (NFR tests).

- ConversÃµes de Identidade (Guid â†” tipos numÃ©ricos)
  - EssÃªncia: padronizar conversÃµes (ex.: `ToEventId()`); evitar comparaÃ§Ãµes de tipos distintos em queries.
  - Onde aplicar: SeÃ§Ãµes de Apoio A (.NET/EF Core), SeÃ§Ãµes 11 e 23 (Kubernetes â†’ mÃ©tricas de queries).

- Ordem de Argumentos em Construtores/MÃ©todos
  - EssÃªncia: alinhar ordem aos contratos reais; corrige blocos de erros de conversÃ£o.
  - Onde aplicar: SeÃ§Ã£o 11 (ResoluÃ§Ã£o em Massa â€“ alto ROI), 55 (Clean Architecture â€“ contratos). 

- Value Objects â†’ Primitivos (ConversÃµes) 
  - EssÃªncia: expor `.Value`/`.ToString()`/`.ToNumber()` conforme contrato esperado; decimalâ†”double com casts explÃ­citos.
  - Onde aplicar: SeÃ§Ã£o 11, SeÃ§Ãµes de Apoio A (.NET/EF Core), 18 (Performance/Caching).

- EF Core â€“ TraduÃ§Ã£o de LINQ
  - EssÃªncia: evitar dicionÃ¡rios em queries, method groups como bool e opcionais em expressÃµes; materializar antes.
  - Onde aplicar: SeÃ§Ãµes de Apoio A (.NET/EF Core), 54 (CQRS â€“ queries). 

- EliminaÃ§Ã£o SistemÃ¡tica de DuplicaÃ§Ãµes (Repos/Contratos)
  - EssÃªncia: consolidar interfaces e herdar de `BaseRepository`; manter apenas mÃ©todos especÃ­ficos.
  - Onde aplicar: SeÃ§Ã£o 57 (PolÃ­tica de RepositÃ³rios), 50.2 (Clean Arch folders).

- Efeito Cascata (Cascading Effect)
  - EssÃªncia: medir erros antes/depois de cada correÃ§Ã£o; priorizar correÃ§Ãµes com maior impacto indireto.
  - Onde aplicar: SeÃ§Ã£o 4.2 (ConcentraÃ§Ã£o), 26 (ROI), 22 (Alertas de qualidade).

- Prioridade Inteligente em MigraÃ§Ãµes (Simples â†’ MÃ©dio â†’ Complexo)
  - EssÃªncia: consolidar padrÃµes em mÃ³dulos simples, refinar nos mÃ©dios, aplicar expertise nos complexos.
  - Onde aplicar: SeÃ§Ãµes 40 (ModernizaÃ§Ã£o), 51.4/51.5 (Estruturas React/Angular).

- ResoluÃ§Ã£o Manual de Erros TypeScript (TS2393 â€“ duplicaÃ§Ãµes)
  - EssÃªncia: resolver duplicaÃ§Ãµes com anÃ¡lise contextual (Signals/typeâ€‘safe > legacy), build a cada correÃ§Ã£o.
  - Onde aplicar: SeÃ§Ãµes 2 (Qualidade), 9 (Frontend), 39 (ModernizaÃ§Ã£o â€“ componentes monolÃ­ticos). 

- Determinismo Visual em E2E + PreservaÃ§Ã£o de Marca
  - EssÃªncia: fixar tema, aguardar fontes/layout estÃ¡vel, tolerÃ¢ncias visuais; preservar tokens e densidade.
  - Onde aplicar: SeÃ§Ãµes 21 (Playwright), 38 (Identidade Visual), 48 (MÃ©tricas PIV).

- PolÃ­tica de VersÃµes LTS ObrigatÃ³ria
  - EssÃªncia: usar apenas versÃµes LTS de tecnologias crÃ­ticas (Node.js, frameworks, databases); validaÃ§Ã£o automÃ¡tica no CI/CD.
  - Onde aplicar: SeÃ§Ã£o 76 (VersÃµes LTS), 7 (CI/CD), 67 (Dev Environment), 24 (Kubernetes).

- PadrÃµes Serverless AWS Lambda Consolidados
  - EssÃªncia: estrutura padronizada, middleware Middy, esbuild, warmup, observabilidade e testes locais com serverless-offline.
  - Onde aplicar: SeÃ§Ã£o 77 (Serverless Framework), 8 (Observabilidade), 6 (Testes), 19 (Performance).

Checklist de RetenÃ§Ã£o de LiÃ§Ãµes
- [ ] Protocolos de seguranÃ§a ativos em mudanÃ§as massivas
- [ ] AnÃ¡lise de frequÃªncia e concentraÃ§Ã£o aplicada
- [ ] PadrÃµes de Date/Time e conversÃµes documentados e validados em CI
- [ ] EstratÃ©gias EF Core/queries revisadas
- [ ] Repos/contratos unificados; sem duplicaÃ§Ãµes
- [ ] MediÃ§Ã£o do efeito cascata
- [ ] EstratÃ©gia Simplesâ†’MÃ©dioâ†’Complexo adotada
- [ ] PadrÃµes TypeScript/Signals no frontend
- [ ] Determinismo visual + preservaÃ§Ã£o de identidade
- [ ] PolÃ­tica de versÃµes LTS implementada e validada automaticamente
- [ ] PadrÃµes serverless AWS Lambda aplicados com observabilidade completa



## 56) API Governance e Versionamento
56.1 PrincÃ­pios
- Contratos como fonte da verdade (OpenAPI/GraphQL SDL geram SDKs/clients/validaÃ§Ãµes);
- Backward compatibility: mudanÃ§as breaking exigem nova versÃ£o (major) e janela de depreciaÃ§Ã£o;
- Disciplina de mudanÃ§as: changelog por versÃ£o, migraÃ§Ã£o documentada, exemplos.

59.2 PadrÃ£o de versionamento (REST)
- `Accept: application/vnd.yourproject.v{major}+json` ou path `/v{major}`;
- DepreciaÃ§Ã£o: header `Deprecation: true` e `Sunset: <date>`; endpoint `/status` lista versÃµes suportadas.

59.3 PolÃ­ticas de breaking changes
- Proibido: remover campos, mudar tipos, trocar semÃ¢ntica de status HTTP, alterar IDs/ordenamentos default;
- Permitido sem major: adicionar campos opcionais, novos endpoints, novos erros com `type` especÃ­fico (RFC 7807).

59.4 GovernanÃ§a do ciclo
- RFC interna para propostas; revisÃ£o tÃ©cnica + produto; canary em clientes crÃ­ticos; mÃ©trica de adoÃ§Ã£o por versÃ£o.

59.5 Linters/validaÃ§Ãµes
- Validar OpenAPI no CI; testes de contrato; snapshot de schemas; diffs semÃ¢nticos (ex.: openapi-diff) bloqueiam breaking.

---

## 57) ConvenÃ§Ãµes de Commits, Branches e Releases
57.1 Commits (Conventional Commits)
- `feat:`, `fix:`, `docs:`, `refactor:`, `perf:`, `test:`, `ci:`, `build:`, `chore:`; `BREAKING CHANGE:` no body quando aplicÃ¡vel;
- Mensagens curtas (â‰¤ 72 chars), corpo explicativo quando necessÃ¡rio, referÃªncia a issue.

60.2 Branches
- `main`: produÃ§Ã£o; `develop` (opcional); `feature/*`, `bugfix/*`, `hotfix/*`, `release/*`;
- ProteÃ§Ãµes: reviews obrigatÃ³rios, checks verdes, commits assinados, bloqueio de forceâ€‘push.

60.3 Releases
- SemVer; changelog gerado (commitlint + changelog generator);
- Tags anotadas; release notes com riscos/rollback; feature flags para rollouts graduais.

---

## 58) Dados de Teste, Mascaramento e SÃ­ntese
58.1 PrincÃ­pios
- Zero PII real em desenvolvimento; ambientes de teste com dados mascarados/sintÃ©ticos;
- Conjuntos reprodutÃ­veis (seeds) e documentaÃ§Ã£o de geraÃ§Ã£o.

61.2 Mascaramento
- Hash/salt para identificadores; truncar textos sensÃ­veis; aleatorizar datas dentro de janelas;
- Garantir integridade referencial (mesmos IDs tÃªm mascaras consistentes).

61.3 SÃ­ntese de dados
- Geradores por domÃ­nio (faker com regras); catÃ¡logos de cenÃ¡rios (happy/edge/error);
- Contratos como guia (OpenAPI/JSON Schema â†’ geradores de payloads vÃ¡lidos).

61.4 AutomaÃ§Ã£o no CI
- Jobs que preparam bancos de teste com seeds/migraÃ§Ãµes idempotentes; limpeza apÃ³s execuÃ§Ã£o;
- Storage de fixtures versionado; validaÃ§Ã£o de volume/performance para testes de carga.

## 59) Taxonomia de Erros e CorrelaÃ§Ã£o
59.1 Taxonomia
- NegÃ³cio (ex.: `BusinessRuleViolation`, `InvalidState`), TÃ©cnica (ex.: `Timeout`, `IntegrationError`, `ValidationError`), SeguranÃ§a (ex.: `Unauthorized`, `Forbidden`), Infra (ex.: `ResourceExhausted`).
- Normalizar `code`, `type`, `message`, `details` (Problem Details para HTTP) e mapear severidade.

62.2 CorrelaÃ§Ã£o
- `correlationId` gerado na borda (gateway/API) e propagado por serviÃ§os (headers/trace context);
- Logs estruturados SEM PII; sempre incluir `correlationId`, `service`, `version`, `env`.

62.3 Mapeamento HTTP
- 4xx para erros de cliente (validaÃ§Ã£o/negÃ³cio) com Problem Details; 5xx para falhas tÃ©cnicas/infra.

62.4 MÃ©tricas & Alertas
- Contar por `type/code` e severidade; alertas baseados em taxa (erro/min) e burnâ€‘rate SLO; dashboards com heatmap por categoria.

---

## 60) FinOps/Cloud Cost Management
60.1 PrincÃ­pios
- Visibilidade: custos por serviÃ§o/ambiente/tenant (tags/labels obrigatÃ³rias);
- OtimizaÃ§Ã£o contÃ­nua: rightsizing, escalonamento dinÃ¢mico, polÃ­ticas de hibernaÃ§Ã£o em dev/staging;
- OrÃ§amentos e alertas: budget mensal com thresholds e aÃ§Ãµes (notificar/pausar workloads nÃ£o crÃ­ticos).

63.2 PrÃ¡ticas
- Autoscaling com limites; evitar sobreprovisionamento; spot/preemptible onde fizer sentido;
- Caching/CDN para reduzir trÃ¡fego/latÃªncia/custo; compactaÃ§Ã£o e polÃ­ticas de retenÃ§Ã£o de logs/metrics;
- Auditoria de recursos Ã³rfÃ£os (discos, IPs, snapshots), polÃ­tica de lifecycle para buckets.

63.3 MÃ©tricas
- Custo/request, custo/tenant, custo por feature; eficiÃªncia (R$/aprov. transaÃ§Ã£o); projeÃ§Ã£o versus orÃ§amento.

---

## 61) Backup/DR â€“ PolÃ­tica e Testes
61.1 PolÃ­tica
- RPO/RTO definidos por sistema; classes de criticidade com frequÃªncias de backup (ex.: P1: horÃ¡rio; P2: diÃ¡rio);
- Criptografia em repouso; catÃ¡logo de locais (regiÃ£o primÃ¡ria/secundÃ¡ria), retenÃ§Ã£o por compliance.

64.2 Procedimentos
- Backups consistentes de banco/arquivos; snapshots de infra; verificaÃ§Ã£o de integridade (checksums);
- ExecuÃ§Ã£o de restores em ambientes de teste; documentaÃ§Ã£o de runbook (passo a passo, owners, tempos).

64.3 Testes de DR
- Drills trimestrais: simular desastre, executar restore, medir RPO/RTO, ajustar plano;
- Lista de verificaÃ§Ã£o pÃ³sâ€‘restore: serviÃ§os crÃ­ticos OK, dados Ã­ntegros, acessos funcionais, observabilidade ativa.

## 62) Regras de InteraÃ§Ã£o (Chat/Agente)
62.1 Idioma e estilo
- Todas as interaÃ§Ãµes com usuÃ¡rios devem ser respondidas em **portuguÃªs** (ptâ€‘BR), salvo solicitaÃ§Ã£o explÃ­cita em outro idioma;
- Mensagens claras e objetivas; bullets para aÃ§Ãµes; destacar riscos/decisÃµes; evitar jargÃµes sem explicar.

65.2 ConteÃºdo tÃ©cnico
- Sempre indicar caminhos de arquivo com crase (ex.: `src/pages/Home.tsx`); usar blocos de cÃ³digo quando Ãºtil;
- Ao sugerir mudanÃ§as, fornecer snippet mÃ­nimo e contexto; evitar â€œsimulaÃ§Ãµesâ€ de cÃ³digo que nÃ£o compilem.

65.3 SeguranÃ§a e confidencialidade
- Nunca expor segredos/credenciais; omitir/redigir dados sensÃ­veis; orientar sobre armazenamento seguro (env/secret manager);
- Em dÃºvidas sobre compliance, apontar riscos e sugerir envolvimento de responsÃ¡veis (seguranÃ§a/privacidade).

65.4 Limites e transparÃªncia
- Assumir suposiÃ§Ãµes explicitamente; pedir confirmaÃ§Ã£o quando o risco de ambiguidade for alto;
- Se necessÃ¡rio, propor passos para validaÃ§Ã£o (build/test/preview) antes de mudanÃ§as amplas.

## 63) Data Governance e Lineage
63.1 CatÃ¡logo e ownership
- CatÃ¡logo de dados (tabelas, eventos, streams), owners claros (tÃ©cnico/negÃ³cio), SLAs de qualidade; glossary/UB.

66.2 Qualidade e lineage
- Regras de qualidade (completude, unicidade, atualidade) com mÃ©tricas e alertas; lineage fimâ€‘aâ€‘fim para auditoria.

66.3 RetenÃ§Ã£o e arquivamento
- PolÃ­ticas por tipo de dado (operacional/analÃ­tico/PII); arquivamento e eliminaÃ§Ã£o segura conforme compliance.

## 64) Telemetria de Produto
64.1 Taxonomia de eventos
- ConvenÃ§Ãµes de nomes, propriedades obrigatÃ³rias (userId/anonId, tenant, device, versÃ£o), consentimento (LGPD/GDPR);
- Amostragem e limites para evitar saturaÃ§Ã£o/custos; tratamento de PII (hash/pseudonimizaÃ§Ã£o) quando aplicÃ¡vel.

67.2 Dashboards e KPIs
- Funil, coortes, retenÃ§Ã£o, erro por etapa, tempo de tarefa; relacionar com SLOs tÃ©cnicos (latÃªncia/erros).

## 65) Dev Environment PadrÃ£o
65.1 Facilidades de dev
- `make up/down/test/lint` (ou scripts npm) para tarefas comuns; Dev Containers/direnv; `.env.example` completo;
- Seeds determinÃ­sticos; â€œoneâ€‘command upâ€ com dockerâ€‘compose (DB/Redis/Mock APIs) e documentaÃ§Ã£o do fluxo.

## 66) Monorepo vs Polyrepo
66.1 CritÃ©rios
- Monorepo: compartilhamento forte de libs, atomia de mudanÃ§as, ferramentas de cache (Nx/Turborepo);
- Polyrepo: isolamento de ciclo de vida, compliance, times independentes; comunicaÃ§Ã£o via contratos.

69.2 PrÃ¡ticas
- Cache remoto em CI; pipelines por escopo; releases versionadas por pacote (quando aplicÃ¡vel); limites de acoplamento.

## 67) Multiâ€‘RegiÃ£o
67.1 EstratÃ©gias
- Activeâ€‘passive vs activeâ€‘active; roteamento (GeoDNS/Anycast), replicaÃ§Ã£o de dados (assÃ­ncrona/sÃ­ncrona), consistÃªncia;
- Testes de failover programados; observabilidade separada por regiÃ£o.

## 68) Mobile (se aplicÃ¡vel)
68.1 Pipelines e Deploy
- Assinaturas/Perfis (iOS/Android), automaÃ§Ã£o de uploads (TestFlight/Play Store), controle de versÃµes/OTA;
- Privacidade em SDKs de analytics/ads; feature flags e canary em apps.

74.2 Performance e Debugging (React Native)
- **Release builds obrigatÃ³rios**: performance testing sempre em `dev=false`;
- **Profiling nativo**: Android Studio System Tracing, Xcode Instruments;
- **Threading awareness**: identificar UI Thread, JS Thread (`mqt_js`), Native Modules Thread (`mqt_native_modules`);
- **InteractionManager**: usar para diferir tarefas nÃ£o crÃ­ticas durante navegaÃ§Ã£o;
- **Debugging**: usar `debugger;` statements; `npx react-native log-android`/`log-ios` para logs nativos.

74.3 PadrÃµes EspecÃ­ficos (React Native)
- **Platform-specific code**: `.native.js` para cÃ³digo compartilhado; `.ios.js`/`.android.js` para especÃ­ficos;
- **Native Modules**: lifecycle management, type-safety com Codegen, logging customizado com tags especÃ­ficos;
- **Cross-platform logic**: C++ para lÃ³gica compartilhada crÃ­tica, JSI para bridging eficiente;
- **Navigation**: otimizar transiÃ§Ãµes com `LayoutAnimation`; evitar trabalho pesado em `componentDidMount`.

74.4 Exemplos PrÃ¡ticos

74.4.1 Estrutura de Arquivos Platform-Specific
```
Container.js          # Web/Node bundlers
Container.native.js   # React Native (Android + iOS)
Container.ios.js      # iOS especÃ­fico
Container.android.js  # Android especÃ­fico
```

74.4.2 Estrutura de Pastas React Native
**Projeto pequeno/mÃ©dio (< 50 telas)**
```
src/
â”œâ”€â”€ components/           # Componentes reutilizÃ¡veis
â”‚   â”œâ”€â”€ ui/              # Componentes base (Button, Input, etc.)
â”‚   â””â”€â”€ business/        # Componentes de negÃ³cio
â”œâ”€â”€ screens/             # Telas da aplicaÃ§Ã£o
â”‚   â”œâ”€â”€ Auth/
â”‚   â”œâ”€â”€ Home/
â”‚   â””â”€â”€ Profile/
â”œâ”€â”€ navigation/          # ConfiguraÃ§Ã£o de navegaÃ§Ã£o
â”‚   â”œâ”€â”€ AppNavigator.tsx
â”‚   â”œâ”€â”€ AuthNavigator.tsx
â”‚   â””â”€â”€ types.ts
â”œâ”€â”€ services/            # APIs e integraÃ§Ãµes
â”‚   â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ storage/
â”‚   â””â”€â”€ notifications/
â”œâ”€â”€ hooks/               # Custom hooks
â”œâ”€â”€ utils/               # UtilitÃ¡rios e helpers
â”œâ”€â”€ constants/           # Constantes da aplicaÃ§Ã£o
â”œâ”€â”€ types/               # DefiniÃ§Ãµes TypeScript
â”œâ”€â”€ assets/              # Imagens, fontes, etc.
â”‚   â”œâ”€â”€ images/
â”‚   â”‚   â”œâ”€â”€ @1x/         # Densidade padrÃ£o
â”‚   â”‚   â”œâ”€â”€ @2x/         # Densidade 2x
â”‚   â”‚   â””â”€â”€ @3x/         # Densidade 3x
â”‚   â”œâ”€â”€ fonts/
â”‚   â””â”€â”€ icons/
â”œâ”€â”€ native/              # MÃ³dulos nativos customizados
â”‚   â”œâ”€â”€ android/
â”‚   â””â”€â”€ ios/
â””â”€â”€ styles/              # Estilos globais e temas
    â”œâ”€â”€ colors.ts
    â”œâ”€â”€ typography.ts
    â”œâ”€â”€ spacing.ts
    â””â”€â”€ theme.ts
```

**Projeto grande (> 50 telas) - Feature-First**
```
src/
â”œâ”€â”€ shared/              # CÃ³digo compartilhado
â”‚   â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ types/
â”‚   â””â”€â”€ constants/
â”œâ”€â”€ features/            # Features organizadas por domÃ­nio
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ screens/
â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â””â”€â”€ types/
â”‚   â”œâ”€â”€ ecommerce/
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ screens/
â”‚   â”‚   â”‚   â”œâ”€â”€ ProductList/
â”‚   â”‚   â”‚   â”œâ”€â”€ ProductDetail/
â”‚   â”‚   â”‚   â””â”€â”€ Cart/
â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â””â”€â”€ types/
â”‚   â””â”€â”€ profile/
â”œâ”€â”€ navigation/
â”œâ”€â”€ assets/
â”œâ”€â”€ native/
â””â”€â”€ styles/
```

74.4.3 ConvenÃ§Ãµes de Nomenclatura
- **Screens**: PascalCase + "Screen" (ex: `ProductListScreen.tsx`)
- **Components**: PascalCase (ex: `ProductCard.tsx`)
- **Hooks**: camelCase + "use" prefix (ex: `useProductData.ts`)
- **Services**: camelCase + "Service" suffix (ex: `authService.ts`)
- **Types**: PascalCase + "Type" suffix (ex: `ProductType.ts`)
- **Assets**: kebab-case (ex: `product-placeholder.png`)

74.4.4 Arquivos de ConfiguraÃ§Ã£o Essenciais
```
project-root/
â”œâ”€â”€ metro.config.js      # Bundler configuration
â”œâ”€â”€ babel.config.js      # Transpilation rules
â”œâ”€â”€ react-native.config.js # Native dependencies
â”œâ”€â”€ tsconfig.json        # TypeScript configuration
â”œâ”€â”€ .eslintrc.js         # Linting rules
â”œâ”€â”€ .prettierrc          # Code formatting
â”œâ”€â”€ app.json            # App metadata
â”œâ”€â”€ package.json        # Dependencies
â””â”€â”€ index.js            # Entry point
```

74.4.5 Native Module (Android)
```java
@ReactMethod
public void processData(String input, Promise promise) {
    try {
        String result = "Processed: " + input;
        Log.d("MyModule", "Processing: " + input);
        promise.resolve(result);
    } catch (Exception e) {
        promise.reject("PROCESS_ERROR", e.getMessage(), e);
    }
}
```

## 69) Acessibilidade em Canais Digitais - PadrÃµes WCAG e ImplementaÃ§Ã£o
<!-- tags: accessibility, wcag, a11y, digital-channels, inclusive-design, compliance -->
<!-- category: frontend-standards -->
<!-- priority: high -->
<!-- audience: frontend-developers, ux-designers, qa-engineers, product-owners -->

**Objetivo**: Estabelecer padrÃµes obrigatÃ³rios de acessibilidade para canais digitais, garantindo conformidade WCAG 2.1/2.2 AA e inclusÃ£o digital efetiva.

### 69.1 PrincÃ­pios Fundamentais

**69.1.1 Conformidade WCAG ObrigatÃ³ria**
- **WCAG 2.1 AA**: padrÃ£o mÃ­nimo obrigatÃ³rio para todos os canais digitais
- **WCAG 2.2 AA**: recomendado para novos projetos (inclui melhorias em mobile e cognitivas)
- **Testes automatizados**: integraÃ§Ã£o obrigatÃ³ria no pipeline CI/CD
- **Auditoria manual**: validaÃ§Ã£o trimestral por especialista em acessibilidade

**69.1.2 Quatro Pilares da Acessibilidade**
1. **PerceptÃ­vel**: informaÃ§Ã£o apresentada de forma que usuÃ¡rios possam perceber
2. **OperÃ¡vel**: interface utilizÃ¡vel por todos os usuÃ¡rios
3. **CompreensÃ­vel**: informaÃ§Ã£o e operaÃ§Ã£o da interface compreensÃ­veis
4. **Robusto**: conteÃºdo interpretÃ¡vel por ampla variedade de tecnologias assistivas

### 69.2 ImplementaÃ§Ã£o TÃ©cnica ObrigatÃ³ria

**69.2.1 Estrutura SemÃ¢ntica**
```html
<!-- âœ… Correto: Estrutura semÃ¢ntica clara -->
<header role="banner">
  <nav role="navigation" aria-label="Menu principal">
    <ul>
      <li><a href="/home" aria-current="page">InÃ­cio</a></li>
      <li><a href="/products">Produtos</a></li>
    </ul>
  </nav>
</header>

<main role="main">
  <h1>TÃ­tulo Principal da PÃ¡gina</h1>
  <section aria-labelledby="products-heading">
    <h2 id="products-heading">Nossos Produtos</h2>
    <!-- conteÃºdo -->
  </section>
</main>

<aside role="complementary" aria-label="InformaÃ§Ãµes relacionadas">
  <!-- conteÃºdo lateral -->
</aside>

<footer role="contentinfo">
  <!-- rodapÃ© -->
</footer>
```

**69.2.2 FormulÃ¡rios AcessÃ­veis**
```html
<!-- âœ… Correto: FormulÃ¡rio com labels e validaÃ§Ã£o acessÃ­vel -->
<form novalidate>
  <div class="form-group">
    <label for="email" class="required">
      E-mail
      <span aria-label="campo obrigatÃ³rio">*</span>
    </label>
    <input 
      type="email" 
      id="email" 
      name="email"
      required
      aria-describedby="email-error email-help"
      aria-invalid="false"
    />
    <div id="email-help" class="help-text">
      Digite seu endereÃ§o de e-mail vÃ¡lido
    </div>
    <div id="email-error" class="error-message" role="alert" aria-live="polite">
      <!-- mensagem de erro inserida dinamicamente -->
    </div>
  </div>
  
  <fieldset>
    <legend>PreferÃªncias de contato</legend>
    <div class="radio-group" role="radiogroup" aria-labelledby="contact-legend">
      <input type="radio" id="contact-email" name="contact" value="email">
      <label for="contact-email">E-mail</label>
      
      <input type="radio" id="contact-phone" name="contact" value="phone">
      <label for="contact-phone">Telefone</label>
    </div>
  </fieldset>
  
  <button type="submit" aria-describedby="submit-help">
    Enviar FormulÃ¡rio
  </button>
  <div id="submit-help" class="sr-only">
    Pressione Enter ou clique para enviar o formulÃ¡rio
  </div>
</form>
```

**69.2.3 NavegaÃ§Ã£o por Teclado**
```typescript
// Gerenciamento de foco e navegaÃ§Ã£o por teclado
class KeyboardNavigation {
  private focusableElements: NodeListOf<HTMLElement>;
  private currentIndex: number = 0;

  constructor(container: HTMLElement) {
    this.focusableElements = container.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
    this.setupKeyboardListeners();
  }

  private setupKeyboardListeners(): void {
    document.addEventListener('keydown', (event) => {
      switch (event.key) {
        case 'Tab':
          this.handleTabNavigation(event);
          break;
        case 'Escape':
          this.handleEscapeKey(event);
          break;
        case 'ArrowDown':
        case 'ArrowUp':
          if (this.isInMenu(event.target as HTMLElement)) {
            event.preventDefault();
            this.handleArrowNavigation(event.key);
          }
          break;
      }
    });
  }

  private handleTabNavigation(event: KeyboardEvent): void {
    // Implementar trap de foco para modais
    if (this.isInModal(event.target as HTMLElement)) {
      const firstElement = this.focusableElements[0];
      const lastElement = this.focusableElements[this.focusableElements.length - 1];
      
      if (event.shiftKey && event.target === firstElement) {
        event.preventDefault();
        lastElement.focus();
      } else if (!event.shiftKey && event.target === lastElement) {
        event.preventDefault();
        firstElement.focus();
      }
    }
  }

  private announceToScreenReader(message: string): void {
    const announcement = document.createElement('div');
    announcement.setAttribute('aria-live', 'polite');
    announcement.setAttribute('aria-atomic', 'true');
    announcement.className = 'sr-only';
    announcement.textContent = message;
    
    document.body.appendChild(announcement);
    setTimeout(() => document.body.removeChild(announcement), 1000);
  }
}
```

**69.2.4 Contraste e Cores**
```scss
// Tokens de acessibilidade obrigatÃ³rios
:root {
  /* Contrastes WCAG AA (4.5:1 para texto normal, 3:1 para texto grande) */
  --text-primary: #1a1a1a;        /* Contraste 16.94:1 com branco */
  --text-secondary: #4a4a4a;      /* Contraste 9.74:1 com branco */
  --text-muted: #6b6b6b;          /* Contraste 6.61:1 com branco */
  
  /* Estados de foco visÃ­veis */
  --focus-ring: 2px solid #005fcc;
  --focus-ring-offset: 2px;
  
  /* Estados de erro acessÃ­veis */
  --error-color: #d32f2f;         /* Contraste 5.93:1 com branco */
  --error-bg: #ffebee;            /* Fundo suave para erros */
  
  /* Estados de sucesso acessÃ­veis */
  --success-color: #2e7d32;       /* Contraste 6.47:1 com branco */
  --success-bg: #e8f5e8;          /* Fundo suave para sucessos */
}

// Mixin para foco visÃ­vel obrigatÃ³rio
@mixin accessible-focus {
  &:focus {
    outline: var(--focus-ring);
    outline-offset: var(--focus-ring-offset);
    box-shadow: 0 0 0 var(--focus-ring-offset) rgba(0, 95, 204, 0.2);
  }
  
  &:focus:not(:focus-visible) {
    outline: none;
    box-shadow: none;
  }
}

// Classes utilitÃ¡rias obrigatÃ³rias
.sr-only {
  position: absolute !important;
  width: 1px !important;
  height: 1px !important;
  padding: 0 !important;
  margin: -1px !important;
  overflow: hidden !important;
  clip: rect(0, 0, 0, 0) !important;
  white-space: nowrap !important;
  border: 0 !important;
}

.skip-link {
  position: absolute;
  top: -40px;
  left: 6px;
  background: var(--text-primary);
  color: white;
  padding: 8px;
  text-decoration: none;
  z-index: 9999;
  
  &:focus {
    top: 6px;
  }
}
```

### 69.3 Componentes AcessÃ­veis ObrigatÃ³rios

**69.3.1 Modal/Dialog AcessÃ­vel**
```typescript
interface AccessibleModalProps {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  children: React.ReactNode;
  initialFocus?: React.RefObject<HTMLElement>;
}

export const AccessibleModal: React.FC<AccessibleModalProps> = ({
  isOpen,
  onClose,
  title,
  children,
  initialFocus
}) => {
  const modalRef = useRef<HTMLDivElement>(null);
  const previousFocus = useRef<HTMLElement | null>(null);

  useEffect(() => {
    if (isOpen) {
      // Salvar foco anterior
      previousFocus.current = document.activeElement as HTMLElement;
      
      // Focar elemento inicial ou primeiro focÃ¡vel
      const focusTarget = initialFocus?.current || 
        modalRef.current?.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])') as HTMLElement;
      
      focusTarget?.focus();
      
      // Prevenir scroll do body
      document.body.style.overflow = 'hidden';
      
      return () => {
        // Restaurar foco anterior
        previousFocus.current?.focus();
        document.body.style.overflow = '';
      };
    }
  }, [isOpen, initialFocus]);

  if (!isOpen) return null;

  return (
    <div 
      className="modal-overlay" 
      role="dialog" 
      aria-modal="true"
      aria-labelledby="modal-title"
      ref={modalRef}
      onClick={(e) => e.target === e.currentTarget && onClose()}
    >
      <div className="modal-content">
        <header className="modal-header">
          <h2 id="modal-title">{title}</h2>
          <button 
            type="button" 
            className="modal-close"
            onClick={onClose}
            aria-label="Fechar modal"
          >
            Ã—
          </button>
        </header>
        <div className="modal-body">
          {children}
        </div>
      </div>
    </div>
  );
};
```

**69.3.2 Dropdown/Select AcessÃ­vel**
```typescript
export const AccessibleSelect: React.FC<{
  options: Array<{value: string; label: string}>;
  value: string;
  onChange: (value: string) => void;
  label: string;
  required?: boolean;
  error?: string;
}> = ({ options, value, onChange, label, required, error }) => {
  const [isOpen, setIsOpen] = useState(false);
  const [activeIndex, setActiveIndex] = useState(-1);
  const selectRef = useRef<HTMLDivElement>(null);

  const handleKeyDown = (event: React.KeyboardEvent) => {
    switch (event.key) {
      case 'Enter':
      case ' ':
        event.preventDefault();
        if (isOpen && activeIndex >= 0) {
          onChange(options[activeIndex].value);
          setIsOpen(false);
        } else {
          setIsOpen(!isOpen);
        }
        break;
      case 'ArrowDown':
        event.preventDefault();
        if (!isOpen) {
          setIsOpen(true);
        } else {
          setActiveIndex(prev => Math.min(prev + 1, options.length - 1));
        }
        break;
      case 'ArrowUp':
        event.preventDefault();
        if (isOpen) {
          setActiveIndex(prev => Math.max(prev - 1, 0));
        }
        break;
      case 'Escape':
        setIsOpen(false);
        setActiveIndex(-1);
        break;
    }
  };

  return (
    <div className="select-container" ref={selectRef}>
      <label htmlFor="custom-select" className={required ? 'required' : ''}>
        {label}
        {required && <span aria-label="campo obrigatÃ³rio">*</span>}
      </label>
      
      <div
        id="custom-select"
        role="combobox"
        aria-expanded={isOpen}
        aria-haspopup="listbox"
        aria-labelledby="select-label"
        aria-describedby={error ? "select-error" : undefined}
        aria-invalid={!!error}
        tabIndex={0}
        className={`select-trigger ${error ? 'error' : ''}`}
        onClick={() => setIsOpen(!isOpen)}
        onKeyDown={handleKeyDown}
      >
        {options.find(opt => opt.value === value)?.label || 'Selecione...'}
        <span className="select-arrow" aria-hidden="true">â–¼</span>
      </div>

      {isOpen && (
        <ul
          role="listbox"
          className="select-options"
          aria-labelledby="select-label"
        >
          {options.map((option, index) => (
            <li
              key={option.value}
              role="option"
              aria-selected={option.value === value}
              className={`select-option ${index === activeIndex ? 'active' : ''} ${option.value === value ? 'selected' : ''}`}
              onClick={() => {
                onChange(option.value);
                setIsOpen(false);
              }}
            >
              {option.label}
            </li>
          ))}
        </ul>
      )}

      {error && (
        <div id="select-error" className="error-message" role="alert">
          {error}
        </div>
      )}
    </div>
  );
};
```

### 69.4 Testes de Acessibilidade ObrigatÃ³rios

**69.4.1 Testes Automatizados**
```typescript
// Jest + Testing Library + axe-core
import { render, screen } from '@testing-library/react';
import { axe, toHaveNoViolations } from 'jest-axe';
import userEvent from '@testing-library/user-event';

expect.extend(toHaveNoViolations);

describe('Accessibility Tests', () => {
  test('should not have accessibility violations', async () => {
    const { container } = render(<MyComponent />);
    const results = await axe(container);
    expect(results).toHaveNoViolations();
  });

  test('should be navigable by keyboard', async () => {
    const user = userEvent.setup();
    render(<MyForm />);
    
    // Testar navegaÃ§Ã£o por Tab
    await user.tab();
    expect(screen.getByLabelText('Nome')).toHaveFocus();
    
    await user.tab();
    expect(screen.getByLabelText('E-mail')).toHaveFocus();
    
    // Testar envio por Enter
    await user.keyboard('{Enter}');
    expect(mockSubmit).toHaveBeenCalled();
  });

  test('should announce changes to screen readers', async () => {
    const user = userEvent.setup();
    render(<SearchComponent />);
    
    const searchInput = screen.getByLabelText('Buscar produtos');
    await user.type(searchInput, 'notebook');
    
    // Verificar se regiÃ£o live foi atualizada
    expect(screen.getByRole('status')).toHaveTextContent('5 resultados encontrados');
  });

  test('should have proper ARIA attributes', () => {
    render(<AccessibleModal isOpen={true} title="Confirmar aÃ§Ã£o" onClose={jest.fn()} />);
    
    const modal = screen.getByRole('dialog');
    expect(modal).toHaveAttribute('aria-modal', 'true');
    expect(modal).toHaveAttribute('aria-labelledby', 'modal-title');
    
    const title = screen.getByRole('heading', { level: 2 });
    expect(title).toHaveAttribute('id', 'modal-title');
  });
});
```

**69.4.2 Pipeline CI/CD com Acessibilidade**
```yaml
# .github/workflows/accessibility.yml
name: Accessibility Tests

on: [push, pull_request]

jobs:
  a11y-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run accessibility tests
        run: npm run test:a11y
      
      - name: Build application
        run: npm run build
      
      - name: Run Lighthouse CI
        run: |
          npm install -g @lhci/cli
          lhci autorun
        env:
          LHCI_GITHUB_APP_TOKEN: ${{ secrets.LHCI_GITHUB_APP_TOKEN }}
      
      - name: Run axe-core tests
        run: |
          npm start &
          sleep 10
          npx axe-cli http://localhost:3000 --exit
```

### 69.5 Ferramentas e ValidaÃ§Ã£o

**69.5.1 Ferramentas ObrigatÃ³rias**
- **axe-core**: testes automatizados integrados ao pipeline
- **Lighthouse**: auditoria de performance e acessibilidade
- **WAVE**: validaÃ§Ã£o manual durante desenvolvimento
- **Screen readers**: NVDA (Windows), VoiceOver (macOS), TalkBack (Android)
- **Keyboard testing**: navegaÃ§Ã£o completa sem mouse

**69.5.2 ConfiguraÃ§Ã£o ESLint para Acessibilidade**
```json
{
  "extends": [
    "plugin:jsx-a11y/recommended"
  ],
  "plugins": ["jsx-a11y"],
  "rules": {
    "jsx-a11y/alt-text": "error",
    "jsx-a11y/anchor-has-content": "error",
    "jsx-a11y/aria-props": "error",
    "jsx-a11y/aria-proptypes": "error",
    "jsx-a11y/aria-unsupported-elements": "error",
    "jsx-a11y/click-events-have-key-events": "error",
    "jsx-a11y/heading-has-content": "error",
    "jsx-a11y/label-has-associated-control": "error",
    "jsx-a11y/no-autofocus": "error",
    "jsx-a11y/no-redundant-roles": "error",
    "jsx-a11y/role-has-required-aria-props": "error",
    "jsx-a11y/role-supports-aria-props": "error"
  }
}
```

### 69.6 Checklist de Acessibilidade ObrigatÃ³rio

**69.6.1 Estrutura e SemÃ¢ntica**
- [ ] Hierarquia de headings (h1-h6) lÃ³gica e sequencial
- [ ] Landmarks semÃ¢nticos (header, nav, main, aside, footer)
- [ ] Roles ARIA apropriados quando necessÃ¡rio
- [ ] Estrutura de listas para conteÃºdo relacionado
- [ ] Links descritivos (evitar "clique aqui", "saiba mais")

**69.6.2 FormulÃ¡rios**
- [ ] Labels associados a todos os inputs (htmlFor/id)
- [ ] Fieldsets e legends para grupos de campos relacionados
- [ ] Mensagens de erro associadas aos campos (aria-describedby)
- [ ] Estados de validaÃ§Ã£o comunicados (aria-invalid)
- [ ] Campos obrigatÃ³rios identificados (required + indicaÃ§Ã£o visual)

**69.6.3 NavegaÃ§Ã£o e InteraÃ§Ã£o**
- [ ] NavegaÃ§Ã£o completa por teclado (Tab, Shift+Tab, Enter, Escape)
- [ ] Foco visÃ­vel em todos os elementos interativos
- [ ] Skip links para navegaÃ§Ã£o rÃ¡pida
- [ ] Trap de foco em modais e overlays
- [ ] Atalhos de teclado documentados quando aplicÃ¡vel

**69.6.4 ConteÃºdo e MÃ­dia**
- [ ] Textos alternativos em todas as imagens informativas
- [ ] Contraste mÃ­nimo 4.5:1 para texto normal, 3:1 para texto grande
- [ ] InformaÃ§Ã£o nÃ£o dependente apenas de cor
- [ ] Legendas em vÃ­deos e transcriÃ§Ãµes em Ã¡udios
- [ ] AnimaÃ§Ãµes respeitam prefers-reduced-motion

**69.6.5 Estados e Feedback**
- [ ] Estados de loading comunicados aos screen readers
- [ ] MudanÃ§as dinÃ¢micas anunciadas (aria-live)
- [ ] Mensagens de sucesso e erro acessÃ­veis
- [ ] Progresso de tarefas longas comunicado
- [ ] Estados de componentes interativos claros (expandido/colapsado)

**69.6.6 Testes e ValidaÃ§Ã£o**
- [ ] Testes automatizados com axe-core passando
- [ ] NavegaÃ§Ã£o testada apenas com teclado
- [ ] Testado com screen reader (NVDA, VoiceOver ou TalkBack)
- [ ] Lighthouse Accessibility score â‰¥ 95
- [ ] ValidaÃ§Ã£o manual com usuÃ¡rios com deficiÃªncia (recomendado)

### 69.7 Responsabilidades e GovernanÃ§a

**69.7.1 PapÃ©is e Responsabilidades**
- **Desenvolvedores**: implementaÃ§Ã£o tÃ©cnica, testes automatizados, code review
- **Designers**: especificaÃ§Ãµes de contraste, estados de foco, fluxos inclusivos
- **QA**: testes manuais, validaÃ§Ã£o com tecnologias assistivas
- **Product Owners**: priorizaÃ§Ã£o de correÃ§Ãµes, definiÃ§Ã£o de critÃ©rios de aceitaÃ§Ã£o
- **Arquitetos**: padrÃµes tÃ©cnicos, integraÃ§Ã£o no pipeline, treinamento

**69.7.2 Processo de AprovaÃ§Ã£o**
- **Definition of Ready**: critÃ©rios de acessibilidade incluÃ­dos nas user stories
- **Definition of Done**: checklist de acessibilidade obrigatÃ³rio
- **Code Review**: validaÃ§Ã£o de padrÃµes de acessibilidade
- **QA Sign-off**: testes manuais e automatizados aprovados
- **Release**: auditoria de acessibilidade em produÃ§Ã£o

**69.7.3 MÃ©tricas e KPIs**
- **Cobertura de testes**: % de componentes com testes de acessibilidade
- **Lighthouse Score**: mÃ©dia â‰¥ 95 em acessibilidade
- **ViolaÃ§Ãµes axe-core**: zero violaÃ§Ãµes crÃ­ticas em produÃ§Ã£o
- **Tempo de correÃ§Ã£o**: SLA para correÃ§Ã£o de issues de acessibilidade
- **SatisfaÃ§Ã£o do usuÃ¡rio**: feedback de usuÃ¡rios com deficiÃªncia

### 69.8 Recursos e Treinamento

**69.8.1 DocumentaÃ§Ã£o de ReferÃªncia**
- [WCAG 2.1 Guidelines](https://www.w3.org/WAI/WCAG21/quickref/)
- [WCAG 2.2 Guidelines](https://www.w3.org/WAI/WCAG22/quickref/)
- [ARIA Authoring Practices Guide](https://www.w3.org/WAI/ARIA/apg/)
- [WebAIM Resources](https://webaim.org/resources/)

**69.8.2 Ferramentas de Desenvolvimento**
- [axe DevTools](https://www.deque.com/axe/devtools/) - extensÃ£o browser
- [WAVE](https://wave.webaim.org/) - avaliaÃ§Ã£o web
- [Colour Contrast Analyser](https://www.tpgi.com/color-contrast-checker/) - verificaÃ§Ã£o de contraste
- [Lighthouse](https://developers.google.com/web/tools/lighthouse) - auditoria automatizada

**69.8.3 Plano de Treinamento**
- **Onboarding**: mÃ³dulo obrigatÃ³rio sobre acessibilidade para novos desenvolvedores
- **Workshops**: sessÃµes trimestrais sobre novos padrÃµes e tÃ©cnicas
- **CertificaÃ§Ã£o**: incentivo para certificaÃ§Ãµes em acessibilidade web
- **Comunidade**: grupo interno para discussÃ£o e compartilhamento de prÃ¡ticas

## 71) AI/ML (se aplicÃ¡vel)
<!-- tags: ai, ml, governance, model-ops, mlops, production -->
<!-- category: ai-ml -->
<!-- priority: medium -->
<!-- audience: data-scientists, ml-engineers, architects -->

**Objetivo**: Estabelecer governanÃ§a robusta para modelos de ML em produÃ§Ã£o, garantindo qualidade, seguranÃ§a e compliance.

### 71.1 GovernanÃ§a de Modelos

**Model Registry e Versionamento**:
```python
# MLflow Model Registry
import mlflow
from mlflow.tracking import MlflowClient

class ModelGovernance:
    def __init__(self, registry_uri: str):
        self.client = MlflowClient(registry_uri)
        
    def register_model(self, model_name: str, model_version: str, 
                      stage: str = "Staging") -> dict:
        """Registra modelo com metadados obrigatÃ³rios"""
        
        # ValidaÃ§Ãµes obrigatÃ³rias
        required_tags = [
            "data_source", "training_date", "algorithm", 
            "performance_metric", "data_lineage", "owner"
        ]
        
        model_info = {
            "name": model_name,
            "version": model_version,
            "stage": stage,
            "tags": {
                "data_source": "customer_transactions_v2",
                "training_date": "2025-01-15",
                "algorithm": "xgboost",
                "performance_metric": "auc=0.87",
                "data_lineage": "pipeline_v1.2.3",
                "owner": "data-science-team",
                "compliance_check": "passed",
                "bias_check": "passed"
            }
        }
        
        # Registrar no MLflow
        mv = self.client.create_model_version(
            name=model_name,
            source=f"models:/{model_name}/{model_version}",
            tags=model_info["tags"]
        )
        
        return model_info
    
    def promote_model(self, model_name: str, version: str, 
                     target_stage: str) -> bool:
        """Promove modelo com validaÃ§Ãµes de governanÃ§a"""
        
        # ValidaÃ§Ãµes antes da promoÃ§Ã£o
        validations = [
            self._validate_performance(model_name, version),
            self._validate_bias_check(model_name, version),
            self._validate_security_scan(model_name, version),
            self._validate_compliance(model_name, version)
        ]
        
        if all(validations):
            self.client.transition_model_version_stage(
                name=model_name,
                version=version,
                stage=target_stage
            )
            return True
        
        return False
```

**PolÃ­ticas de Dados e Compliance**:
```yaml
# config/ml-governance.yaml
data_governance:
  retention_policy:
    training_data: "2_years"
    model_artifacts: "5_years"
    predictions: "1_year"
    
  consent_management:
    required_consent_types:
      - "data_processing"
      - "model_training"
      - "automated_decision"
    
    consent_validation:
      before_training: true
      before_inference: true
      
  data_lineage:
    track_sources: true
    track_transformations: true
    track_feature_engineering: true
    
model_security:
  endpoint_protection:
    rate_limiting:
      requests_per_minute: 1000
      burst_limit: 100
    
    authentication:
      method: "mTLS"
      token_validation: true
      
    encryption:
      in_transit: "TLS_1_3"
      at_rest: "AES_256"
      
  model_protection:
    adversarial_detection: true
    input_validation: true
    output_sanitization: true
```

### 71.2 Monitoramento de Modelos

**Drift Detection**:
```python
from evidently import ColumnMapping
from evidently.report import Report
from evidently.metric_preset import DataDriftPreset, TargetDriftPreset

class ModelMonitoring:
    def __init__(self, reference_data, current_data):
        self.reference_data = reference_data
        self.current_data = current_data
        
    def detect_data_drift(self) -> dict:
        """Detecta drift nos dados de entrada"""
        
        report = Report(metrics=[
            DataDriftPreset(),
            TargetDriftPreset()
        ])
        
        report.run(
            reference_data=self.reference_data,
            current_data=self.current_data
        )
        
        drift_results = report.as_dict()
        
        # Alertas baseados em thresholds
        drift_score = drift_results['metrics'][0]['result']['drift_score']
        
        if drift_score > 0.3:  # Threshold configurÃ¡vel
            self._trigger_drift_alert(drift_score)
            
        return {
            "drift_detected": drift_score > 0.3,
            "drift_score": drift_score,
            "affected_features": self._get_drifted_features(drift_results)
        }
    
    def monitor_performance(self, predictions, actuals) -> dict:
        """Monitora performance do modelo em produÃ§Ã£o"""
        
        from sklearn.metrics import accuracy_score, precision_score, recall_score
        
        metrics = {
            "accuracy": accuracy_score(actuals, predictions),
            "precision": precision_score(actuals, predictions, average='weighted'),
            "recall": recall_score(actuals, predictions, average='weighted'),
            "timestamp": datetime.now().isoformat()
        }
        
        # Comparar com baseline
        baseline_accuracy = 0.85  # ConfigurÃ¡vel
        
        if metrics["accuracy"] < baseline_accuracy * 0.95:  # 5% degradaÃ§Ã£o
            self._trigger_performance_alert(metrics)
            
        return metrics
```

**Bias Detection**:
```python
from aif360 import datasets
from aif360.metrics import BinaryLabelDatasetMetric
from aif360.algorithms.preprocessing import Reweighing

class BiasMonitoring:
    def __init__(self, protected_attributes):
        self.protected_attributes = protected_attributes
        
    def detect_bias(self, dataset, predictions) -> dict:
        """Detecta viÃ©s em prediÃ§Ãµes"""
        
        bias_metrics = {}
        
        for attr in self.protected_attributes:
            # Calcular mÃ©tricas de equidade
            privileged_groups = [{attr: 1}]
            unprivileged_groups = [{attr: 0}]
            
            metric = BinaryLabelDatasetMetric(
                dataset,
                unprivileged_groups=unprivileged_groups,
                privileged_groups=privileged_groups
            )
            
            bias_metrics[attr] = {
                "statistical_parity": metric.statistical_parity_difference(),
                "equal_opportunity": metric.equal_opportunity_difference(),
                "disparate_impact": metric.disparate_impact()
            }
            
            # Alertas para viÃ©s significativo
            if abs(bias_metrics[attr]["statistical_parity"]) > 0.1:
                self._trigger_bias_alert(attr, bias_metrics[attr])
                
        return bias_metrics
```

### 71.3 Explainability e Auditoria

**Model Explainability**:
```python
import shap
from lime import lime_tabular

class ModelExplainability:
    def __init__(self, model, training_data):
        self.model = model
        self.training_data = training_data
        self.explainer = None
        
    def setup_shap_explainer(self):
        """Configura explainer SHAP"""
        self.explainer = shap.TreeExplainer(self.model)
        
    def explain_prediction(self, instance) -> dict:
        """Explica prediÃ§Ã£o individual"""
        
        if self.explainer is None:
            self.setup_shap_explainer()
            
        shap_values = self.explainer.shap_values(instance)
        
        explanation = {
            "prediction": self.model.predict(instance)[0],
            "probability": self.model.predict_proba(instance)[0].tolist(),
            "feature_importance": {
                f"feature_{i}": float(shap_values[i])
                for i in range(len(shap_values))
            },
            "base_value": float(self.explainer.expected_value),
            "timestamp": datetime.now().isoformat()
        }
        
        return explanation
    
    def generate_audit_report(self) -> dict:
        """Gera relatÃ³rio de auditoria do modelo"""
        
        # AnÃ¡lise global do modelo
        shap_values = self.explainer.shap_values(self.training_data)
        
        report = {
            "model_info": {
                "algorithm": type(self.model).__name__,
                "features": list(self.training_data.columns),
                "training_samples": len(self.training_data)
            },
            "global_importance": {
                feature: float(importance)
                for feature, importance in zip(
                    self.training_data.columns,
                    np.abs(shap_values).mean(0)
                )
            },
            "model_behavior": {
                "feature_interactions": self._analyze_interactions(),
                "decision_boundaries": self._analyze_boundaries()
            },
            "generated_at": datetime.now().isoformat()
        }
        
        return report
```

### 71.4 Deployment e Rollback

**Blue-Green Deployment para Modelos**:
```python
class ModelDeployment:
    def __init__(self, model_registry, load_balancer):
        self.registry = model_registry
        self.load_balancer = load_balancer
        
    def deploy_model(self, model_name: str, version: str, 
                    deployment_strategy: str = "blue_green") -> bool:
        """Deploy com estratÃ©gia blue-green"""
        
        try:
            # 1. Preparar novo ambiente (green)
            green_endpoint = self._prepare_green_environment(model_name, version)
            
            # 2. Testes de smoke
            if not self._run_smoke_tests(green_endpoint):
                raise Exception("Smoke tests failed")
                
            # 3. Testes A/B com trÃ¡fego limitado
            self._start_ab_testing(green_endpoint, traffic_percentage=10)
            
            # 4. Monitorar mÃ©tricas por perÃ­odo
            if self._monitor_deployment(green_endpoint, duration_minutes=30):
                # 5. Switch completo do trÃ¡fego
                self._switch_traffic(green_endpoint)
                
                # 6. Cleanup do ambiente anterior
                self._cleanup_blue_environment()
                
                return True
            else:
                # Rollback automÃ¡tico
                self._rollback_deployment()
                return False
                
        except Exception as e:
            self.logger.error(f"Deployment failed: {e}")
            self._rollback_deployment()
            return False
    
    def _monitor_deployment(self, endpoint: str, duration_minutes: int) -> bool:
        """Monitora deployment por perÃ­odo especÃ­fico"""
        
        start_time = time.time()
        end_time = start_time + (duration_minutes * 60)
        
        while time.time() < end_time:
            metrics = self._collect_endpoint_metrics(endpoint)
            
            # CritÃ©rios de falha
            if (metrics['error_rate'] > 0.05 or  # 5% error rate
                metrics['latency_p95'] > 2000 or  # 2s latency
                metrics['accuracy'] < 0.80):      # 80% accuracy
                
                return False
                
            time.sleep(60)  # Check every minute
            
        return True
```

### 71.5 Checklist de GovernanÃ§a ML

**Desenvolvimento**:
- [ ] Modelo registrado com metadados completos
- [ ] Dados de treino com consentimento validado
- [ ] Testes de viÃ©s executados e aprovados
- [ ] Explainability implementada quando necessÃ¡ria
- [ ] ValidaÃ§Ã£o de seguranÃ§a (adversarial attacks)

**Deployment**:
- [ ] Testes A/B configurados
- [ ] Monitoramento de drift implementado
- [ ] Alertas de performance configurados
- [ ] EstratÃ©gia de rollback definida
- [ ] Logs de auditoria habilitados

**OperaÃ§Ã£o**:
- [ ] Monitoramento contÃ­nuo de performance
- [ ] DetecÃ§Ã£o de drift automatizada
- [ ] RelatÃ³rios de compliance gerados
- [ ] RevisÃµes periÃ³dicas de viÃ©s
- [ ] Backup de modelos e artefatos

**Compliance**:
- [ ] PolÃ­ticas de retenÃ§Ã£o implementadas
- [ ] Consentimento rastreado e validado
- [ ] Auditoria de decisÃµes automatizadas
- [ ] DocumentaÃ§Ã£o de lineage completa
- [ ] RelatÃ³rios regulatÃ³rios gerados

## 72) PolÃ­tica de LicenÃ§as
72.1 Diretrizes
- Lista de licenÃ§as permitidas/proibidas; scans automÃ¡ticos (SCA) no CI; processo de aprovaÃ§Ã£o de inclusÃ£o;
- GeraÃ§Ã£o de relatÃ³rio de compliance por release; armazenar avisos de licenÃ§as (NOTICE). 

## 73) Mermaid â€“ PadrÃµes de Uso
- **Menos Ã© mais**: Diagramas devem comunicar, nÃ£o impressionar
- **Legibilidade primeiro**: Prefira clareza sobre complexidade visual
- **Manutenibilidade**: Diagramas simples sÃ£o mais fÃ¡ceis de atualizar
- **Performance**: Diagramas menores renderizam mais rÃ¡pido

### 73.1) Sintaxe e Compatibilidade
- **Evitar sintaxes nÃ£o suportadas**: `C4Deployment`, `C4Container`, `C4Component` nÃ£o sÃ£o nativos do Mermaid
- **Usar flowchart/graph**: Para diagramas de arquitetura, prefira `flowchart TB/LR` com subgraphs
- **LimitaÃ§Ãµes conhecidas**: 
  - MÃ¡ximo 50 nÃ³s por diagrama para performance
  - Evitar textos longos em labels (mÃ¡x 20 caracteres)
  - Subgraphs aninhados podem causar problemas de renderizaÃ§Ã£o
- **ValidaÃ§Ã£o obrigatÃ³ria**: Sempre testar diagramas em editor Mermaid antes de commit

73.2 PadrÃµes Recomendados
- **Deployment**: Use `flowchart TB` com subgraphs para ambientes (DEV/QAS/PROD).
- **Arquitetura**: Combine flowchart + classDef para tipagem visual (container/database/service).
- **Fluxos**: `flowchart LR` para pipelines e processos sequenciais.
- **C4 Model**: Implemente os 4 nÃ­veis usando flowchart com convenÃ§Ãµes de cores e Ã­cones padronizados.

73.2.1 ReferÃªncia para C4 Model
- **Templates C4**: Ver seÃ§Ã£o 4.1 (C4 Model) para templates especÃ­ficos e convenÃ§Ãµes completas.
- **ImplementaÃ§Ã£o**: Use `flowchart TB/LR` com `subgraph` e `classDef` conforme padrÃµes definidos na seÃ§Ã£o 4.1.

73.3 Exemplo de Deployment Diagram
```mermaid
flowchart TB
    subgraph DEV ["ðŸ”§ Development Environment"]
        DEV_APP["WebRep SPA<br/>AngularJS 1.8<br/>Development build"]
        DEV_API["Backend API<br/>REST API<br/>Development server"]
        DEV_DB[("Database<br/>SQL Server<br/>Development data")]
    end
    
    DEV_APP -.->|"API Calls<br/>HTTPS"| DEV_API
    DEV_API -.->|"SQL Queries<br/>TDS"| DEV_DB
    
    classDef container fill:#85bbf0,stroke:#073b6f,color:#1a1a1a
    classDef database fill:#f4b942,stroke:#aa6c39,color:#1a1a1a
    classDef environment fill:#c4e5c5,stroke:#2e7d32,color:#1a1a1a
    
    class DEV_APP,DEV_API container
    class DEV_DB database
    class DEV environment
```

73.4 Checklist Mermaid
- [ ] Sintaxe validada (flowchart/graph/sequenceDiagram/etc)
- [ ] Evitar C4* nÃ£o nativos
- [ ] ClassDef aplicado para consistÃªncia visual
- [ ] Ãcones/emojis para melhor identificaÃ§Ã£o
- [ ] Testado em preview antes do commit
- [ ] MÃ¡ximo 50 nÃ³s respeitado
- [ ] Labels com mÃ¡ximo 20 caracteres
- [ ] Pipeline CI/CD configurado para validaÃ§Ã£o

### 73.4.1) Pipeline CI/CD para ValidaÃ§Ã£o de Diagramas
**ValidaÃ§Ã£o automÃ¡tica obrigatÃ³ria:**
```yaml
# .github/workflows/mermaid-validation.yml
name: Validate Mermaid Diagrams
on: [push, pull_request]
jobs:
  validate-mermaid:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      - name: Install Mermaid CLI
        run: npm install -g @mermaid-js/mermaid-cli
      - name: Validate Mermaid Files
        run: |
          find . -name "*.md" -exec grep -l "```mermaid" {} \; | while read file; do
            echo "Validating $file"
            mmdc -i "$file" -o "/tmp/validation.png" --quiet || exit 1
          done
      - name: Check Diagram Limits
        run: |
          find . -name "*.md" -exec grep -A 50 "```mermaid" {} \; | \
          awk '/```mermaid/,/```/' | \
          grep -E "^[[:space:]]*[A-Za-z0-9_]+" | \
          wc -l | \
          awk '{if($1 > 50) {print "Error: Diagram exceeds 50 nodes limit"; exit 1}}'
```

**Workarounds para limitaÃ§Ãµes conhecidas:**
- **Subgraphs aninhados**: Use `direction TB` explÃ­cito em cada subgraph
- **RenderizaÃ§Ã£o lenta**: Divida diagramas grandes em mÃºltiplos arquivos
- **Labels longos**: Use abreviaÃ§Ãµes + legenda separada
- **Caracteres especiais**: Escape com aspas duplas: `A["Texto com espaÃ§os"]`

73.5 Tema, fontes e cores
- Preferir tema `neutral`/`default` para compatibilidade; ajustar apenas quando necessÃ¡rio;
- Fontes: herdar da pÃ¡gina (sem forÃ§ar famÃ­lias); tamanhos legÃ­veis (12â€“14px) em labels;
- **Cores padronizadas**: usar paleta definida na seÃ§Ã£o 4.1.6 para consistÃªncia organizacional;
- **Legibilidade crÃ­tica**: sempre usar `color:#1a1a1a` em todas as classes de estilo para garantir contraste adequado;
- Evitar contrastes baixos; nunca usar cinza claro (`#666`, `#999`) para texto.

73.6 Boas prÃ¡ticas
- Diagramas pequenos e focados; dividir diagramas muito grandes em seÃ§Ãµes;
- Nomes claros para nÃ³s/arestas; evitar abreviaÃ§Ãµes obscuras; manter direÃ§Ã£o consistente (`LR` ou `TB`);
- Usar comentÃ¡rios no cÃ³digo do diagrama para contexto (nÃ£o exibidos no render).

73.7 Exemplo base (herdando estilo)
```mermaid
flowchart LR
  A[Cliente] --> B[API]
  B --> C[AplicaÃ§Ã£o]
  C --> D[DomÃ­nio]
  C --> E[Infra]
```

73.7.1 Exemplo C4 com cores padronizadas
```mermaid
graph TD
    User[UsuÃ¡rio] --> System[Sistema]
    System --> External[Sistema Externo]
    
    %% Ver seÃ§Ã£o 4.1.6 para paleta completa de cores
    classDef user fill:#87CEEB,stroke:#4682B4,color:#1a1a1a
    classDef system fill:#90EE90,stroke:#228B22,color:#1a1a1a
    classDef external fill:#FFB6C1,stroke:#DC143C,color:#1a1a1a
    
    class User user
    class System system
    class External external
```

73.8 Tokens â†’ Mermaid (mapping sugerido)
- Manter um mapeamento simples dos tokens principais para `themeVariables` do Mermaid (hexas resolvidos do seu `tokens.scss`).

Tabela de referÃªncia (exemplo):
```markdown
| Token CSS            | Hex     | Mermaid themeVariables        |
|----------------------|---------|--------------------------------|
| --brand-primary      | #1E90FF | primaryColor, primaryBorder   |
| --text-primary       | #222222 | tertiaryTextColor             |
| --surface-base       | #FFFFFF | background                     |
| --border-strong      | #DCDCDC | lineColor                      |
```

Exemplo (diagramas crÃ­ticos com init):
```mermaid
%%{init: {
  'theme': 'base',
  'themeVariables': {
    'primaryColor': '#1E90FF',
    'primaryBorderColor': '#1E90FF',
    'primaryTextColor': '#ffffff',
    'lineColor': '#DCDCDC',
    'tertiaryTextColor': '#222222',
    'background': '#ffffff'
  }
}}%%
flowchart LR
  A[[InÃ­cio]] --> B[Etapa]
  B --> C{DecisÃ£o}
  C -->|Sim| D[PrÃ³ximo]
  C -->|NÃ£o| E[Alternativa]
```

ObservaÃ§Ã£o: o Mermaid nÃ£o resolve `var(--token)` diretamente; use valores hex definidos a partir dos seus tokens de marca (automatize no build, se possÃ­vel).

73.9 Estilo global (opcional, site de documentaÃ§Ã£o)
- Se o site de documentaÃ§Ã£o permitir CSS, aplicar um escopo leve para diagramas visando legibilidade:
```css
.markdown-body .mermaid svg {
  font-family: var(--font-family-base, Inter, system-ui, sans-serif);
}
.markdown-body .mermaid .edgeLabel, 
.markdown-body .mermaid .label {
  font-size: 12px;
  fill: var(--text-primary, #222);
}
```

---

## 74) Tailwind CSS + SASS â€“ Abordagem HÃ­brida

**PrincÃ­pio fundamental**: Combinar a produtividade do Tailwind CSS com a flexibilidade do SASS para criar uma soluÃ§Ã£o hÃ­brida que atenda tanto necessidades de desenvolvimento rÃ¡pido quanto customizaÃ§Ãµes avanÃ§adas.

### 74.1) Quando Usar Cada Tecnologia

**Use Tailwind CSS para:**
- Layout responsivo (`grid`, `flex`, breakpoints)
- Spacing consistente (`p-4`, `m-8`, `gap-6`)
- Prototipagem rÃ¡pida e utilitÃ¡rios comuns
- Estados interativos (`hover:`, `focus:`, `active:`)

**Use SASS para:**
- Componentes complexos com lÃ³gica condicional
- Mixins reutilizÃ¡veis e temas avanÃ§ados
- CÃ¡lculos dinÃ¢micos e integraÃ§Ã£o com Design Systems
- Tokens complexos e hierarquias

### 74.2) ConfiguraÃ§Ã£o Essencial

**PostCSS + Tailwind + SASS**
```javascript
// postcss.config.js
module.exports = {
  plugins: {
    'tailwindcss/nesting': {},
    tailwindcss: {},
    autoprefixer: {},
    ...(process.env.NODE_ENV === 'production' ? { cssnano: {} } : {})
  }
};
```

**Estrutura hÃ­brida**
```
/styles/
  /tailwind/ - configuraÃ§Ãµes e overrides
  /sass/ - tokens, mixins, componentes complexos
  - main.css (entry point)
```

### 74.3) PadrÃµes de Nomenclatura

- **Classes Tailwind**: usar conforme documentaÃ§Ã£o oficial
- **Classes SASS**: prefixo consistente (`.c-button`, `.u-text-center`)
- **Componentes**: separar por responsabilidade e complexidade
- **UtilitÃ¡rios**: criar apenas quando Tailwind nÃ£o atende

```scss
// âœ… CombinaÃ§Ã£o hÃ­brida
.c-card {
  @apply bg-white rounded-lg shadow-md; // Tailwind utilities
  
  &__header {
    @apply p-6 border-b border-gray-200;
  }
  
  // SASS para lÃ³gica complexa
  @include responsive-typography(16px, 18px, 20px);
}
```

### 74.4) Checklist de ImplementaÃ§Ã£o

**ConfiguraÃ§Ã£o**
- [ ] PostCSS configurado com Tailwind CSS e autoprefixer
- [ ] SASS integrado via imports no entry point CSS
- [ ] PurgeCSS configurado para produÃ§Ã£o
- [ ] Estrutura de pastas definida e documentada

**Desenvolvimento**
- [ ] Tokens de design sincronizados entre Tailwind e SASS
- [ ] Componentes complexos implementados em SASS
- [ ] UtilitÃ¡rios simples migrados para Tailwind
- [ ] Nomenclatura consistente aplicada

**Performance**
- [ ] CSS splitting por rotas implementado
- [ ] Bundle size monitorado e otimizado
- [ ] Assets versionados com hash de conteÃºdo

### 74.5) BenefÃ­cios da Abordagem

- **Produtividade**: desenvolvimento rÃ¡pido com utilitÃ¡rios + flexibilidade total para casos complexos
- **Manutenibilidade**: cÃ³digo CSS organizado com separaÃ§Ã£o clara de responsabilidades
- **Performance**: bundle otimizado com tree-shaking automÃ¡tico
- **Flexibilidade**: suporte a mÃºltiplos temas e migraÃ§Ã£o gradual de projetos existentes

Esta abordagem representa o melhor dos dois mundos: velocidade do Tailwind + poder do SASS para uma soluÃ§Ã£o robusta e escalÃ¡vel.
- [ ] Testes de unidade e integraÃ§Ã£o cobrindo use cases crÃ­ticos

## 75) AnÃ¡lise Automatizada de PDFs com MCPs

**Objetivo**: estabelecer padrÃµes para extraÃ§Ã£o e anÃ¡lise automatizada de documentos PDF usando Model Context Protocol (MCP) servers.

### 75.1) PrincÃ­pios Fundamentais
- **AutomaÃ§Ã£o completa**: eliminar revisÃµes manuais atravÃ©s de extraÃ§Ã£o programÃ¡tica
- **AnÃ¡lise estruturada**: converter conteÃºdo PDF em dados estruturados
- **ValidaÃ§Ã£o cruzada**: comparar especificaÃ§Ãµes com implementaÃ§Ãµes existentes

### 75.2) Stack Recomendada
- **Context7**: resoluÃ§Ã£o de bibliotecas e documentaÃ§Ã£o
- **UnPDF**: extraÃ§Ã£o de texto, links e metadados
- **Node.js**: runtime para scripts de anÃ¡lise
- **Markdown**: formato de saÃ­da

### 75.3) ImplementaÃ§Ã£o BÃ¡sica
```javascript
// Script simplificado de anÃ¡lise
async function analyzePDF(pdfPath) {
  const text = await extractText(pdfPath);
  const metadata = await extractMetadata(pdfPath);
  
  return {
    metadata: { title, pages, creationDate },
    content: { operations, integrations, specs },
    gaps: identifyGaps(text)
  };
}
```

### 75.4) PadrÃµes de ExtraÃ§Ã£o
- **OperaÃ§Ãµes**: identificar services, methods, endpoints
- **IntegraÃ§Ãµes**: mapear sistemas externos e protocolos
- **Specs tÃ©cnicas**: extrair requisitos de memÃ³ria, timeout, linguagens

### 75.5) IntegraÃ§Ã£o CI/CD
```yaml
- name: Analyze PDFs
  run: find docs/ -name "*.pdf" -exec node analyze-pdf.js {} \;
```

### 75.6) Casos de Uso
- MigraÃ§Ã£o de sistemas (validaÃ§Ã£o spec vs implementaÃ§Ã£o)
- Auditoria tÃ©cnica e compliance
- Onboarding e extraÃ§Ã£o de conhecimento legado

---

## 76) VersÃµes LTS - PolÃ­tica ObrigatÃ³ria

**PrincÃ­pio fundamental**: SEMPRE utilizar versÃµes LTS (Long Term Support) de tecnologias em produÃ§Ã£o para garantir estabilidade, seguranÃ§a e suporte de longo prazo.

### 76.1) Tecnologias ObrigatÃ³rias LTS

**Node.js**
- **ObrigatÃ³rio**: Sempre usar versÃµes LTS pares (18.x, 20.x, 22.x)
- **Proibido**: VersÃµes Ã­mpares (17.x, 19.x, 21.x) em produÃ§Ã£o
- **ValidaÃ§Ã£o**: `engines.node` no package.json deve especificar versÃ£o LTS
- **Exemplo validado**: Node.js 22.x (LTS atual do projeto OneClick V1)

```json
// package.json - OBRIGATÃ“RIO
{
  "engines": {
    "node": ">=22.0.0"
  }
}
```

**Outras tecnologias crÃ­ticas**
- **Java**: OpenJDK LTS (8, 11, 17, 21)
- **.NET**: VersÃµes LTS (.NET 6, .NET 8)
- **Python**: VersÃµes com suporte ativo (3.9+, preferencialmente 3.11+)
- **PostgreSQL**: VersÃµes com suporte (13+, preferencialmente 15+)
- **Redis**: VersÃµes estÃ¡veis (6.2+, preferencialmente 7.0+)

### 76.2) ValidaÃ§Ã£o e Monitoramento

**CI/CD Gates**
- Pipeline deve falhar se versÃ£o nÃ£o-LTS for detectada
- ValidaÃ§Ã£o automÃ¡tica de `engines` em package.json
- Scan de dependÃªncias para versÃµes EOL (End of Life)

**Monitoramento de EOL**
- Alertas 6 meses antes do fim do suporte LTS
- Roadmap de migraÃ§Ã£o automÃ¡tico
- Dashboard de compliance de versÃµes

### 76.3) ExceÃ§Ãµes Controladas

**Desenvolvimento local**
- Permitido usar versÃµes mais recentes para testes
- ObrigatÃ³rio validar compatibilidade com LTS antes do merge

**Projetos experimentais**
- Permitido em repositÃ³rios marcados como "experimental"
- MigraÃ§Ã£o obrigatÃ³ria para LTS antes de produÃ§Ã£o

### 76.4) Processo de AtualizaÃ§Ã£o LTS

**Planejamento**
1. Monitorar roadmap oficial da tecnologia
2. Testar nova versÃ£o LTS em ambiente isolado
3. Validar compatibilidade de dependÃªncias
4. Executar suite completa de testes

**ExecuÃ§Ã£o**
1. Atualizar desenvolvimento primeiro
2. Deploy em staging com monitoramento intensivo
3. Rollout gradual em produÃ§Ã£o (blue-green)
4. Documentar liÃ§Ãµes aprendidas

**ValidaÃ§Ã£o pÃ³s-migraÃ§Ã£o**
- Performance nÃ£o pode degradar >5%
- Zero regressÃµes funcionais
- Logs e mÃ©tricas estÃ¡veis por 48h

## 77) Serverless Framework - PadrÃµes AWS Lambda

**Baseado nas liÃ§Ãµes aprendidas do projeto OneClick V1** - padrÃµes validados em produÃ§Ã£o com 100% de paridade funcional.

### 77.1) Estrutura de Projeto Serverless

**OrganizaÃ§Ã£o de pastas obrigatÃ³ria**
```
project-name/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ handlers/           # Lambda handlers individuais
â”‚   â”œâ”€â”€ shared/            # UtilitÃ¡rios compartilhados
â”‚   â”œâ”€â”€ adapters/          # IntegraÃ§Ãµes externas
â”‚   â”œâ”€â”€ business/          # Regras de negÃ³cio
â”‚   â””â”€â”€ @types/           # DefiniÃ§Ãµes TypeScript
â”œâ”€â”€ test/
â”‚   â”œâ”€â”€ unit/             # Testes unitÃ¡rios
â”‚   â”œâ”€â”€ integration/      # Testes de integraÃ§Ã£o
â”‚   â””â”€â”€ e2e/             # Testes end-to-end
â”œâ”€â”€ terraform/           # Infraestrutura como cÃ³digo
â”œâ”€â”€ monitoring/          # Dashboards e alertas
â””â”€â”€ scripts/            # Scripts de deploy e utilitÃ¡rios
```

### 77.2) ConfiguraÃ§Ã£o Serverless Framework

**serverless.yml - Template base**
```yaml
service: project-name
frameworkVersion: '4'  # Sempre usar versÃ£o 4.x (LTS)

provider:
  name: aws
  runtime: nodejs22.x    # Sempre LTS
  region: us-east-1
  stage: ${opt:stage, 'dev1'}
  memorySize: 1024       # PadrÃ£o otimizado
  timeout: 30           # MÃ¡ximo recomendado
  architecture: x86_64   # Compatibilidade mÃ¡xima
  versionFunctions: true # Versionamento obrigatÃ³rio
  
  environment:
    NODE_ENV: ${self:provider.stage}
    AWS_NODEJS_CONNECTION_REUSE_ENABLED: 1
    STAGE: ${self:provider.stage}
    SERVICE_NAME: ${self:service}
    LOG_LEVEL: ${param:LOG_LEVEL, 'info'}

build:
  esbuild:
    bundle: true
    minify: false         # Debug em desenvolvimento
    sourcemap: true       # Debugging obrigatÃ³rio
    exclude:
      - '@aws-sdk/*'      # Reduz bundle size
    target: 'node22'      # Match com runtime
    platform: 'node'
    buildConcurrency: 10
```

### 77.3) Handlers e Middleware

**Handler padrÃ£o com Middy**
```typescript
import middy from '@middy/core';
import httpErrorHandler from '@middy/http-error-handler';
import httpEventNormalizer from '@middy/http-event-normalizer';
import httpJsonBodyParser from '@middy/http-json-body-parser';
import httpCors from '@middy/http-cors';
import validator from '@middy/validator';
import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';
import { logger } from '../shared/Logger';

const baseHandler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  const correlationId = event.headers['x-correlation-id'] || 
                       event.requestContext.requestId;
  
  logger.info('Handler started', { 
    correlationId, 
    path: event.path,
    method: event.httpMethod 
  });

  try {
    // LÃ³gica de negÃ³cio aqui
    const result = await processRequest(event.body);
    
    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json',
        'X-Correlation-ID': correlationId
      },
      body: JSON.stringify(result)
    };
  } catch (error) {
    logger.error('Handler error', { correlationId, error });
    throw error;
  }
};

export const handler = middy(baseHandler)
  .use(httpEventNormalizer())
  .use(httpJsonBodyParser())
  .use(validator({ inputSchema: requestSchema }))
  .use(httpErrorHandler())
  .use(httpCors({
    origin: process.env.ALLOWED_ORIGINS?.split(',') || ['*'],
    credentials: true
  }));
```

### 77.4) Multi-Ambiente e ConfiguraÃ§Ã£o

**EstratÃ©gia de ambientes**
```yaml
# serverless.yml - ParÃ¢metros por ambiente
params:
  local:
    LOG_LEVEL: debug
    API_GATEWAY_REST_API_ID: local-api-gateway
  dev1:
    LOG_LEVEL: debug
    API_GATEWAY_REST_API_ID: ${ssm:/project/dev1/api-gateway/rest-api-id}
  dev2:
    LOG_LEVEL: debug
    API_GATEWAY_REST_API_ID: ${ssm:/project/dev2/api-gateway/rest-api-id}
  hml1:
    LOG_LEVEL: info
    API_GATEWAY_REST_API_ID: ${ssm:/project/hml1/api-gateway/rest-api-id}
  blue:
    LOG_LEVEL: warn
    API_GATEWAY_REST_API_ID: ${ssm:/project/blue/api-gateway/rest-api-id}
  green:
    LOG_LEVEL: warn
    API_GATEWAY_REST_API_ID: ${ssm:/project/green/api-gateway/rest-api-id}
```

### 77.5) SeguranÃ§a e IAM

**PolÃ­ticas IAM mÃ­nimas**
```yaml
provider:
  iam:
    role:
      statements:
        # SSM Parameters (configuraÃ§Ã£o)
        - Effect: Allow
          Action:
            - ssm:GetParameter
            - ssm:GetParameters
            - ssm:GetParametersByPath
          Resource:
            - arn:aws:ssm:${aws:region}:${aws:accountId}:parameter/project/${self:provider.stage}/*
        
        # Secrets Manager (credenciais)
        - Effect: Allow
          Action:
            - secretsmanager:GetSecretValue
          Resource:
            - arn:aws:secretsmanager:${aws:region}:${aws:accountId}:secret:project/${self:provider.stage}/*
        
        # CloudWatch Logs
        - Effect: Allow
          Action:
            - logs:CreateLogGroup
            - logs:CreateLogStream
            - logs:PutLogEvents
          Resource:
            - arn:aws:logs:${aws:region}:${aws:accountId}:log-group:/aws/lambda/${self:service}-${self:provider.stage}-*
```

### 77.6) Testes Serverless

**Estrutura de testes obrigatÃ³ria**
```typescript
// test/unit/handlers/example.test.ts
import { handler } from '../../../src/handlers/ExampleHandler';
import { APIGatewayProxyEvent } from 'aws-lambda';

describe('ExampleHandler', () => {
  const mockEvent: Partial<APIGatewayProxyEvent> = {
    httpMethod: 'POST',
    path: '/example',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ test: 'data' }),
    requestContext: {
      requestId: 'test-request-id'
    } as any
  };

  it('should process request successfully', async () => {
    const result = await handler(mockEvent as APIGatewayProxyEvent, {} as any);
    
    expect(result.statusCode).toBe(200);
    expect(JSON.parse(result.body)).toMatchObject({
      success: true
    });
  });
});
```

### 77.7) Deploy e CI/CD

**Scripts de deploy padronizados**
```json
// package.json - Scripts obrigatÃ³rios
{
  "scripts": {
    "build": "tsc",
    "test": "jest",
    "test:coverage": "jest --coverage",
    "test:unit": "jest --testPathPattern=test/unit",
    "test:integration": "jest --testPathPattern=test/integration",
    "test:e2e": "jest --testPathPattern=test/e2e",
    "deploy:dev1": "serverless deploy --stage dev1",
    "deploy:hml1": "serverless deploy --stage hml1",
    "deploy:blue": "serverless deploy --stage blue",
    "deploy:green": "serverless deploy --stage green",
    "offline": "serverless offline",
    "package": "serverless package"
  }
}
```

### 77.8) Monitoramento e Observabilidade

**Warmup para produÃ§Ã£o**
```yaml
custom:
  warmup:
    enabled:
      - production
      - blue
      - green
    events:
      - schedule: rate(5 minutes)
    timeout: 20
    memorySize: 256
```

**Logs estruturados obrigatÃ³rios**
```typescript
// src/shared/Logger.ts
import winston from 'winston';

export const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: {
    service: process.env.SERVICE_NAME,
    stage: process.env.STAGE
  },
  transports: [new winston.transports.Console()]
});
```

### 77.9) Performance e OtimizaÃ§Ã£o

**ConfiguraÃ§Ãµes de performance**
- **Memory**: 1024MB (padrÃ£o otimizado custo/performance)
- **Timeout**: 30s (mÃ¡ximo recomendado para APIs)
- **Architecture**: x86_64 (compatibilidade mÃ¡xima)
- **Bundle**: esbuild com exclusÃµes AWS SDK
- **Connection reuse**: `AWS_NODEJS_CONNECTION_REUSE_ENABLED=1`

**MÃ©tricas de sucesso validadas (OneClick V1)**
- LatÃªncia P95: ~16ms (muito abaixo do SLA 500ms)
- Cold start: <2s
- Memory utilization: <70%
- Error rate: <0.1%

---

## 78) Micro-frontends - PadrÃµes de FederaÃ§Ã£o e ComunicaÃ§Ã£o
<!-- tags: micro-frontends, module-federation, architecture, scalability -->
<!-- category: frontend-architecture -->
<!-- priority: high -->
<!-- audience: frontend-developers, architects -->

**EstratÃ©gias para arquiteturas de micro-frontends escalÃ¡veis e resilientes.**

### 78.1) EstratÃ©gias de ImplementaÃ§Ã£o

**Module Federation (Webpack 5)**
```javascript
// host/webpack.config.js
const ModuleFederationPlugin = require('@module-federation/webpack');

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'host',
      remotes: {
        mfe1: 'mfe1@http://localhost:3001/remoteEntry.js',
        mfe2: 'mfe2@http://localhost:3002/remoteEntry.js'
      },
      shared: {
        react: { singleton: true, requiredVersion: '^18.0.0' },
        'react-dom': { singleton: true, requiredVersion: '^18.0.0' }
      }
    })
  ]
};
```

**Single-SPA (Framework Agnostic)**
```typescript
// src/microfrontend-loader.ts
import { registerApplication, start } from 'single-spa';

registerApplication({
  name: '@company/navbar',
  app: () => System.import('@company/navbar'),
  activeWhen: ['/'],
  customProps: {
    authToken: () => getAuthToken(),
    theme: () => getCurrentTheme()
  }
});

start({
  urlRerouteOnly: true
});
```

### 78.2) ComunicaÃ§Ã£o Entre MÃ³dulos

**Event Bus Pattern**
```typescript
// shared/EventBus.ts
class EventBus {
  private events: Map<string, Function[]> = new Map();

  emit(event: string, data?: any) {
    const handlers = this.events.get(event) || [];
    handlers.forEach(handler => handler(data));
  }

  on(event: string, handler: Function) {
    const handlers = this.events.get(event) || [];
    this.events.set(event, [...handlers, handler]);
  }

  off(event: string, handler: Function) {
    const handlers = this.events.get(event) || [];
    this.events.set(event, handlers.filter(h => h !== handler));
  }
}

export const eventBus = new EventBus();
```

**Shared State Management**
```typescript
// shared/SharedStore.ts
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';

interface SharedState {
  user: User | null;
  theme: 'light' | 'dark';
  notifications: Notification[];
  setUser: (user: User | null) => void;
  setTheme: (theme: 'light' | 'dark') => void;
  addNotification: (notification: Notification) => void;
}

export const useSharedStore = create<SharedState>()()
  subscribeWithSelector((set, get) => ({
    user: null,
    theme: 'light',
    notifications: [],
    setUser: (user) => set({ user }),
    setTheme: (theme) => set({ theme }),
    addNotification: (notification) => 
      set(state => ({ 
        notifications: [...state.notifications, notification] 
      }))
  }));
```

### 78.3) Roteamento e NavegaÃ§Ã£o

**Coordinated Routing**
```typescript
// shared/RouterCoordinator.ts
class RouterCoordinator {
  private currentRoute: string = '/';
  private subscribers: Function[] = [];

  navigate(path: string, options?: { replace?: boolean }) {
    if (options?.replace) {
      window.history.replaceState({}, '', path);
    } else {
      window.history.pushState({}, '', path);
    }
    
    this.currentRoute = path;
    this.notifySubscribers(path);
  }

  subscribe(callback: (path: string) => void) {
    this.subscribers.push(callback);
    return () => {
      this.subscribers = this.subscribers.filter(sub => sub !== callback);
    };
  }

  private notifySubscribers(path: string) {
    this.subscribers.forEach(callback => callback(path));
  }
}

export const routerCoordinator = new RouterCoordinator();
```

### 78.4) Deployment e Versionamento

**Independent Deployment Strategy**
```yaml
# .github/workflows/deploy-mfe.yml
name: Deploy Micro-frontend

on:
  push:
    branches: [main]
    paths: ['packages/mfe-*/**']

jobs:
  deploy:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        mfe: [navbar, dashboard, profile]
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Build MFE
        run: |
          cd packages/mfe-${{ matrix.mfe }}
          npm ci
          npm run build
          
      - name: Deploy to CDN
        run: |
          aws s3 sync dist/ s3://mfe-${{ matrix.mfe }}-${{ github.sha }}/
          aws cloudfront create-invalidation --distribution-id ${{ secrets.CLOUDFRONT_ID }}
```

**Version Management**
```typescript
// shared/VersionManager.ts
interface MFEVersion {
  name: string;
  version: string;
  url: string;
  fallbackUrl?: string;
}

class VersionManager {
  private versions: Map<string, MFEVersion> = new Map();

  async loadMFE(name: string): Promise<any> {
    const mfe = this.versions.get(name);
    if (!mfe) throw new Error(`MFE ${name} not found`);

    try {
      return await System.import(mfe.url);
    } catch (error) {
      if (mfe.fallbackUrl) {
        console.warn(`Failed to load ${name}, using fallback`);
        return await System.import(mfe.fallbackUrl);
      }
      throw error;
    }
  }

  registerVersion(mfe: MFEVersion) {
    this.versions.set(mfe.name, mfe);
  }
}

export const versionManager = new VersionManager();
```

### 78.5) Testes e Qualidade

**Integration Testing**
```typescript
// tests/integration/mfe-integration.test.ts
import { render, screen } from '@testing-library/react';
import { loadMicroFrontend } from '../utils/mfe-loader';

describe('Micro-frontend Integration', () => {
  it('should load and render navbar MFE', async () => {
    const NavbarMFE = await loadMicroFrontend('navbar');
    
    render(<NavbarMFE user={{ name: 'Test User' }} />);
    
    expect(screen.getByText('Test User')).toBeInTheDocument();
  });

  it('should handle MFE loading failures gracefully', async () => {
    const consoleSpy = jest.spyOn(console, 'error').mockImplementation();
    
    const FailingMFE = await loadMicroFrontend('non-existent');
    
    expect(FailingMFE).toBe(null);
    expect(consoleSpy).toHaveBeenCalled();
  });
});
```

**Performance Monitoring**
```typescript
// shared/MFEMonitor.ts
class MFEMonitor {
  private loadTimes: Map<string, number> = new Map();

  startLoad(mfeName: string) {
    this.loadTimes.set(mfeName, performance.now());
  }

  endLoad(mfeName: string) {
    const startTime = this.loadTimes.get(mfeName);
    if (startTime) {
      const loadTime = performance.now() - startTime;
      
      // Send metrics to monitoring service
      this.sendMetric('mfe_load_time', loadTime, { mfe: mfeName });
      
      if (loadTime > 3000) {
        console.warn(`Slow MFE load: ${mfeName} took ${loadTime}ms`);
      }
    }
  }

  private sendMetric(name: string, value: number, tags: Record<string, string>) {
    // Implementation depends on your monitoring solution
    // e.g., DataDog, New Relic, custom analytics
  }
}

export const mfeMonitor = new MFEMonitor();
```

### 78.6) Checklist de ImplementaÃ§Ã£o

**Arquitetura**
- [ ] EstratÃ©gia de federaÃ§Ã£o definida (Module Federation/Single-SPA)
- [ ] Contratos de comunicaÃ§Ã£o documentados
- [ ] Shared dependencies versionadas
- [ ] Fallback strategies implementadas

**Desenvolvimento**
- [ ] Event bus ou state management compartilhado
- [ ] Roteamento coordenado entre MFEs
- [ ] Error boundaries em cada micro-frontend
- [ ] Testes de integraÃ§Ã£o automatizados

**Deploy e OperaÃ§Ã£o**
- [ ] Pipeline de deploy independente por MFE
- [ ] Versionamento e rollback strategy
- [ ] Monitoramento de performance por mÃ³dulo
- [ ] Health checks para cada micro-frontend

---

## 79) Edge Computing - EstratÃ©gias de DistribuiÃ§Ã£o e Cache na Borda
<!-- tags: edge-computing, cdn, performance, distributed-systems, caching -->
<!-- category: infrastructure -->
<!-- priority: medium -->
<!-- audience: architects, devops -->

### 79.1 Conceitos Fundamentais

**79.1.1 DefiniÃ§Ã£o e BenefÃ­cios**
- **Edge Computing**: processamento prÃ³ximo ao usuÃ¡rio final; reduÃ§Ã£o de latÃªncia e largura de banda.
- **BenefÃ­cios**: menor latÃªncia (< 50ms), melhor UX, reduÃ§Ã£o de custos de bandwidth, maior disponibilidade.
- **Casos de uso**: CDN inteligente, IoT processing, real-time analytics, gaming, streaming.

**79.1.2 Arquitetura Edge**
```text
User â†’ Edge Node (CDN/Edge Server) â†’ Origin Server â†’ Backend Services
     â†“
   Cache/Compute/Filter
```

### 79.2 EstratÃ©gias de Cache na Borda

**79.2.1 Cache Layers**
```typescript
// Edge cache configuration
interface EdgeCacheConfig {
  ttl: number;                    // Time to live
  staleWhileRevalidate: number;   // Serve stale content while updating
  cacheKey: string[];             // Cache key components
  varyHeaders: string[];          // Headers that affect cache
  purgeStrategy: 'tag' | 'url' | 'wildcard';
}

// Cloudflare Workers example
export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const cache = caches.default;
    const cacheKey = new Request(request.url, request);
    
    // Try cache first
    let response = await cache.match(cacheKey);
    
    if (!response) {
      // Fetch from origin
      response = await fetch(request);
      
      // Cache successful responses
      if (response.status === 200) {
        const headers = new Headers(response.headers);
        headers.set('Cache-Control', 'public, max-age=3600, s-maxage=86400');
        headers.set('CDN-Cache-Control', 'max-age=86400');
        
        const cachedResponse = new Response(response.body, {
          status: response.status,
          statusText: response.statusText,
          headers
        });
        
        await cache.put(cacheKey, cachedResponse.clone());
        return cachedResponse;
      }
    }
    
    return response;
  }
};
```

**79.2.2 Cache Invalidation**
```typescript
// Tag-based purging
interface CachePurgeService {
  purgeByTag(tags: string[]): Promise<void>;
  purgeByUrl(urls: string[]): Promise<void>;
  purgeAll(): Promise<void>;
}

// Implementation example
class CloudflarePurgeService implements CachePurgeService {
  async purgeByTag(tags: string[]): Promise<void> {
    await fetch(`https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/purge_cache`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${CF_API_TOKEN}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ tags })
    });
  }
}
```

### 79.3 Edge Computing Patterns

**79.3.1 Edge Functions**
```typescript
// Request/Response transformation
export async function handleRequest(request: Request): Promise<Response> {
  const url = new URL(request.url);
  
  // A/B Testing at edge
  const variant = getABTestVariant(request.headers.get('CF-IPCountry'));
  url.searchParams.set('variant', variant);
  
  // Geolocation-based routing
  const country = request.headers.get('CF-IPCountry');
  const region = getRegionForCountry(country);
  
  // Modify request before forwarding
  const modifiedRequest = new Request(url.toString(), {
    method: request.method,
    headers: {
      ...Object.fromEntries(request.headers),
      'X-Edge-Region': region,
      'X-AB-Variant': variant
    },
    body: request.body
  });
  
  return fetch(modifiedRequest);
}

// Bot detection and filtering
function isBotRequest(request: Request): boolean {
  const userAgent = request.headers.get('User-Agent') || '';
  const botPatterns = [
    /googlebot/i,
    /bingbot/i,
    /slurp/i,
    /duckduckbot/i
  ];
  
  return botPatterns.some(pattern => pattern.test(userAgent));
}
```

**79.3.2 Edge-Side Includes (ESI)**
```html
<!-- Template with edge includes -->
<!DOCTYPE html>
<html>
<head>
  <title>Product Page</title>
</head>
<body>
  <!-- Static content cached for 24h -->
  <header>...</header>
  
  <!-- Dynamic content with shorter TTL -->
  <esi:include src="/api/user-specific-content" ttl="300" />
  
  <!-- Personalized recommendations -->
  <esi:include src="/api/recommendations?user=<esi:vars name='$(HTTP_X_USER_ID)' />" ttl="600" />
  
  <!-- Real-time inventory -->
  <esi:include src="/api/inventory/$(QUERY_STRING_product_id)" ttl="60" />
</body>
</html>
```

### 79.4 Multi-Region Edge Deployment

**79.4.1 Global Distribution Strategy**
```yaml
# Terraform - Multi-region edge deployment
resource "cloudflare_worker_script" "edge_app" {
  name    = "edge-app"
  content = file("${path.module}/worker.js")
  
  # Deploy to multiple regions
  placement {
    mode = "smart"
  }
}

resource "cloudflare_worker_route" "edge_routes" {
  for_each = toset([
    "api.example.com/*",
    "cdn.example.com/*"
  ])
  
  zone_id     = var.cloudflare_zone_id
  pattern     = each.value
  script_name = cloudflare_worker_script.edge_app.name
}
```

**79.4.2 Edge Data Synchronization**
```typescript
// Edge KV store for distributed state
interface EdgeKVStore {
  get(key: string): Promise<string | null>;
  put(key: string, value: string, ttl?: number): Promise<void>;
  delete(key: string): Promise<void>;
}

// Distributed configuration management
class EdgeConfigManager {
  private kv: EdgeKVStore;
  
  async getFeatureFlags(userId: string): Promise<Record<string, boolean>> {
    const cacheKey = `feature_flags:${userId}`;
    const cached = await this.kv.get(cacheKey);
    
    if (cached) {
      return JSON.parse(cached);
    }
    
    // Fallback to origin if not in edge cache
    const flags = await this.fetchFromOrigin(userId);
    await this.kv.put(cacheKey, JSON.stringify(flags), 300); // 5min TTL
    
    return flags;
  }
}
```

### 79.5 Performance e Monitoramento

**79.5.1 Edge Metrics**
```typescript
// Performance tracking
interface EdgeMetrics {
  cacheHitRatio: number;
  edgeResponseTime: number;
  originResponseTime: number;
  bandwidthSaved: number;
  errorRate: number;
}

// Monitoring implementation
class EdgeMonitoring {
  async trackRequest(request: Request, response: Response, timing: PerformanceTiming) {
    const metrics = {
      timestamp: Date.now(),
      url: request.url,
      method: request.method,
      status: response.status,
      cacheStatus: response.headers.get('CF-Cache-Status'),
      edgeLocation: response.headers.get('CF-RAY')?.split('-')[1],
      responseTime: timing.responseEnd - timing.requestStart,
      country: request.headers.get('CF-IPCountry')
    };
    
    // Send to analytics
    await this.sendMetrics(metrics);
  }
}
```

**79.5.2 Edge Debugging**
```typescript
// Debug headers for edge troubleshooting
function addDebugHeaders(response: Response, request: Request): Response {
  const headers = new Headers(response.headers);
  
  headers.set('X-Edge-Cache', response.headers.get('CF-Cache-Status') || 'MISS');
  headers.set('X-Edge-Location', request.cf?.colo || 'unknown');
  headers.set('X-Edge-Country', request.headers.get('CF-IPCountry') || 'unknown');
  headers.set('X-Edge-Timestamp', new Date().toISOString());
  
  return new Response(response.body, {
    status: response.status,
    statusText: response.statusText,
    headers
  });
}
```

### 79.6 Checklist Edge Computing
- [ ] CDN configurado com cache inteligente
- [ ] Edge functions para lÃ³gica de negÃ³cio simples
- [ ] Cache invalidation strategy definida
- [ ] Geolocation-based routing implementado
- [ ] A/B testing na borda configurado
- [ ] Bot detection e rate limiting
- [ ] MÃ©tricas de performance monitoradas
- [ ] Fallback para origin em caso de falha
- [ ] Edge KV store para estado distribuÃ­do
- [ ] Debug headers para troubleshooting

- [80) Multi-Cloud - PadrÃµes de Portabilidade e GovernanÃ§a](#80-multi-cloud---padrÃµes-de-portabilidade-e-governanÃ§a)

## 80) Multi-Cloud - PadrÃµes de Portabilidade e GovernanÃ§a
<!-- tags: multi-cloud, portability, governance, vendor-lock-in, hybrid-cloud -->
<!-- category: cloud-architecture -->
<!-- priority: medium -->
<!-- audience: architects, devops, platform-engineers -->

**Objetivo**: Estabelecer padrÃµes para arquiteturas multi-cloud que garantam portabilidade, reduzam vendor lock-in e mantenham governanÃ§a consistente.

### 80.1 EstratÃ©gias de AbstraÃ§Ã£o

**Camadas de AbstraÃ§Ã£o**:
```typescript
// Interface comum para serviÃ§os de nuvem
interface CloudStorageService {
  upload(key: string, data: Buffer): Promise<string>;
  download(key: string): Promise<Buffer>;
  delete(key: string): Promise<void>;
  list(prefix?: string): Promise<string[]>;
}

// ImplementaÃ§Ã£o AWS
class AWSStorageService implements CloudStorageService {
  constructor(private s3: AWS.S3, private bucket: string) {}
  
  async upload(key: string, data: Buffer): Promise<string> {
    const result = await this.s3.upload({
      Bucket: this.bucket,
      Key: key,
      Body: data
    }).promise();
    return result.Location;
  }
  
  async download(key: string): Promise<Buffer> {
    const result = await this.s3.getObject({
      Bucket: this.bucket,
      Key: key
    }).promise();
    return result.Body as Buffer;
  }
}

// ImplementaÃ§Ã£o Azure
class AzureStorageService implements CloudStorageService {
  constructor(private blobService: BlobServiceClient, private container: string) {}
  
  async upload(key: string, data: Buffer): Promise<string> {
    const blockBlobClient = this.blobService
      .getContainerClient(this.container)
      .getBlockBlobClient(key);
    
    await blockBlobClient.upload(data, data.length);
    return blockBlobClient.url;
  }
}
```

**Factory Pattern para Providers**:
```typescript
class CloudServiceFactory {
  static createStorageService(provider: 'aws' | 'azure' | 'gcp'): CloudStorageService {
    switch (provider) {
      case 'aws':
        return new AWSStorageService(
          new AWS.S3({ region: process.env.AWS_REGION }),
          process.env.AWS_BUCKET!
        );
      case 'azure':
        return new AzureStorageService(
          new BlobServiceClient(process.env.AZURE_STORAGE_CONNECTION_STRING!),
          process.env.AZURE_CONTAINER!
        );
      case 'gcp':
        return new GCPStorageService(
          new Storage({ projectId: process.env.GCP_PROJECT_ID }),
          process.env.GCP_BUCKET!
        );
      default:
        throw new Error(`Unsupported provider: ${provider}`);
    }
  }
}
```

### 80.2 ConfiguraÃ§Ã£o Multi-Provider

**Terraform Multi-Cloud**:
```hcl
# terraform/providers.tf
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "~> 3.0"
    }
    google = {
      source  = "hashicorp/google"
      version = "~> 4.0"
    }
  }
}

# ConfiguraÃ§Ã£o por regiÃ£o/provider
provider "aws" {
  alias  = "primary"
  region = var.aws_primary_region
}

provider "azurerm" {
  alias = "secondary"
  features {}
}

# MÃ³dulo reutilizÃ¡vel
module "storage_aws" {
  source = "./modules/storage/aws"
  providers = {
    aws = aws.primary
  }
  
  bucket_name = "${var.project_name}-${var.environment}-aws"
  tags = local.common_tags
}

module "storage_azure" {
  source = "./modules/storage/azure"
  providers = {
    azurerm = azurerm.secondary
  }
  
  storage_account_name = "${var.project_name}${var.environment}az"
  tags = local.common_tags
}
```

**ConfiguraÃ§Ã£o de AplicaÃ§Ã£o**:
```yaml
# config/multi-cloud.yaml
cloud:
  primary_provider: aws
  secondary_provider: azure
  
  providers:
    aws:
      region: us-east-1
      storage:
        bucket: myapp-prod-aws
      compute:
        instance_type: t3.medium
    
    azure:
      region: East US
      storage:
        account: myappprodaz
        container: data
      compute:
        vm_size: Standard_B2s
    
    gcp:
      region: us-central1
      storage:
        bucket: myapp-prod-gcp
      compute:
        machine_type: e2-medium

# EstratÃ©gia de failover
failover:
  enabled: true
  health_check_interval: 30s
  failure_threshold: 3
  recovery_threshold: 2
```

### 80.3 PadrÃµes de Dados Multi-Cloud

**SincronizaÃ§Ã£o de Dados**:
```typescript
class MultiCloudDataSync {
  constructor(
    private primaryStorage: CloudStorageService,
    private secondaryStorage: CloudStorageService,
    private logger: Logger
  ) {}
  
  async syncData(key: string, data: Buffer): Promise<void> {
    try {
      // Upload para provider primÃ¡rio
      const primaryUrl = await this.primaryStorage.upload(key, data);
      this.logger.info('Data uploaded to primary', { key, url: primaryUrl });
      
      // Sync assÃ­ncrono para secundÃ¡rio
      this.syncToSecondary(key, data).catch(error => {
        this.logger.error('Secondary sync failed', { key, error });
        // Adicionar Ã  fila de retry
        this.addToRetryQueue(key, data);
      });
      
    } catch (error) {
      this.logger.error('Primary upload failed', { key, error });
      // Fallback para secundÃ¡rio
      await this.secondaryStorage.upload(key, data);
    }
  }
  
  private async syncToSecondary(key: string, data: Buffer): Promise<void> {
    await this.secondaryStorage.upload(key, data);
    this.logger.info('Data synced to secondary', { key });
  }
}
```

**Backup Cross-Cloud**:
```typescript
class CrossCloudBackup {
  async createBackup(sourceProvider: string, targetProvider: string): Promise<void> {
    const source = CloudServiceFactory.createStorageService(sourceProvider as any);
    const target = CloudServiceFactory.createStorageService(targetProvider as any);
    
    const files = await source.list();
    
    for (const file of files) {
      try {
        const data = await source.download(file);
        await target.upload(`backup/${new Date().toISOString()}/${file}`, data);
        
        this.logger.info('File backed up', {
          file,
          source: sourceProvider,
          target: targetProvider
        });
      } catch (error) {
        this.logger.error('Backup failed for file', { file, error });
      }
    }
  }
}
```

### 80.4 Monitoramento Multi-Cloud

**MÃ©tricas Unificadas**:
```typescript
interface CloudMetrics {
  provider: string;
  region: string;
  service: string;
  metrics: {
    availability: number;
    latency: number;
    cost: number;
    requests: number;
  };
  timestamp: Date;
}

class MultiCloudMonitoring {
  async collectMetrics(): Promise<CloudMetrics[]> {
    const providers = ['aws', 'azure', 'gcp'];
    const metrics: CloudMetrics[] = [];
    
    for (const provider of providers) {
      try {
        const providerMetrics = await this.getProviderMetrics(provider);
        metrics.push(...providerMetrics);
      } catch (error) {
        this.logger.error('Failed to collect metrics', { provider, error });
      }
    }
    
    return metrics;
  }
  
  private async getProviderMetrics(provider: string): Promise<CloudMetrics[]> {
    switch (provider) {
      case 'aws':
        return this.getAWSMetrics();
      case 'azure':
        return this.getAzureMetrics();
      case 'gcp':
        return this.getGCPMetrics();
      default:
        return [];
    }
  }
}
```

**Dashboard Unificado**:
```yaml
# grafana/multi-cloud-dashboard.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: multi-cloud-dashboard
data:
  dashboard.json: |
    {
      "dashboard": {
        "title": "Multi-Cloud Overview",
        "panels": [
          {
            "title": "Availability by Provider",
            "type": "stat",
            "targets": [
              {
                "expr": "avg_over_time(cloud_availability[5m])",
                "legendFormat": "{{provider}}"
              }
            ]
          },
          {
            "title": "Cost Comparison",
            "type": "bargauge",
            "targets": [
              {
                "expr": "sum(cloud_cost_hourly) by (provider)",
                "legendFormat": "{{provider}}"
              }
            ]
          },
          {
            "title": "Latency Distribution",
            "type": "heatmap",
            "targets": [
              {
                "expr": "histogram_quantile(0.95, cloud_latency_bucket)",
                "legendFormat": "{{provider}} - {{region}}"
              }
            ]
          }
        ]
      }
    }
```

### 80.5 GovernanÃ§a e Compliance

**PolÃ­ticas Unificadas**:
```yaml
# policies/multi-cloud-governance.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: cloud-governance-policies
data:
  security-policy.yaml: |
    policies:
      - name: encryption-at-rest
        description: "All data must be encrypted at rest"
        providers:
          aws:
            s3:
              server_side_encryption: "AES256"
            ebs:
              encrypted: true
          azure:
            storage:
              encryption:
                services:
                  blob:
                    enabled: true
          gcp:
            storage:
              encryption:
                default_kms_key_name: "projects/PROJECT/locations/LOCATION/keyRings/RING/cryptoKeys/KEY"
      
      - name: network-security
        description: "Network access must be restricted"
        providers:
          aws:
            vpc:
              enable_dns_hostnames: true
              enable_dns_support: true
            security_groups:
              ingress:
                - protocol: "tcp"
                  from_port: 443
                  to_port: 443
                  cidr_blocks: ["10.0.0.0/8"]
          azure:
            network_security_group:
              security_rule:
                - name: "AllowHTTPS"
                  protocol: "Tcp"
                  source_port_range: "*"
                  destination_port_range: "443"
                  access: "Allow"
```

**Auditoria Cross-Cloud**:
```typescript
class MultiCloudAudit {
  async generateComplianceReport(): Promise<ComplianceReport> {
    const providers = await this.getActiveProviders();
    const report: ComplianceReport = {
      timestamp: new Date(),
      providers: [],
      overall_score: 0
    };
    
    for (const provider of providers) {
      const providerReport = await this.auditProvider(provider);
      report.providers.push(providerReport);
    }
    
    report.overall_score = this.calculateOverallScore(report.providers);
    return report;
  }
  
  private async auditProvider(provider: string): Promise<ProviderComplianceReport> {
    const checks = [
      this.checkEncryption(provider),
      this.checkNetworkSecurity(provider),
      this.checkAccessControls(provider),
      this.checkLogging(provider)
    ];
    
    const results = await Promise.all(checks);
    
    return {
      provider,
      checks: results,
      score: results.filter(r => r.passed).length / results.length
    };
  }
}
```

### 80.6 Checklist de ImplementaÃ§Ã£o Multi-Cloud

**Planejamento**:
- [ ] Definir estratÃ©gia multi-cloud (hÃ­brida, multi-ativa, DR)
- [ ] Mapear serviÃ§os equivalentes entre providers
- [ ] Estabelecer polÃ­ticas de governanÃ§a unificadas
- [ ] Definir estratÃ©gia de dados (replicaÃ§Ã£o, backup, sync)

**ImplementaÃ§Ã£o**:
- [ ] Criar abstraÃ§Ãµes para serviÃ§os de nuvem
- [ ] Implementar factory patterns para providers
- [ ] Configurar IaC multi-provider (Terraform)
- [ ] Estabelecer pipelines de deploy multi-cloud

**OperaÃ§Ã£o**:
- [ ] Implementar monitoramento unificado
- [ ] Configurar alertas cross-cloud
- [ ] Estabelecer processos de failover
- [ ] Criar dashboards de custo e performance

**GovernanÃ§a**:
- [ ] Implementar polÃ­ticas de seguranÃ§a consistentes
- [ ] Configurar auditoria cross-cloud
- [ ] Estabelecer processos de compliance
- [ ] Criar relatÃ³rios de governanÃ§a automatizados

## 81) Steering Documents - GovernanÃ§a de Projetos EstratÃ©gicos
<!-- tags: governance, project-management, documentation, strategic-projects, modernization -->
<!-- category: project-governance -->
<!-- priority: high -->
<!-- audience: tech-leads, architects, project-managers, stakeholders -->

**Aplicabilidade**: Projetos estratÃ©gicos com duraÃ§Ã£o > 3 meses, modernizaÃ§Ãµes, migraÃ§Ãµes, ou projetos com impacto em mÃºltiplos sistemas/equipes.

### 81.1 Conjunto ObrigatÃ³rio de Steering Documents

**Para projetos estratÃ©gicos, o seguinte conjunto Ã© OBRIGATÃ“RIO**:

1. **Product Requirements Document (PRD)**
   - Objetivos de negÃ³cio e tÃ©cnicos
   - MÃ©tricas de sucesso mensurÃ¡veis
   - Stakeholders e responsabilidades
   - Requisitos funcionais e nÃ£o-funcionais

2. **Technical Specification**
   - Arquitetura alvo detalhada
   - Stack tecnolÃ³gico e justificativas
   - PadrÃµes de implementaÃ§Ã£o
   - EstratÃ©gia de testes e migraÃ§Ã£o

3. **Project Charter**
   - AutorizaÃ§Ã£o formal do projeto
   - OrganizaÃ§Ã£o da equipe
   - Timeline e marcos crÃ­ticos
   - OrÃ§amento e critÃ©rios de sucesso

4. **Risk Register**
   - Matriz de riscos (probabilidade Ã— impacto)
   - EstratÃ©gias de mitigaÃ§Ã£o
   - Planos de contingÃªncia
   - Indicadores de alerta precoce

5. **Governance Document**
   - Estrutura organizacional
   - Processos de desenvolvimento
   - Quality Gates
   - GestÃ£o de mudanÃ§as

6. **Status Report Template**
   - ComunicaÃ§Ã£o padronizada com stakeholders
   - MÃ©tricas e KPIs
   - EscalaÃ§Ã£o de issues

### 81.2 Templates Padronizados

**Todos os templates devem incluir**:
```markdown
---
title: "[TÃ­tulo do Documento]"
version: "v1.0"
date: "YYYY-MM-DD"
author: "[Nome do Autor]"
reviewer: "[Nome do Revisor]"
status: "draft|review|approved|deprecated"
project: "[Nome do Projeto]"
stakeholders: ["lista", "de", "stakeholders"]
---
```

**Estrutura de pastas obrigatÃ³ria**:
```
/docs/
  /steering/
    - PRD.md
    - TECH_SPEC.md
    - PROJECT_CHARTER.md
    - RISK_REGISTER.md
    - GOVERNANCE.md
    - STEERING_SUMMARY.md
  /templates/
    - PRD_TEMPLATE.md
    - TECH_SPEC_TEMPLATE.md
    - PROJECT_CHARTER_TEMPLATE.md
    - RISK_REGISTER_TEMPLATE.md
    - GOVERNANCE_TEMPLATE.md
    - STATUS_REPORT_TEMPLATE.md
```

### 81.3 Processo de AprovaÃ§Ã£o

**Gates de AprovaÃ§Ã£o ObrigatÃ³rios**:

1. **Gate 1 - Steering Documents Review**
   - Todos os steering documents criados
   - RevisÃ£o tÃ©cnica e de negÃ³cio
   - AprovaÃ§Ã£o formal dos stakeholders

2. **Gate 2 - Implementation Readiness**
   - Ambiente de desenvolvimento configurado
   - Equipe treinada e alocada
   - Riscos crÃ­ticos mitigados

3. **Gate 3 - Go-Live Readiness**
   - Testes de aceitaÃ§Ã£o concluÃ­dos
   - Plano de rollback validado
   - Monitoramento configurado

### 81.4 MÃ©tricas de Qualidade

**MÃ©tricas obrigatÃ³rias para steering documents**:

- **Completude**: % de seÃ§Ãµes preenchidas vs template
- **AtualizaÃ§Ã£o**: FrequÃªncia de updates (mÃ­nimo semanal)
- **AprovaÃ§Ã£o**: Tempo mÃ©dio para aprovaÃ§Ã£o de mudanÃ§as
- **Rastreabilidade**: % de decisÃµes com ADR correspondente

### 81.5 IntegraÃ§Ã£o com Processos Existentes

**Relacionamento com outras seÃ§Ãµes do Global Rules**:

- **SeÃ§Ã£o 3 (DocumentaÃ§Ã£o)**: Steering documents complementam documentaÃ§Ã£o tÃ©cnica
- **SeÃ§Ã£o 33 (ADR Template)**: ADRs documentam decisÃµes tÃ©cnicas especÃ­ficas
- **SeÃ§Ã£o 11 (ModernizaÃ§Ã£o de Legado)**: Steering documents sÃ£o obrigatÃ³rios para modernizaÃ§Ãµes
- **SeÃ§Ã£o 25 (ROI, Riscos e Roadmap)**: Risk Register integra com anÃ¡lise de ROI

### 81.6 Ferramentas e AutomaÃ§Ã£o

**AutomaÃ§Ã£o recomendada**:

```yaml
# GitHub Actions - Steering Documents Validation
name: Validate Steering Documents
on:
  pull_request:
    paths: ['docs/steering/**']
jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Validate Document Structure
        run: |
          # Validar presenÃ§a de metadados obrigatÃ³rios
          # Verificar completude vs templates
          # Validar links e referÃªncias
```

**Dashboard de Status**:
- Status de cada documento (draft/review/approved)
- MÃ©tricas de qualidade em tempo real
- Alertas para documentos desatualizados

### 81.7 Checklist de ImplementaÃ§Ã£o

**Para adotar esta seÃ§Ã£o em um projeto**:

- [ ] Criar estrutura de pastas `/docs/steering/` e `/docs/templates/`
- [ ] Adaptar templates para contexto especÃ­fico do projeto
- [ ] Definir stakeholders e processo de aprovaÃ§Ã£o
- [ ] Configurar automaÃ§Ã£o de validaÃ§Ã£o
- [ ] Treinar equipe nos novos processos
- [ ] Estabelecer cadÃªncia de revisÃ£o (semanal/quinzenal)

### SeÃ§Ãµes de Apoio
- [ApÃªndices Opcionais por Stack](#apÃªndices-opcionais-por-stack)
- [Fluxo Recomendado de ExecuÃ§Ã£o](#fluxo-recomendado-de-execuÃ§Ã£o)
- [PR Checklist (genÃ©rico)](#pr-checklist-genÃ©rico)

---

## ðŸš€ NavegaÃ§Ã£o RÃ¡pida

### Por Categoria
**ðŸ—ï¸ Fundamentos (1-15)**
- [SeÃ§Ã£o 1: PrincÃ­pios Production-First](#1-princÃ­pios-productionfirst-obrigatÃ³rios) | [SeÃ§Ã£o 4: Arquitetura](#4-arquitetura-e-organizaÃ§Ã£o) | [SeÃ§Ã£o 5: SOLID](#5-solid--aplicaÃ§Ã£o-prÃ¡tica) | [SeÃ§Ã£o 6: DDD](#6-ddd--diretrizes-objetivas) | [SeÃ§Ã£o 7: CQRS](#7-cqrs--padrÃ£o-pragmÃ¡tico) | [SeÃ§Ã£o 8: Clean Architecture](#8-clean-architecture--contratos-e-fluxo)

**ðŸ§ª Desenvolvimento & Qualidade (16-30)**
- [SeÃ§Ã£o 16: Testes](#16-testes) | [SeÃ§Ã£o 17: QA/E2E](#17-qa--padrÃµes-de-e2e-visuais-playwright) | [SeÃ§Ã£o 20: APIs](#20-design-de-apis-restgraphql) | [SeÃ§Ã£o 22: Performance](#22-performance-e-caching) | [SeÃ§Ã£o 29: DÃ©bito TÃ©cnico](#29-dÃ©bito-tÃ©cnico-e-triagem)

**ðŸŽ¨ Frontend & UX (31-40)**
- [SeÃ§Ã£o 31: Frontend BÃ¡sico](#31-frontend--padrÃµes-bÃ¡sicos) | [SeÃ§Ã£o 32: Frontend AvanÃ§ado](#32-frontend--padrÃµes-avanÃ§ados) | [SeÃ§Ã£o 33: PIV](#33-preservaÃ§Ã£o-de-identidade-visual-piv--guia-definitivo) | [SeÃ§Ã£o 38: Tailwind+SASS](#38-tailwind-css--sass--abordagem-hÃ­brida) | [SeÃ§Ã£o 39: Micro-frontends](#39-micro-frontends---padrÃµes-de-federaÃ§Ã£o-e-comunicaÃ§Ã£o)

**ðŸ”’ SeguranÃ§a (41-43)**
- [SeÃ§Ã£o 41: SeguranÃ§a Essencial](#41-seguranÃ§a-essencial-owasp-top-10) | [SeÃ§Ã£o 42: SeguranÃ§a AvanÃ§ada](#42-seguranÃ§a-avanÃ§ada) | [SeÃ§Ã£o 43: LGPD/GDPR](#43-dados-privacidade-e-lgpdgdpr)

**ðŸš€ ProduÃ§Ã£o & DevOps (44-60)**
- [SeÃ§Ã£o 44: CI/CD](#44-cicd-e-deploy) | [SeÃ§Ã£o 46: Observabilidade](#46-observabilidade-logs-mÃ©tricas-traces) | [SeÃ§Ã£o 47: SLO/SLI](#47-sloslisl-e-orÃ§amento-de-erros) | [SeÃ§Ã£o 50: Kubernetes](#50-kubernetes-produÃ§Ã£o) | [SeÃ§Ã£o 54: Backup/DR](#54-backupdr--polÃ­tica-e-testes)

**ðŸ“‹ GovernanÃ§a & GestÃ£o (61-70)**
- [SeÃ§Ã£o 61: GovernanÃ§a de Repo](#61-governanÃ§a-de-repositÃ³rio) | [SeÃ§Ã£o 63: ROI & Roadmap](#63-roi-riscos-e-roadmap-tÃ©cnico) | [SeÃ§Ã£o 64: Onboarding](#64-onboarding-e-conhecimento) | [SeÃ§Ã£o 65: Data Governance](#65-data-governance-e-lineage)

### Por UrgÃªncia
**ðŸ”¥ CrÃ­tico (Production-First)**
- [SeÃ§Ã£o 1: PrincÃ­pios ObrigatÃ³rios](#1-princÃ­pios-productionfirst-obrigatÃ³rios) | [SeÃ§Ã£o 48: GestÃ£o de Incidentes](#48-gestÃ£o-de-incidentes-e-postmortem) | [SeÃ§Ã£o 54: Backup/DR](#54-backupdr--polÃ­tica-e-testes)

**âš¡ Alto Impacto**
- [SeÃ§Ã£o 11: ResoluÃ§Ã£o de Problemas](#11-estratÃ©gias-comprovadas-de-resoluÃ§Ã£o-de-problemas) | [SeÃ§Ã£o 12: ResoluÃ§Ã£o em Massa](#12-padrÃµes-para-resoluÃ§Ã£o-em-massa-alto-roi) | [SeÃ§Ã£o 29: DÃ©bito TÃ©cnico](#29-dÃ©bito-tÃ©cnico-e-triagem)

**ðŸ“‹ GovernanÃ§a**
- [SeÃ§Ã£o 61: GovernanÃ§a de Repo](#61-governanÃ§a-de-repositÃ³rio) | [SeÃ§Ã£o 13: ADR Template](#13-adr--template) | [SeÃ§Ã£o 14: ConvenÃ§Ãµes](#14-convenÃ§Ãµes-de-commits-branches-e-releases)

---

## SeÃ§Ãµes de Apoio
## ApÃªndices Opcionais por Stack

### QA â€“ Playwright (E2E) (opcional)
- Projetos: Chromium/Firefox/WebKit; executar em headless/headed conforme necessidade.
- Determinismo: aguardar fontes/carregamento estÃ¡vel; setar `data-theme` quando necessÃ¡rio.

### Frontend â€“ PadrÃµes Gerais (opcional)
- Rotas lazy + boundaries; estado com hooks/signals; estilos com tokens e Sass modular.

### ModernizaÃ§Ã£o de Legacy (opcional)
- EstratÃ©gia incremental; preservar UX; KPIs e riskâ€‘based planning.

### Angular â€“ PadrÃµes EspecÃ­ficos (opcional)
- **Signals over Legacy**: priorizar implementaÃ§Ãµes com signals sobre [(ngModel)]
- **Typeâ€‘safe templates**: usar cast seguro `($event.target as HTMLInputElement).value` em vez de `$any()`
- **Build incremental**: resolver TS2393 (duplicate function) manualmente com `ng build` apÃ³s cada correÃ§Ã£o
- **Componentes genÃ©ricos**: criar `DataTable<T>` typeâ€‘safe para reduzir repetiÃ§Ã£o de cÃ³digo

## Checklists RÃ¡pidos

### Deploy Productionâ€‘Ready
- [ ] Config por env validada
- [ ] Health/Ready/Live
- [ ] Logs estruturados + correlaÃ§Ã£o
- [ ] MÃ©tricas RED/USE + tracing
- [ ] Rate limiting + headers + TLS
- [ ] CI/CD com gates + scans
- [ ] Rollback testado + backup

### Frontend PR
- [ ] A11y sem violaÃ§Ãµes crÃ­ticas
- [ ] Perf budgets atendidos
- [ ] Rotas lazy + boundaries
- [ ] Tokens CSS + responsividade
- [ ] Testes unit/integration/E2E

### Backend PR
- [ ] Endpoints idempotentes onde aplicÃ¡vel
- [ ] Erros no padrÃ£o Problem Details
- [ ] Regras de negÃ³cio cobertas por testes
- [ ] Observabilidade nas rotas crÃ­ticas
- [ ] SeguranÃ§a (authz/authn/inputs)

## Anexos Visuais â€“ Diagramas (Mermaid)
Este anexo oferece diagramas de referÃªncia para fluxos citados nas seÃ§Ãµes (Clean Architecture, CQRS e Strangler Fig).

### Clean Architecture (ref. SeÃ§Ã£o 54)
```mermaid
flowchart LR
  A[Client] --> B[API Layer]
  B --> C[Application Layer]
  C --> D[Domain Layer]
  C --> E[Infrastructure]
  D <-- events --> C
  E -->|DB/External| C
```

### CQRS (ref. SeÃ§Ã£o 53)
```mermaid
flowchart LR
  A[Controller] --> B[Command Handler]
  A --> C[Query Handler]
  B --> D[(Write Model)]
  C --> E[(Read Model)]
```

### Strangler Fig â€“ ModernizaÃ§Ã£o de Legado (ref. SeÃ§Ã£o 37)
```mermaid
flowchart LR
  subgraph Legacy
    L1[Legacy UI] --> L2[Legacy Services]
  end
  subgraph Modern
    M1[Modern UI] --> M2[Modern Services]
  end
  G[Gateway/Proxy] --> L1
  G --> M1
  %% Roteamento progressivo
  style Legacy fill:#ffeeee,stroke:#cc8888
  style Modern fill:#e8ffea,stroke:#88cc88
```

## Snippets de Rotas (React e Angular)

### React Router v6 â€“ Rotas Lazy + Providers
```tsx
// src/routes/index.tsx
import { Suspense, lazy } from 'react';
import { createBrowserRouter, RouterProvider } from 'react-router-dom';

const Home = lazy(() => import('@pages/Home'));
const Users = lazy(() => import('@pages/Users'));

const router = createBrowserRouter([
  { path: '/', element: <Home /> },
  { path: '/users', element: <Users /> }
]);

export function AppRouter() {
  return (
    <Suspense fallback={<div>Carregandoâ€¦</div>}>
      <RouterProvider router={router} />
    </Suspense>
  );
}
```
```tsx
// src/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { AppRouter } from '@routes/index';

const qc = new QueryClient({
  defaultOptions: {
    queries: { retry: 1, refetchOnWindowFocus: false, staleTime: 60_000 }
  }
});

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <QueryClientProvider client={qc}>
      <AppRouter />
    </QueryClientProvider>
  </React.StrictMode>
);
```

### Angular â€“ Rotas Standalone + Providers
```ts
// src/app/app.routes.ts
import { Routes } from '@angular/router';

export const routes: Routes = [
  { path: '', loadComponent: () => import('./features/home/home.page').then(m => m.HomePage) },
  { path: 'users', loadComponent: () => import('./features/users/users.page').then(m => m.UsersPage) }
];
```
```ts
// src/app/app.config.ts
import { ApplicationConfig } from '@angular/core';
import { provideRouter } from '@angular/router';
import { routes } from './app.routes';

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(routes)
    // provideHttpClient(), interceptors, etc.
  ]
};
```

## Fluxo Recomendado de ExecuÃ§Ã£o
1. **Planejar**: objetivos, mÃ©tricas (ROI/KPIs), riscos, protocolos de seguranÃ§a.
2. **Baseline**: lint, build, testes, seguranÃ§a, performance.
3. **Aplicar mudanÃ§as curtas e seguras**: validaÃ§Ã£o incremental + rollback quando necessÃ¡rio.
4. **Medir efeito cascata**: priorizar correÃ§Ãµes com maior impacto indireto.
5. **Documentar e automatizar**: ADRs, pipelines, dashboards, alertas.

## PR Checklist (genÃ©rico)
- [ ] CÃ³digo limpo, tipado e formatado; imports organizados
- [ ] Testes (unit/integration/e2e) cobrindo mudanÃ§as e sem flaky
- [ ] SeguranÃ§a: inputs saneados; secrets seguros; headers adequados
- [ ] Observabilidade: logs/metrics/traces para paths crÃ­ticos
- [ ] A11y/Performance (frontend) validados
- [ ] DocumentaÃ§Ã£o (README/ADR/guia de uso) atualizada

### Mobile/React Native (quando aplicÃ¡vel)
- [ ] Performance testada em release builds (`dev=false`)

---

## ðŸ“š Ãndice de Busca por Palavras-Chave

### A-D
**API** â†’ [SeÃ§Ã£o 18: Design de APIs](#18-design-de-apis-restgraphql) | [SeÃ§Ã£o 58: API Governance](#58-api-governance-e-versionamento)  
**Arquitetura** â†’ [SeÃ§Ã£o 4: Arquitetura](#4-arquitetura-e-organizaÃ§Ã£o) | [SeÃ§Ã£o 52: DDD](#52-ddd--diretrizes-objetivas) | [SeÃ§Ã£o 54: Clean Architecture](#54-clean-architecture--contratos-e-fluxo)  
**Backup** â†’ [SeÃ§Ã£o 63: Backup/DR](#63-backupdr--polÃ­tica-e-testes)  
**Cache** â†’ [SeÃ§Ã£o 19: Performance e Caching](#19-performance-e-caching)  
**CI/CD** â†’ [SeÃ§Ã£o 7: CI/CD](#7-cicd-e-deploy) | [SeÃ§Ã£o 25: CI/CD AvanÃ§ado](#25-cicd-avanÃ§ado)  
**CORS** â†’ [SeÃ§Ã£o 34: CORS](#34-cors-e-headers-de-seguranÃ§a)  
**CQRS** â†’ [SeÃ§Ã£o 53: CQRS](#53-cqrs--padrÃ£o-pragmÃ¡tico)  
**CSS** â†’ [SeÃ§Ã£o 73: Tailwind+SASS](#73-tailwind-css--sass--abordagem-hÃ­brida)  
**Dados** â†’ [SeÃ§Ã£o 17: LGPD/GDPR](#17-dados-privacidade-e-lgpdgdpr) | [SeÃ§Ã£o 60: Dados de Teste](#60-dados-de-teste-mascaramento-e-sÃ­ntese) | [SeÃ§Ã£o 65: Data Governance](#65-data-governance-e-lineage)  
**DDD** â†’ [SeÃ§Ã£o 52: DDD](#52-ddd--diretrizes-objetivas)  
**DÃ©bito TÃ©cnico** â†’ [SeÃ§Ã£o 30: DÃ©bito TÃ©cnico](#30-dÃ©bito-tÃ©cnico-e-triagem)  
**Deploy** â†’ [SeÃ§Ã£o 7: CI/CD e Deploy](#7-cicd-e-deploy)  
**DocumentaÃ§Ã£o** â†’ [SeÃ§Ã£o 3: DocumentaÃ§Ã£o](#3-documentaÃ§Ã£o-padrÃ£o) | [SeÃ§Ã£o 35: ADR](#35-adr--template)  

### E-L
**Erros** â†’ [SeÃ§Ã£o 61: Taxonomia de Erros](#61-taxonomia-de-erros-e-correlaÃ§Ã£o)  
**Feature Flags** â†’ [SeÃ§Ã£o 16: Feature Flags](#16-change-management-e-feature-flags)  
**Frontend** â†’ [SeÃ§Ã£o 10: Frontend Geral](#10-frontend--padrÃµes-gerais) | [SeÃ§Ã£o 21: Frontend EspecÃ­fico](#21-frontend--seÃ§Ãµes-especÃ­ficas)  
**Incidentes** â†’ [SeÃ§Ã£o 15: GestÃ£o de Incidentes](#15-gestÃ£o-de-incidentes-e-postmortem)  
**Kubernetes** â†’ [SeÃ§Ã£o 24: Kubernetes](#24-kubernetes-produÃ§Ã£o)  
**Legacy** â†’ [SeÃ§Ã£o 11: ModernizaÃ§Ã£o](#11-modernizaÃ§Ã£o-de-legacy) | [SeÃ§Ã£o 37: EstratÃ©gia Completa](#37-modernizaÃ§Ã£o-de-legado--estratÃ©gia-completa)  
**LGPD** â†’ [SeÃ§Ã£o 17: LGPD/GDPR](#17-dados-privacidade-e-lgpdgdpr)  
**Logs** â†’ [SeÃ§Ã£o 8: Observabilidade](#8-observabilidade-logs-mÃ©tricas-traces)  

### M-S
**MÃ©tricas** â†’ [SeÃ§Ã£o 8: Observabilidade](#8-observabilidade-logs-mÃ©tricas-traces) | [SeÃ§Ã£o 14: SLO/SLI](#14-sloslisl-e-orÃ§amento-de-erros)  
**Monorepo** â†’ [SeÃ§Ã£o 68: Monorepo vs Polyrepo](#68-monorepo-vs-polyrepo)  
**Observabilidade** â†’ [SeÃ§Ã£o 8: Observabilidade](#8-observabilidade-logs-mÃ©tricas-traces) | [SeÃ§Ã£o 23: Dashboards](#23-observabilidade--dashboards-e-alertas)  
**Performance** â†’ [SeÃ§Ã£o 19: Performance](#19-performance-e-caching) | [SeÃ§Ã£o 42: Performance Visual](#42-performance-visual-e-ux)  
**PIV** â†’ [SeÃ§Ã£o 36: PreservaÃ§Ã£o Visual](#36-preservaÃ§Ã£o-de-identidade-visual-piv--guia-definitivo)  
**Playwright** â†’ [SeÃ§Ã£o 13: QA/E2E](#13-qa--padrÃµes-de-e2e-visuais-playwright) | [SeÃ§Ã£o 22: Playwright AvanÃ§ado](#22-playwright-avanÃ§ado-e2e-visual)  
**Production-First** â†’ [SeÃ§Ã£o 1: PrincÃ­pios](#1-princÃ­pios-productionfirst-obrigatÃ³rios)  
**RepositÃ³rios** â†’ [SeÃ§Ã£o 26: GovernanÃ§a](#26-governanÃ§a-de-repositÃ³rio) | [SeÃ§Ã£o 56: PolÃ­tica](#56-polÃ­tica-de-repositÃ³rios-sem-duplicaÃ§Ãµes)  
**SeguranÃ§a** â†’ [SeÃ§Ã£o 41: SeguranÃ§a Essencial](#41-seguranÃ§a-essencial-owasp-top-10) | [SeÃ§Ã£o 42: SeguranÃ§a AvanÃ§ada](#42-seguranÃ§a-avanÃ§ada)  
**Serverless** â†’ [SeÃ§Ã£o 76: AWS Lambda](#76-serverless-framework---padrÃµes-aws-lambda)  
**SLO/SLI** â†’ [SeÃ§Ã£o 14: SLO/SLI/SLA](#14-sloslisl-e-orÃ§amento-de-erros)  
**SOLID** â†’ [SeÃ§Ã£o 51: SOLID](#51-solid--aplicaÃ§Ã£o-prÃ¡tica)  

### T-Z
**Testes** â†’ [SeÃ§Ã£o 6: Testes](#6-testes) | [SeÃ§Ã£o 29: NFR](#29-requisitos-nÃ£o-funcionais-nfr-e-testes)  
**Traces** â†’ [SeÃ§Ã£o 8: Observabilidade](#8-observabilidade-logs-mÃ©tricas-traces)  
**Visual Regression** â†’ [SeÃ§Ã£o 41: Visual Regression](#41-visual-regression-pipeline)  

---

**ðŸ’¡ Dica**: Use `Ctrl+F` (ou `Cmd+F`) para buscar termos especÃ­ficos neste documento. As tags HTML comentadas em cada seÃ§Ã£o tambÃ©m facilitam a busca por IDEs modernas.
- [ ] Platform-specific code usando convenÃ§Ãµes corretas (`.native.js`, `.ios.js`, `.android.js`)
- [ ] Native Modules com lifecycle management e error handling adequados
- [ ] Logs nativos funcionando (`npx react-native log-android`/`log-ios`)
- [ ] Threading otimizado (evitar trabalho pesado em `componentDidMount`)
- [ ] NavegaÃ§Ã£o suave (uso de `InteractionManager` quando necessÃ¡rio)

---

**Nota global**: Este documento Ã© genÃ©rico e aplicÃ¡vel a qualquer projeto. Exemplos e termos especÃ­ficos de stacks (ex.: .NET/EF Core, Playwright, React/Angular) sÃ£o apresentados como apÃªndices opcionais. Adapte conforme seu contexto.
</file>

<file path="PRD.md">
Analise e entenda 100% meu Markdown e melhore se necessÃ¡rio


# Product Requirement Document (PRD): BOTLink

| Metadado | Detalhe |
| :--- | :--- |
| **Projeto** | BOTLink - AutomaÃ§Ã£o Cognitiva de Candidaturas |
| **VersÃ£o** | 3.1.0 (Roadmap Completo IncluÃ­do) |
| **Status** | EspecificaÃ§Ã£o Aprovada para Desenvolvimento |
| **Data** | 14 de Janeiro de 2026 |
| **Stack Principal** | Python, Playwright (Camoufox), OpenAI (GPT-4o), SQLite |
| **Arquitetura** | Desktop Local-First (SeguranÃ§a de IP) |

---

## 1. IntroduÃ§Ã£o e VisÃ£o EstratÃ©gica
O **BOTLink** Ã© um agente de software autÃ´nomo projetado para o ecossistema de recrutamento de 2026. Em um cenÃ¡rio onde "Candidaturas Simplificadas" (Easy Apply) geram volume massivo e bloqueios algorÃ­tmicos, a automaÃ§Ã£o convencional (scripts lineares) tornou-se obsoleta e perigosa.

O BOTLink adota a **AutomaÃ§Ã£o Cognitiva**: um sistema capaz de navegar furtivamente (evitando detecÃ§Ã£o), interpretar semanticamente requisitos de vagas (via LLMs) e adaptar respostas com base em um perfil profissional estruturado, operando de forma indistinguÃ­vel de um operador humano.

### 1.1 DeclaraÃ§Ã£o do Problema
1.  **FricÃ§Ã£o:** Profissionais gastam horas repetindo dados em formulÃ¡rios idÃªnticos.
2.  **Bloqueio:** Bots rÃ¡pidos (spam) sÃ£o banidos instantaneamente pelo LinkedIn.
3.  **Complexidade:** Scripts simples falham em perguntas abertas ("Descreva um projeto desafiador").

### 1.2 SoluÃ§Ã£o Proposta
Uma aplicaÃ§Ã£o desktop que gerencia a candidatura de ponta a ponta, respeitando limites estritos de volume (Rate Limiting) e utilizando IA para preenchimento contextual.

---

## 2. DecisÃµes de Arquitetura e Stack TecnolÃ³gica

A escolha da tecnologia Ã© fundamentada na necessidade de **Furtividade (Stealth)** e **Processamento de Dados**.

| Componente | Tecnologia Escolhida | Justificativa TÃ©cnica |
| :--- | :--- | :--- |
| **Linguagem** | **Python 3.10+** | Ecossistema nativo de IA/Data Science. Superior ao Node.js para parsing de PDF e integraÃ§Ã£o com LLMs. |
| **Browser** | **Camoufox** | Fork do Firefox com patches em C++ para evasÃ£o de fingerprinting (User-Agent, WebGL, Canvas). Muito superior ao Selenium. |
| **Driver** | **Playwright** | ComunicaÃ§Ã£o via WebSocket (rÃ¡pida), suporte a *Shadow DOM* (usado pelo LinkedIn) e seletores robustos. |
| **IA / LLM** | **OpenAI API (GPT-4o)** | Capacidade de *Structured Outputs* (JSON Mode) essencial para mapear respostas a inputs HTML. |
| **Database** | **SQLite** | Zero-config, transacional, ideal para armazenamento local de logs e estado. |

---

## 3. Escopo do Produto

### 3.1 In-Scope (MVP)
* Interface GrÃ¡fica (GUI) Desktop (SugestÃ£o: Flet ou CustomTkinter).
* Motor de navegaÃ§Ã£o autÃ´noma para vagas "Easy Apply".
* Parsing inteligente de currÃ­culo e cartas de apresentaÃ§Ã£o.
* Sistema de seguranÃ§a operacional (OpSec) com limites diÃ¡rios.
* Logs detalhados e auditoria de respostas da IA.

### 3.2 Out-of-Scope (Fase 1)
* VersÃ£o Web/SaaS (Risco de IP compartilhado).
* SoluÃ§Ã£o automÃ¡tica de CAPTCHA (O usuÃ¡rio resolve manualmente se necessÃ¡rio).
* AutomaÃ§Ã£o de Networking (DMs, ConexÃµes).

---

## 4. Requisitos de Interface (Front-End)

A interface deve ser minimalista, desacoplada da lÃ³gica e suportar temas visuais.

### 4.1 ConfiguraÃ§Ã£o da Candidatura
* **[FE-01] Painel de Vagas:**
    * **Cargo(s):** Input de tags mÃºltiplas (ex: `[Backend Python]`, `[DevOps]`).
    * **Localidade:** Input de texto (Cidade, Estado, PaÃ­s).
    * **Filtros:** Checkbox para `[x] Apenas Remoto`.
* **[FE-02] Credenciais & SessÃ£o:**
    * Campos para Login/Senha (criptografados localmente).
    * BotÃ£o "Verificar SessÃ£o" (para testar cookies existentes sem login).

### 4.2 Contexto do Candidato (Knowledge Base)
* **[FE-03] Upload de CurrÃ­culo:**
    * BotÃ£o para anexar PDF/DOCX. O sistema deve extrair o texto para memÃ³ria.
* **[FE-04] Perfil Estendido:**
    * **Resumo/Bio:** Ãrea de texto grande para colar Carta de ApresentaÃ§Ã£o e lista de projetos.
    * **Anexos Extras:** Lista para adicionar arquivos suplementares (PortfÃ³lio, Certificados) caso solicitados.

### 4.3 Controle e Monitoramento
* **[FE-05] Comandos:**
    * BotÃ£o `Iniciar BOT` (Verde).
    * BotÃ£o `Parar BOT` (Vermelho - Graceful Shutdown).
* **[FE-06] Dashboard de Logs:**
    * Tabela (Data Grid) com colunas: *Empresa, Vaga, Data, Status, Detalhes*.
    * BotÃ£o `Atualizar Log` (Refresh).
    * Ao clicar em falha, exibir modal com o motivo ou resposta da IA.
* **[FE-07] PersonalizaÃ§Ã£o:**
    * Toggle Switch: **Dark Mode** / **Light Mode**.

---

## 5. Requisitos Funcionais (Back-End)

### 5.1 Motor de NavegaÃ§Ã£o (Stealth)
* **[BE-01] GestÃ£o de Cookies:** O sistema deve salvar `auth.json` apÃ³s o primeiro login. Nas execuÃ§Ãµes seguintes, injeta os cookies para evitar telas de login.
* **[BE-02] SimulaÃ§Ã£o Humana:**
    * Movimento do mouse via Curvas de Bezier.
    * Scroll aleatÃ³rio na pÃ¡gina da vaga antes de aplicar.
* **[BE-03] Upload InvisÃ­vel:** Detectar `input[type='file']` ocultos e injetar o caminho do arquivo sem abrir janela do sistema operacional.

### 5.2 Motor Cognitivo (IA)
* **[BE-04] Parsing de Perguntas:** Extrair o texto da pergunta (`label`) e as opÃ§Ãµes disponÃ­veis (`radio`, `select`).
* **[BE-05] Engenharia de Prompt:** Construir prompt contendo:
    * Contexto do CurrÃ­culo + Bio.
    * Pergunta da vaga.
    * RestriÃ§Ãµes (ex: "Responda apenas com um nÃºmero").
* **[BE-06] SaÃ­da JSON:** ForÃ§ar a resposta da IA em formato JSON estrito para garantir integraÃ§Ã£o com o cÃ³digo Python.

### 5.3 PersistÃªncia
* **[BE-07] Banco de Dados:** Utilizar SQLite. Garantir unicidade de candidatura via `job_id` do LinkedIn.

---

## 6. Requisitos NÃ£o-Funcionais (OpSec & SeguranÃ§a)

**CrÃ­tico:** O LinkedIn impÃµe limites rÃ­gidos. O desrespeito a estas regras causarÃ¡ bloqueio da conta.

| ID | Regra | ImplementaÃ§Ã£o TÃ©cnica |
| :--- | :--- | :--- |
| **RNF-01** | **Limite DiÃ¡rio (Hard Cap)** | O bot deve parar automaticamente ao atingir **40 a 50 candidaturas** em 24h. |
| **RNF-02** | **Warm-up de Conta** | Contas novas no bot devem seguir rampa: Dia 1 (10), Dia 2 (20), Dia 3 (30), Dia 4+ (40). |
| **RNF-03** | **Atrasos AleatÃ³rios** | Entre cada aÃ§Ã£o (clique/digitaÃ§Ã£o), aguardar `random(1.5, 4.0)` segundos. Entre candidaturas, aguardar `random(120, 600)` segundos. |
| **RNF-04** | **Jornada de Trabalho** | O bot deve pausar por 15-30 minutos a cada 10 candidaturas processadas. |
| **RNF-05** | **Tratamento de Erros** | Se houver 3 erros de "Elemento nÃ£o encontrado" consecutivos, abortar sessÃ£o (possÃ­vel mudanÃ§a de layout ou soft-ban). |

---

## 7. Modelo de Dados (Schema SQLite)

```sql
CREATE TABLE config (
    key TEXT PRIMARY KEY,
    value TEXT
);

CREATE TABLE candidaturas (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    job_id TEXT UNIQUE,            -- ID da vaga (ex: 37481923)
    empresa TEXT,
    titulo TEXT,
    localizacao TEXT,
    data_hora DATETIME DEFAULT CURRENT_TIMESTAMP,
    status TEXT CHECK(status IN ('SUCESSO', 'FALHA', 'PULADO')),
    motivo_log TEXT,               -- Ex: "IA respondeu X", "Erro de Timeout"
    tokens_ia INTEGER              -- Para controle de custo da API
);

CREATE TABLE estatisticas_diarias (
    data DATE PRIMARY KEY,
    quantidade INTEGER DEFAULT 0
);
</file>

<file path="pyproject.toml">
[project]
name = "botlink"
version = "0.1.0"
description = "BOTLink - Cognitive Automation for Job Applications"
readme = "README.md"
requires-python = ">=3.10"
license = {text = "MIT"}
authors = [
    {name = "BOTLink Team"}
]
keywords = ["automation", "linkedin", "job-application", "ai"]

dependencies = [
    "flet>=0.21.0",
    "playwright>=1.40.0",
    "openai>=1.12.0",
    "pymupdf>=1.23.0",
    "python-docx>=1.1.0",
    "cryptography>=42.0.0",
    "pydantic>=2.5.0",
    "pydantic-settings>=2.1.0",
    "aiosqlite>=0.19.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.4.0",
    "pytest-asyncio>=0.23.0",
    "pytest-cov>=4.1.0",
    "ruff>=0.1.0",
    "mypy>=1.8.0",
]

[project.scripts]
botlink = "src.main:main"

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.ruff]
line-length = 100
target-version = "py310"

[tool.ruff.lint]
select = ["E", "F", "W", "I", "UP", "B", "C4", "SIM"]
ignore = ["E501"]

[tool.mypy]
python_version = "3.10"
warn_return_any = true
warn_unused_ignores = true
disallow_untyped_defs = true

[tool.pytest.ini_options]
asyncio_mode = "auto"
testpaths = ["tests"]
</file>

<file path="README.md">
# BOTLink - AutomaÃ§Ã£o Cognitiva de Candidaturas

<div align="center">

![Python](https://img.shields.io/badge/Python-3.10+-blue?logo=python&logoColor=white)
![Playwright](https://img.shields.io/badge/Playwright-Latest-green?logo=playwright&logoColor=white)
![OpenAI](https://img.shields.io/badge/OpenAI-GPT--4o-purple?logo=openai&logoColor=white)
![License](https://img.shields.io/badge/License-MIT-yellow)

**Agente autÃ´nomo para automaÃ§Ã£o de candidaturas no LinkedIn com IA**

</div>

---

## ðŸŽ¯ O que Ã© o BOTLink?

O BOTLink Ã© um sistema de **AutomaÃ§Ã£o Cognitiva** que:
- ðŸ¤– Navega furtivamente pelo LinkedIn evitando detecÃ§Ã£o
- ðŸ§  Usa GPT-4o para responder perguntas de candidatura
- ðŸ“„ Extrai informaÃ§Ãµes do seu currÃ­culo automaticamente
- ðŸ›¡ï¸ Respeita limites rÃ­gidos para evitar bloqueios

## ðŸš€ InstalaÃ§Ã£o

### PrÃ©-requisitos

- Python 3.10 ou superior
- Conta no LinkedIn
- API Key do OpenAI (GPT-4o)

### Passos

```bash
# Clone o repositÃ³rio
git clone https://github.com/seu-usuario/botlink.git
cd botlink

# Crie um ambiente virtual
python -m venv venv
source venv/bin/activate  # Linux/Mac
# ou: venv\Scripts\activate  # Windows

# Instale as dependÃªncias
pip install -r requirements.txt

# Instale os navegadores do Playwright
playwright install firefox

# Configure as variÃ¡veis de ambiente
cp .env.example .env
# Edite .env e adicione sua OPENAI_API_KEY
```

## ðŸ“‹ Uso

### Executando a GUI

```bash
python -m src.main
```

### ConfiguraÃ§Ã£o Inicial

**Acesse no navegador:** `http://localhost:8553`

1. **Upload de CurrÃ­culo**: Carregue seu CV (PDF ou DOCX)
2. **Credenciais**: Configure seu login do LinkedIn
3. **Filtros**: Defina os cargos e localizaÃ§Ã£o desejados
4. **Iniciar**: Clique em "Iniciar BOT"

## âš™ï¸ OpSec (SeguranÃ§a Operacional)

O BOTLink implementa medidas rigorosas para evitar bloqueios:

| Regra | DescriÃ§Ã£o |
|-------|-----------|
| **Limite DiÃ¡rio** | MÃ¡ximo 40-50 candidaturas por dia |
| **Warm-up** | Contas novas: 10 â†’ 20 â†’ 30 â†’ 40/dia |
| **Delays** | 1.5-4.0s entre aÃ§Ãµes, 2-10min entre candidaturas |
| **Pausas** | 15-30min a cada 10 candidaturas |
| **Abort** | Para apÃ³s 3 erros consecutivos |

## ðŸ—ï¸ Arquitetura

```
src/
â”œâ”€â”€ domain/          # Entidades e lÃ³gica de negÃ³cio
â”œâ”€â”€ application/     # Casos de uso
â”œâ”€â”€ infrastructure/  # Adaptadores (Browser, AI, DB)
â””â”€â”€ presentation/    # GUI (Flet)
```

Seguindo **Clean Architecture** com separaÃ§Ã£o clara de responsabilidades.

## ðŸ§ª Testes

```bash
# Rodar todos os testes
python -m pytest tests/ -v

# Com cobertura
python -m pytest tests/ --cov=src --cov-report=html
```

## ðŸ“ VariÃ¡veis de Ambiente

| VariÃ¡vel | DescriÃ§Ã£o | PadrÃ£o |
|----------|-----------|--------|
| `OPENAI_API_KEY` | Sua API key do OpenAI | - |
| `BOTLINK_DAILY_LIMIT` | Limite diÃ¡rio de candidaturas | 50 |
| `BOTLINK_HEADLESS` | Rodar navegador sem janela | false |
| `BOTLINK_LOG_LEVEL` | NÃ­vel de log (DEBUG/INFO) | INFO |

## âš ï¸ Aviso Legal

Este software Ã© fornecido para fins educacionais. O uso de automaÃ§Ã£o em plataformas pode violar seus termos de serviÃ§o. Use por sua conta e risco.

## ðŸ“„ LicenÃ§a

MIT License - veja [LICENSE](LICENSE) para detalhes.
</file>

<file path="requirements.txt">
# BOTLink Dependencies
# Core
flet>=0.21.0
playwright>=1.40.0
openai>=1.12.0

# Document Parsing
pymupdf>=1.23.0
python-docx>=1.1.0

# Security
cryptography>=42.0.0

# Data Validation
pydantic>=2.5.0
pydantic-settings>=2.1.0

# Database
aiosqlite>=0.19.0

# Development
pytest>=7.4.0
pytest-asyncio>=0.23.0
pytest-cov>=4.1.0
ruff>=0.1.0
mypy>=1.8.0
</file>

</files>
